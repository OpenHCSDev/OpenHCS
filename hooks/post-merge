#!/bin/bash
# Update submodules to latest on their tracked branches after merge/pull
# This complements post-checkout which runs when switching branches

echo "Updating submodules after merge..."

# Get list of submodules and process
git submodule status | while IFS= read -r line; do
    [ -z "$line" ] && continue
    
    # Parse: SHA path (version)
    sha=$(echo "$line" | awk '{print $1}')
    path=$(echo "$line" | awk '{print $2}')
    name=$(basename "$path")
    
    # Remove leading + or - from SHA
    sha=${sha#+}
    sha=${sha#-}
    
    # Check if submodule is clean (no staged, unstaged, or untracked changes)
    if (cd "$path" && git diff --quiet HEAD && git diff --cached --quiet HEAD && [ -z "$(git ls-files --others --exclude-standard)" ] 2>/dev/null); then
        # Clean - try to update to latest on remote branch
        current=$(cd "$path" && git rev-parse --short HEAD)
        if git submodule update --remote "$path" >/dev/null 2>&1; then
            new=$(cd "$path" && git rev-parse --short HEAD)
            if [ "$current" != "$new" ]; then
                echo "Updated: $name ($current â†’ $new)"
            fi
        fi
        
        # Checkout the tracking branch to avoid detached HEAD
        branch=$(cd "$path" && git config -f "$toplevel/.gitmodules" submodule."$name".branch 2>/dev/null || echo main)
        if (cd "$path" && git checkout "$branch" >/dev/null 2>&1); then
            # Pull latest if we're now on the branch
            if (cd "$path" && git pull --ff-only >/dev/null 2>&1); then
                : # Successfully pulled
            fi
        fi
    else
        # Dirty - skip
        echo "Skipped: $name (uncommitted changes)"
    fi
done

echo "Done. Run 'git submodule status' to see current state."
