#!/bin/bash
# Update submodules individually - update clean ones, skip dirty ones

echo "Checking submodules..."

# Get list of submodules and process
git submodule status | while IFS= read -r line; do
    [ -z "$line" ] && continue
    
    # Parse: SHA path (version)
    sha=$(echo "$line" | awk '{print $1}')
    path=$(echo "$line" | awk '{print $2}')
    name=$(basename "$path")
    
    # Remove leading + or - from SHA
    sha=${sha#+}
    sha=${sha#-}
    
    # Check if submodule is clean (no staged, unstaged, or untracked changes)
    if (cd "$path" && git diff --quiet HEAD && git diff --cached --quiet HEAD && [ -z "$(git ls-files --others --exclude-standard)" ] 2>/dev/null); then
        # Clean - try to update
        current=$(cd "$path" && git rev-parse --short HEAD)
        if git submodule update --remote "$path" >/dev/null 2>&1; then
            new=$(cd "$path" && git rev-parse --short HEAD)
            if [ "$current" != "$new" ]; then
                echo "Updated: $name ($current â†’ $new)"
            fi
        fi
    else
        # Dirty - skip
        echo "Skipped: $name (uncommitted changes)"
    fi
done

echo "Done. Run 'git submodule status' to see current state."
