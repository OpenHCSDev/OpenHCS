"""
OpenHCS Pipeline - Converted from CellProfiler
Source: ExampleHuman.cppipe

Auto-generated by CellProfiler â†’ OpenHCS converter.
"""

import numpy as np
from typing import Tuple, List, Optional, Dict, Any
from dataclasses import dataclass
from enum import Enum

# OpenHCS imports
from openhcs.core.steps.function_step import FunctionStep
from openhcs.core.config import LazyProcessingConfig
from openhcs.constants.constants import VariableComponents, GroupBy
from openhcs.core.memory.decorators import numpy
from openhcs.processing.backends.lib_registry.unified_registry import ProcessingContract
from openhcs.core.pipeline.function_contracts import special_outputs
from openhcs.processing.materialization import csv_materializer


# === IdentifyPrimaryObjects ===

def IdentifyPrimaryObjects(image, threshold_value, size_range_min, size_range_max, smoothing_filter_size, maxima_color, maxima_size, want_plot_maxima):
    # Convert image to grayscale if it's not already
    if len(image.shape) == 3:
        image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Apply thresholding
    _, binary_image = cv2.threshold(image, threshold_value, 255, cv2.THRESH_BINARY)

    # Apply morphological operations to remove noise and improve object detection
    kernel = np.ones((3, 3), np.uint8)
    binary_image = cv2.morphologyEx(binary_image, cv2.MORPH_OPEN, kernel)
    binary_image = cv2.morphologyEx(binary_image, cv2.MORPH_CLOSE, kernel)

    # Find contours of objects
    contours, _ = cv2.findContours(binary_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Filter contours based on size range
    filtered_contours = []
    for contour in contours:
        area = cv2.contourArea(contour)
        if area >= np.pi * (size_range_min ** 2) / 4 and area <= np.pi * (size_range_max ** 2) / 4:
            filtered_contours.append(contour)

    # Draw contours on the original image
    result_image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)
    cv2.drawContours(result_image, filtered_contours, -1, (0, 255, 0), 2)

    # Plot maxima if required
    if want_plot_maxima:
        maxima_mask = np.zeros_like(binary_image, dtype=np.uint8)
        for contour in filtered_contours:
            M = cv2.moments(contour)
            cX = int(M["m10"] / M["m00"])
            cY = int(M["m01"] / M["m00"])
            cv2.circle(maxima_mask, (cX, cY), maxima_size, 255, -1)

        result_image = cv2.cvtColor(result_image, cv2.COLOR_BGR2GRAY)
        result_image = cv2.addWeighted(result_image, 0.7, maxima_mask, 0.3, 0)

    # Return the result image
    return result_image

# === IdentifySecondaryObjects ===

class IdentifySecondaryObjects(IdentifyObjectsBase):
    module_name = "IdentifySecondaryObjects"
    category = "Object Identification"

    image_name = Parameter("Image", type=str, default="Input Image")
    x_name = Parameter("Primary Object Name", type=str, default="Primary Objects")
    y_name = Parameter("Secondary Object Name", type=str, default="Secondary Objects")
    show_window = Parameter("Show Window", type=bool, default=True)
    method = EnumParameter(
        "Method",
        type=Enum,
        values=[M_DISTANCE_N, M_THRESHOLD, M_Watershed],
        default=M_DISTANCE_N,
    )
    distance_threshold = Parameter("Distance Threshold", type=float, default=10.0)
    threshold = Threshold()

    new_primary_objects_name = Parameter(
        "New Primary Object Name", type=str, default="Filtered Primary Objects"
    )

    wants_discard_edge = Parameter("Discard Edge Objects", type=bool, default=False)
    wants_discard_primary = Parameter(
        "Discard Primary Objects", type=bool, default=False
    )

    def get_parameters(self):
        return [
            self.image_name,
            self.x_name,
            self.y_name,
            self.show_window,
            self.method,
            self.distance_threshold,
            self.threshold.get_parameters(),
            self.new_primary_objects_name,
            self.wants_discard_edge,
            self.wants_discard_primary,
        ]

    def get_measurement_columns(self, pipeline):
        if self.wants_discard_edge and self.wants_discard_primary:
            columns = super(IdentifySecondaryObjects, self).get_measurement_columns(
                pipeline,
                additional_objects=[
                    (self.x_name.value, self.new_primary_objects_name.value)
                ],
            )

            columns += [
                (
                    self.new_primary_objects_name.value,
                    FF_CHILDREN_COUNT % self.y_name.value,
                    "integer",
                ),
                (
                    self.y_name.value,
                    FF_PARENT % self.new_primary_objects_name.value,
                    "integer",
                ),
            ]
        else:
            columns = super(IdentifySecondaryObjects, self).get_measurement_columns(
                pipeline
            )

        if self.method != M_DISTANCE_N:
            columns += self.threshold.get_measurement_columns(
                pipeline, object_name=self.y_name.value
            )

        return columns

    def get_categories(self, pipeline, object_name):
        categories = super(IdentifySecondaryObjects, self).get_categories(
            pipeline, object_name
        )

        if self.method != M_DISTANCE_N:
            categories += self.threshold.get_categories(pipeline, object_name)

        if self.wants_discard_edge and self.wants_discard_primary:
            if object_name == self.new_primary_objects_name.value:
                # new_primary_objects_name objects has the same categories as y_name objects
                categories += super(IdentifySecondaryObjects, self).get_categories(
                    pipeline, self.y_name.value
                )

                categories += [C_CHILDREN]

        return categories

    def get_measurements(self, pipeline, object_name, category):
        measurements = super(IdentifySecondaryObjects, self).get_measurements(
            pipeline, object_name, category
        )

        if self.method.value != M_DISTANCE_N:
            measurements += self.threshold.get_measurements(
                pipeline, object_name, category
            )

        if self.wants_discard_edge and self.wants_discard_primary:
            if object_name == "Image" and category == C_COUNT:
                measurements += [self.new_primary_objects_name.value]

            if object_name == self.y_name.value and category == C_PARENT:
                measurements += [self.new_primary_objects_name.value]

            if object_name == self.new_primary_objects_name.value:
                if category == C_LOCATION:
                    measurements += [
                        FTR_CENTER_X,
                        FTR_CENTER_Y,
                        FTR_CENTER_Z,
                    ]

                if category == C_NUMBER:
                    measurements += [FTR_OBJECT_NUMBER]

                if category == C_PARENT:
                    measurements += [self.x_name.value]

            if category == C_CHILDREN:
                if object_name == self.x_name.value:
                    measurements += ["%s_Count" % self.new_primary_objects_name.value]

                if object_name == self.new_primary_objects_name.value:
                    measurements += ["%s_Count" % self.y_name.value]

        return measurements

    def get_measurement_objects(self, pipeline, object_name, category, measurement):
        threshold_measurements = self.threshold.get_measurements(
            pipeline, object_name, category
        )

        if self.method != M_DISTANCE_N and measurement in threshold_measurements:
            return [self.y_name.value]

        return []

    def display(self, workspace, figure):
        object_pct = workspace.display_data.object_pct
        img = workspace.display_data.img
        primary_labels = workspace.display_data.primary_labels
        segmented_out = workspace.display_data.segmented_out
        global_threshold = workspace.display_data.global_threshold
        object_count = workspace.display_data.object_count
        statistics = workspace.display_data.statistics

        if global_threshold is not None:
            statistics.append(["Threshold", "%0.3g" % global_threshold])

        if object_count > 0:
            areas = scipy.ndimage.sum(
                numpy.ones(segmented_out.shape),
                segmented_out,
                numpy.arange(1, object_count + 1),
            )
            areas.sort()
            low_diameter = numpy.sqrt(float(areas[object_count // 10]) / numpy.pi) * 2
            median_diameter = numpy.sqrt(float(areas[object_count // 2]) / numpy.pi) * 2
            high_diameter = (
                numpy.sqrt(float(areas[object_count * 9 // 10]) / numpy.pi) * 2
            )
            statistics.append(["10th pctile diameter", "%.1f pixels" % low_diameter])
            statistics.append(["Median diameter", "%.1f pixels" % median_diameter])
            statistics.append(["90th pctile diameter", "%.1f pixels" % high_diameter])
            if self.method != M_DISTANCE_N:
                statistics.append(
                    [
                        "Thresholding filter size",
                        "%.1f" % workspace.display_data.threshold_sigma,
                    ]
                )
            statistics.append(["Area covered by objects", "%.1f %%" % object_pct])
        workspace.display_data.statistics = statistics

        figure.set_subplots((2, 2))
        title = "Input image, cycle #%d" % workspace.measurements.image_number
        figure.subplot_imshow_grayscale(0, 0, img, title)
        figure.subplot_imshow_labels(
            1,
            0,
            segmented_out,
            "%s objects" % self.y_name.value,
            sharexy=figure.subplot(0, 0),
        )

        cplabels = [
            dict(name=self.x_name.value, labels=[primary_labels]),
            dict(name=self.y_name.value, labels=[segmented_out]),
        ]
        title = "%s and %s outlines" % (self.x_name.value, self.y_name.value)
        figure.subplot_imshow_grayscale(
            0, 1, img, title=title, cplabels=cplabels, sharexy=figure.subplot(0, 0)
        )
        figure.subplot_table(
            1,
            1,
            [[x[1]] for x in workspace.display_data.statistics],
            row_labels=[x[0] for x in workspace.display_data.statistics],
        )

    def is_object_identification_module(self):
        return True

    def run(self, workspace):
        self.threshold.run(workspace)
        self.filter_labels(workspace)

    def filter_labels(self, workspace):
        """Filter labels out of the output

        Filter labels that are not in the segmented input labels. Optionally
        filter labels that are touching the edge.

        labels_out - the unfiltered output labels
        objects    - the objects thing, containing both segmented and
                     small_removed labels
        """
        image = workspace.image_set.get_image(self.image_name.value)
        segmented_labels = workspace.display_data.segmented_out
        max_out = numpy.max(segmented_labels)
        if max_out > 0:
            segmented_labels, m1 = size_similarly(segmented_labels, image.segmented)
            segmented_labels[~m1] = 0
            lookup = scipy.ndimage.maximum(
                segmented_labels, image.segmented, list(range(max_out + 1))
            )
            lookup = numpy.array(lookup, int)
            lookup[0] = 0
            segmented_labels_out = lookup[segmented_labels]
        else:
            segmented_labels_out = segmented_labels.copy()
        if self.wants_discard_edge:
            mask_border = image.mask & ~scipy.ndimage.binary_erosion(image.mask)
            edge_labels = segmented_labels_out[mask_border]
            edge_labels = numpy.unique(edge_labels)
            lookup = numpy.arange(max(max_out, numpy.max(segmented_labels)) + 1)
            lookup[edge_labels] = 0
            segmented_labels_out = lookup[segmented_labels_out]

        workspace.display_data.segmented_out = segmented_labels_out

    def display(self, workspace, figure):
        object_pct = workspace.display_data.object_pct
        img = workspace.display_data.img
        primary_labels = workspace.display_data.primary_labels
        segmented_out = workspace.display_data.segmented_out
        global_threshold = workspace.display_data.global_threshold
        object_count = workspace.display_data.object_count
        statistics = workspace.display_data.statistics

        if global_threshold is not None:
            statistics.append(["Threshold", "%0.3g" % global_threshold])

        if object_count > 0:
            areas = scipy.ndimage.sum(
                numpy.ones(segmented_out.shape),
                segmented_out,
                numpy.arange(1, object_count + 1),
            )
            areas.sort()
            low_diameter = numpy.sqrt(float(areas[object_count // 10]) / numpy.pi) * 2
            median_diameter = numpy.sqrt(float(areas[object_count // 2]) / numpy.pi) * 2
            high_diameter = (
                numpy.sqrt(float(areas[object_count * 9 // 10]) / numpy.pi) * 2
            )
            statistics.append(["10th pctile diameter", "%.1f pixels" % low_diameter])
            statistics.append(["Median diameter", "%.1f pixels" % median_diameter])
            statistics.append(["90th pctile diameter", "%.1f pixels" % high_diameter])
            if self.method != M_DISTANCE_N:
                statistics.append(
                    [
                        "Thresholding filter size",
                        "%.1f" % workspace.display_data.threshold_sigma,
                    ]
                )
            statistics.append(["Area covered by objects", "%.1f %%" % object_pct])
        workspace.display_data.statistics = statistics

        figure.set_subplots((2, 2))
        title = "Input image, cycle #%d" % workspace.measurements.image_number
        figure.subplot_imshow_grayscale(0, 0, img, title)
        figure.subplot_imshow_labels(
            1,
            0,
            segmented_out,
            "%s objects" % self.y_name.value,
            sharexy=figure.subplot(0, 0),
        )

        cplabels = [
            dict(name=self.x_name.value, labels=[primary_labels]),
            dict(name=self.y_name.value, labels=[segmented_out]),
        ]
        title = "%s and %s outlines" % (self.x_name.value, self.y_name.value)
        figure.subplot_imshow_grayscale(
            0, 1, img, title=title, cplabels=cplabels, sharexy=figure.subplot(0, 0)
        )
        figure.subplot_table(
            1,
            1,
            [[x[1]] for x in workspace.display_data.statistics],
            row_labels=[x[0] for x in workspace.display_data.statistics],
        )

    def is_object_identification_module(self):
        return True

# === MeasureObjectIntensity ===

def measure_intensity_and_location(image, labels, measurements, show_window=False):
    import numpy as np
    from skimage.measure import regionprops

    integrated_intensity = []
    mean_intensity = []
    std_intensity = []
    min_intensity = []
    max_intensity = []
    cmi_x = []
    cmi_y = []
    cmi_z = []
    max_x = []
    max_y = []
    max_z = []
    mass_displacement = []
    lower_quartile_intensity = []
    median_intensity = []
    mad_intensity = []
    upper_quartile_intensity = []

    for label in np.unique(labels):
        region = regionprops(labels, intensity_image=image, label=label)
        if len(region) > 0:
            props = region[0]
            integrated_intensity.append(props.mean_intensity * props.area)
            mean_intensity.append(props.mean_intensity)
            std_intensity.append(props.std_intensity)
            min_intensity.append(props.min_intensity)
            max_intensity.append(props.max_intensity)
            cmi_x.append(props.centroid[1])
            cmi_y.append(props.centroid[0])
            cmi_z.append(props.centroid[2])
            max_x.append(props.local_max_coords[1][0])
            max_y.append(props.local_max_coords[0][0])
            max_z.append(props.local_max_coords[2][0])
            mass_displacement.append(np.sqrt((props.centroid[1] - props.local_max_coords[1][0])**2 + (props.centroid[0] - props.local_max_coords[0][0])**2 + (props.centroid[2] - props.local_max_coords[2][0])**2))
            lower_quartile_intensity.append(np.percentile(props.intensity_image, 25))
            median_intensity.append(np.percentile(props.intensity_image, 50))
            mad_intensity.append(np.median(np.abs(props.intensity_image - np.median(props.intensity_image))))
            upper_quartile_intensity.append(np.percentile(props.intensity_image, 75))

    measurements.add_measurement('default', 'integrated_intensity', integrated_intensity)
    measurements.add_measurement('default', 'mean_intensity', mean_intensity)
    measurements.add_measurement('default', 'std_intensity', std_intensity)
    measurements.add_measurement('default', 'min_intensity', min_intensity)
    measurements.add_measurement('default', 'max_intensity', max_intensity)
    measurements.add_measurement('default', 'cmi_x', cmi_x)
    measurements.add_measurement('default', 'cmi_y', cmi_y)
    measurements.add_measurement('default', 'cmi_z', cmi_z)
    measurements.add_measurement('default', 'max_x', max_x)
    measurements.add_measurement('default', 'max_y', max_y)
    measurements.add_measurement('default', 'max_z', max_z)
    measurements.add_measurement('default', 'mass_displacement', mass_displacement)
    measurements.add_measurement('default', 'lower_quartile_intensity', lower_quartile_intensity)
    measurements.add_measurement('default', 'median_intensity', median_intensity)
    measurements.add_measurement('default', 'mad_intensity', mad_intensity)
    measurements.add_measurement('default', 'upper_quartile_intensity', upper_quartile_intensity)

    if show_window:
        import matplotlib.pyplot as plt
        fig, ax = plt.subplots()
        ax.boxplot([integrated_intensity, mean_intensity, std_intensity, min_intensity, max_intensity, cmi_x, cmi_y, cmi_z, max_x, max_y, max_z, mass_displacement, lower_quartile_intensity, median_intensity, mad_intensity, upper_quartile_intensity])
        ax.set_xticklabels(['integrated_intensity', 'mean_intensity', 'std_intensity', 'min_intensity', 'max_intensity', 'cmi_x', 'cmi_y', 'cmi_z', 'max_x', 'max_y', 'max_z', 'mass_displacement', 'lower_quartile_intensity', 'median_intensity', 'mad_intensity', 'upper_quartile_intensity'])
        plt.show()

# === MeasureObjectSizeShape ===

"""
Converted from CellProfiler: MeasureObjectSizeShape

Original: measureobjectsizeshape
"""

import numpy as np
from typing import Tuple, List, Optional
from dataclasses import dataclass
from openhcs.core.memory.decorators import numpy
from openhcs.processing.backends.lib_registry.unified_registry import ProcessingContract
from openhcs.core.pipeline.function_contracts import special_outputs
from openhcs.processing.materialization import csv_materializer

@dataclass
class ObjectMeasurement:
    slice_index: int
    label: int
    area: float
    perimeter: float
    bbox_area: float
    major_axis_length: float
    minor_axis_length: float
    orientation: float
    centroid: Tuple[float, float]
    equivalent_diameter: float
    extent: float
    eccentricity: float
    convex_area: float
    solidity: float
    euler_number: int

@numpy(contract=ProcessingContract.PURE_2D)
@special_outputs(("measurements", csv_materializer(
    fields=["slice_index", "label", "area", "perimeter", "bbox_area", "major_axis_length", "minor_axis_length", "orientation", "centroid", "equivalent_diameter", "extent", "eccentricity", "convex_area", "solidity", "euler_number"],
    analysis_type="object_measurements"
)))
def measure_object_size_shape(
    objects: np.ndarray,
    calculate_advanced: bool = False,
    calculate_zernikes: bool = True,
    spacing: Tuple[float, float] = None
) -> Tuple[np.ndarray, List[ObjectMeasurement]]:
    """Measure size and shape features of objects."""
    
    if len(objects[objects != 0]) == 0:
        return np.zeros((0,)), []

    labels = convert_dense_to_label_set(objects, validate=False)
    labels = [i[0] for i in labels]

    measurements = []
    for labelmap in labels:
        buffer, measured_labels, nobjects = measure_object_size_shape(
            labels=labelmap,
            desired_properties=[
                "label",
                "area",
                "perimeter",
                "bbox_area",
                "major_axis_length",
                "minor_axis_length",
                "orientation",
                "centroid",
                "equivalent_diameter",
                "extent",
                "eccentricity",
                "convex_area",
                "solidity",
                "euler_number"
            ],
            calculate_zernikes=calculate_zernikes,
            calculate_advanced=calculate_advanced,
            spacing=spacing
        )
        
        for f, m in buffer.items():
            if f == "label":
                labels = m
            else:
                measurements.extend([
                    ObjectMeasurement(
                        slice_index=0,
                        label=int(label),
                        area=float(area),
                        perimeter=float(perimeter),
                        bbox_area=float(bbox_area),
                        major_axis_length=float(major_axis_length),
                        minor_axis_length=float(minor_axis_length),
                        orientation=float(orientation),
                        centroid=(float(x), float(y)),
                        equivalent_diameter=float(equivalent_diameter),
                        extent=float(extent),
                        eccentricity=float(eccentricity),
                        convex_area=float(convex_area),
                        solidity=float(solidity),
                        euler_number=int(euler_number)
                    )
                    for label, area, perimeter, bbox_area, major_axis_length, minor_axis_length, orientation, (x, y), equivalent_diameter, extent, eccentricity, convex_area, solidity, euler_number in zip(labels, m["area"], m["perimeter"], m["bbox_area"], m["major_axis_length"], m["minor_axis_length"], m["orientation"], m["centroid"], m["equivalent_diameter"], m["extent"], m["eccentricity"], m["convex_area"], m["solidity"], m["euler_number"])
                ])

    return np.zeros((0,)), measurements

# Pipeline Steps
pipeline_steps = [
    FunctionStep(
        func=identify_primary_objects,
        name="IdentifyPrimaryObjects",
        processing_config=LazyProcessingConfig(
            variable_components=[VariableComponents.SITE]
        )
    ),
    FunctionStep(
        func=identify_secondary_objects,
        name="IdentifySecondaryObjects",
        processing_config=LazyProcessingConfig(
            variable_components=[VariableComponents.SITE]
        )
    ),
    FunctionStep(
        func=measure_object_intensity,
        name="MeasureObjectIntensity",
        processing_config=LazyProcessingConfig(
            variable_components=[VariableComponents.SITE]
        )
    ),
    FunctionStep(
        func=measure_object_size_shape,
        name="MeasureObjectSizeShape",
        processing_config=LazyProcessingConfig(
            variable_components=[VariableComponents.SITE]
        )
    ),
]