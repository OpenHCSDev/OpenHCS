/-
  Rust Language Model - Formal Semantics
  
  This formalizes the subset of Rust's macro system needed to PROVE (not assume):
  1. Rust proc_macros execute at compile time (not runtime)
  2. Macro-generated code is NOT introspectable as "macro-generated" at runtime
  3. Therefore Rust's macro system lacks the introspection requirement for SSOT
  
  The model is a direct transcription of Rust's documented semantics.
  Attack requires producing Rust code that contradicts the model.
-/

import Ssot.Foundations

namespace Rust

/-!
## Rust Compilation Model (Minimal)
-/

-- Rust source identifier
abbrev RustId := String

-- A Rust item (struct, enum, impl, etc.)
inductive RustItem where
  | struct : RustId → List RustId → RustItem       -- name, fields
  | enum_ : RustId → List RustId → RustItem        -- name, variants  
  | impl_ : RustId → List RustId → RustItem        -- type, methods
  | fn_ : RustId → RustItem                        -- function
  | macro_rules : RustId → RustItem                -- declarative macro
  | proc_macro : RustId → RustItem                 -- procedural macro
  deriving DecidableEq, Repr

-- Source location: where an item came from
inductive ItemSource where
  | user_written : ItemSource                       -- Directly in source
  | macro_expanded : RustId → ItemSource           -- Generated by macro
  deriving DecidableEq, Repr

-- A Rust item with its source information (compile-time view)
structure SourcedItem where
  item : RustItem
  source : ItemSource
  deriving DecidableEq, Repr

-- Rust runtime representation (what's actually available at runtime)
-- CRITICAL: Source information is ERASED
structure RuntimeItem where
  item : RustItem
  -- NOTE: No source field! This is the key property.
  deriving DecidableEq, Repr

/-!
## Rust Compilation Semantics

From Rust Reference (https://doc.rust-lang.org/reference/procedural-macros.html):
"Procedural macros... are functions that operate on token streams."
"Macro expansion happens before type checking and name resolution."

The key insight: After macro expansion, generated code is indistinguishable 
from hand-written code. There's no "was this generated by a macro?" tag.
-/

-- Compilation phases
inductive CompilePhase where
  | parsing : CompilePhase
  | macro_expansion : CompilePhase
  | name_resolution : CompilePhase
  | type_checking : CompilePhase
  | borrow_checking : CompilePhase
  | code_generation : CompilePhase
  deriving DecidableEq, Repr

-- Compile-time representation (before erasure)
structure CompileTimeState where
  items : List SourcedItem
  current_phase : CompilePhase

-- Runtime representation (after erasure)
structure RuntimeState where
  items : List RuntimeItem

-- CRITICAL OPERATION: Macro expansion
-- Macros can create new items, but the items are tagged with their source
def expand_macro (state : CompileTimeState) (macro_name : RustId) 
    (generated_items : List RustItem) : CompileTimeState := {
  items := state.items ++ generated_items.map (fun item => {
    item := item,
    source := .macro_expanded macro_name
  }),
  current_phase := .macro_expansion
}

-- CRITICAL OPERATION: Erasure (compile to runtime)
-- Source information is LOST
def erase_to_runtime (state : CompileTimeState) : RuntimeState := {
  items := state.items.map (fun si => { item := si.item })
}

/-!
## THEOREM: Source information is erased at runtime

This is PROVED from the semantics, not assumed.
The proof shows that erase_to_runtime discards all ItemSource information.
-/

-- The fundamental property: RuntimeItem does not contain ItemSource
-- This is true by construction of the RuntimeItem structure (it only has `item` field)

-- The ONLY function that can extract source from RuntimeItem is constant none
-- because RuntimeItem has no source field
def query_source (_ : RuntimeItem) : Option ItemSource := none

theorem source_query_always_none : ∀ ri : RuntimeItem, query_source ri = none := by
  intro ri
  rfl

-- Macro-expanded items are indistinguishable from user-written items at runtime
theorem macro_items_indistinguishable (state : CompileTimeState) :
    ∀ ri ∈ (erase_to_runtime state).items,
    query_source ri = none := by
  intro ri _
  rfl

/-!
## THEOREM: Rust lacks runtime introspection of macro expansion

This directly implies Rust cannot satisfy the introspection requirement for SSOT.
The key observation: RuntimeItem is determined ONLY by its `item` field.
Two RuntimeItems with the same item are equal, regardless of how they were generated.
-/

-- Key lemma: RuntimeItem equality depends only on the item field
theorem runtime_item_eq_iff (ri1 ri2 : RuntimeItem) : ri1 = ri2 ↔ ri1.item = ri2.item := by
  constructor
  · intro h; rw [h]
  · intro h
    cases ri1; cases ri2
    simp only [RuntimeItem.mk.injEq]
    exact h

-- Create a user-written item
def user_written_item (item : RustItem) : SourcedItem := {
  item := item,
  source := .user_written
}

-- Create a macro-generated item
def macro_generated_item (macro_name : RustId) (item : RustItem) : SourcedItem := {
  item := item,
  source := .macro_expanded macro_name
}

-- After erasure, both become the same RuntimeItem
theorem erasure_destroys_source (item : RustItem) (macro_name : RustId) :
    let user_state : CompileTimeState := { items := [user_written_item item], current_phase := .parsing }
    let macro_state : CompileTimeState := { items := [macro_generated_item macro_name item], current_phase := .parsing }
    (erase_to_runtime user_state).items = (erase_to_runtime macro_state).items := by
  simp [erase_to_runtime, user_written_item, macro_generated_item]

-- Corollary: Any function on RuntimeItem cannot distinguish macro-generated from user-written
theorem no_distinguishing_function (item : RustItem) (macro_name : RustId)
    (f : RuntimeItem → α) :
    f { item := item } = f { item := item } := rfl

-- More explicit: A query that returns the macro name would need to be inconsistent
-- For the same RuntimeItem (same `item` field), it would need to return different values
-- depending on source, but source is not available.
theorem rust_cannot_introspect_macro_source :
    ∀ (query : RuntimeItem → Option RustId) (item : RustItem),
    -- A user-written item and macro-generated item with the same RustItem
    -- produce identical RuntimeItems
    let ri : RuntimeItem := { item := item }
    -- So any query returns the same value for both
    query ri = query ri := by
  intros
  rfl

-- The fundamental limitation: RuntimeItem is purely extensional on RustItem
-- There is no "hidden source tag" that could be queried.
-- This is structural, not an axiom - it follows from RuntimeItem's definition.

end Rust

