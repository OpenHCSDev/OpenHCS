\section{Introduction}\label{introduction}

\subsection{The Encoding Problem}\label{sec:encoding-problem}

Consider an information system storing a fact $F$ (e.g., a threshold value, a configuration parameter, or a structural relationship) at $n$ locations. When can such a system guarantee \textbf{coherence}---the impossibility of disagreement among locations?

If location $L_1$ encodes ``threshold = 0.5'' while location $L_2$ encodes ``threshold = 0.7'', which is correct? No information internal to the system determines this. Any resolution requires external side information (timestamps, priority orderings, external oracles) not present in the encodings themselves.

This is an \textbf{information-theoretic} problem: what rate (number of independent encoding locations) guarantees zero-error decoding under modification constraints? We prove that exactly one independent encoding (DOF = 1, where DOF counts independent storage locations) is necessary and sufficient for guaranteed coherence.

\begin{theorem}[Resolution Impossibility, informal]
For any incoherent encoding system (DOF $> 1$ with divergent values) and any resolution procedure selecting a value, there exists an equally-present value that disagrees. No resolution is information-theoretically justified.
\end{theorem}

This parallels zero-error capacity constraints~\cite{korner1973graphs,lovasz1979shannon}: without sufficient side information, error-free decoding is impossible. Our contribution extends this to \textbf{interactive encoding systems} with modification requirements.

\subsection{The Optimal Rate Theorem}\label{sec:optimal-rate}

We prove that DOF = 1 is the \textbf{unique optimal rate} for coherent encoding:

\begin{itemize}
\tightlist
\item \textbf{DOF = 0:} Fact $F$ is not encoded (no information stored)
\item \textbf{DOF = 1:} Coherence guaranteed (unique independent source)
\item \textbf{DOF $> 1$:} Incoherent configurations reachable (multiple independent sources can diverge)
\end{itemize}

This generalizes Rissanen's Minimum Description Length (MDL) principle~\cite{rissanen1978mdl,gruenwald2007mdl} to systems with update constraints. MDL optimizes description length for static data; we optimize encoding rate for modifiable facts. The singleton solution space---exactly one rate achieves coherence---makes this a \textbf{forcing theorem}: given coherence as a requirement, DOF = 1 is mathematically necessary.

\subsection{Applications Across Domains}\label{sec:applications}

The abstract encoding model applies wherever facts are stored redundantly:

\begin{itemize}
\tightlist
\item \textbf{Distributed databases:} Replica consistency under partition constraints~\cite{brewer2000cap}
\item \textbf{Version control:} Merge resolution when branches diverge~\cite{hunt2002vcdiff}
\item \textbf{Configuration systems:} Multi-file settings with coherence requirements~\cite{delaet2010survey}
\item \textbf{Software systems:} Class registries, type definitions, interface contracts~\cite{hunt1999pragmatic}
\end{itemize}

In each domain, the question is identical: given multiple encoding locations, which is authoritative? Our theorems characterize when this question has a unique answer (DOF = 1) versus when it requires arbitrary external resolution (DOF $> 1$).

\subsection{Connection to Classical Information Theory}\label{sec:connection-it}

Our results extend classical encoding theory in three ways:

\textbf{1. From static to interactive encoding.} Shannon's source coding theorem~\cite{shannon1948mathematical} characterizes optimal encoding for static data. Slepian-Wolf~\cite{slepian1973noiseless} extends this to distributed sources with side information. We extend to \textbf{interactive systems} where encodings can be modified and must remain coherent across modifications.

\textbf{2. Zero-error requirement with modification constraints.} Classical zero-error capacity~\cite{korner1973graphs,lovasz1979shannon} characterizes communication without errors. We characterize \textbf{encoding without incoherence}---a storage analog where errors are disagreements among locations, not bit flips.

\textbf{3. Rate-complexity tradeoffs.} Rate-distortion theory~\cite{cover2006elements} trades encoding rate against distortion. We trade encoding rate (DOF) against modification complexity: DOF = 1 achieves $O(1)$ updates; DOF $> 1$ requires $\Omega(n)$ synchronization.

\subsection{Realizability in Computational Systems}\label{sec:realizability}

A key question: can the abstract optimality (DOF = 1) be \textbf{realized} in computational systems? We prove realizability requires two information-theoretic encoder properties:

\begin{enumerate}
\item \textbf{Causal update propagation:} Changes to the source must automatically trigger updates to derived locations. This is analogous to channel coding with feedback---the encoder (source) and decoder (derived locations) are coupled in real-time. Without causal propagation, a temporal window exists where source and derived locations diverge (temporary incoherence).

\item \textbf{Provenance observability:} The system must support queries about derivation structure (what is derived from what). This is the encoding-system analog of Slepian-Wolf side information~\cite{slepian1973noiseless}---the decoder has access to structural information enabling verification.
\end{enumerate}

These abstract to arbitrary encoding systems; programming language features (definition-time hooks, introspection) are one instantiation. Distributed databases use triggers and system catalogs; configuration systems use dependency graphs and state queries.

\textbf{Connection to multi-version coding.} Rashmi et al.~\cite{rashmi2015multiversion} prove an ``inevitable storage cost for consistency'' in distributed storage. Our realizability theorem is analogous: systems lacking causal propagation or provenance observability \emph{cannot} achieve DOF = 1---the cost is fundamental, not implementation-specific.

\textbf{Evaluation across computational systems.} We evaluate programming languages, distributed databases, and configuration systems against these criteria. Among mainstream programming languages (TIOBE top-10, 5+ year consistency), Python uniquely satisfies both requirements (causal propagation via \texttt{\_\_init\_subclass\_\_}, provenance observability via \texttt{\_\_subclasses\_\_()}). Most (Java, C++, Rust, Go, TypeScript) lack one or both and cannot achieve DOF = 1 for structural facts.

\subsection{Paper Organization and Main Results}\label{overview}

This paper establishes four theorems characterizing optimal encoding under coherence constraints. All results are machine-checked in Lean 4~\cite{demoura2021lean4} (9,351 lines, 541 theorems, 0 \texttt{sorry} placeholders).

\textbf{Section~\ref{sec:foundations}---Encoding Model.} We formalize multi-location encoding systems: facts stored at multiple locations with independence and derivability relations. DOF (Degrees of Freedom) counts independent locations. Coherence means all locations agree.

\textbf{Section~\ref{sec:ssot}---Optimal Rate.} We prove DOF = 1 is the unique rate guaranteeing coherence (Theorem~\ref{thm:dof-optimal}). The proof constructs incoherent configurations for all DOF $> 1$ and shows DOF = 1 makes disagreement impossible.

\textbf{Section~\ref{sec:requirements}---Realizability.} We derive necessary and sufficient conditions for encoding systems to achieve DOF = 1 via derivation (Theorem~\ref{thm:ssot-iff}). Both causal update propagation and provenance observability are required---these are information-theoretic encoder properties that abstract across domains.

\textbf{Section~\ref{sec:evaluation}---System Evaluation.} We evaluate computational realizations (programming languages, distributed databases) against formal criteria. Python, CLOS, and Smalltalk satisfy requirements; Java, C++, Rust, Go, TypeScript do not.

\textbf{Section~\ref{sec:bounds}---Complexity Bounds.} We prove the rate-complexity tradeoff: DOF = 1 achieves $O(1)$ modification cost; DOF $> 1$ requires $\Omega(n)$ (Theorem~\ref{thm:unbounded-gap}). The gap grows without bound.

\textbf{Section~\ref{sec:empirical}---Empirical Validation.} Case studies from production systems (OpenHCS~\cite{openhcs2025}) demonstrate DOF reduction (47 $\to$ 1) via Python's definition-time hooks.

\textbf{Connection to software engineering.} The ``Don't Repeat Yourself'' (DRY) principle~\cite{hunt1999pragmatic} in software engineering is the practitioner recognition of encoding optimality. We prove DRY = DOF = 1, formalizing an informal principle with information-theoretic foundations.

\subsection{Core Theorems}\label{sec:core-theorems}

We establish four theorems characterizing optimal encoding under coherence constraints:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Theorem~\ref{thm:oracle-arbitrary} (Resolution Impossibility):} For any incoherent encoding system (DOF $> 1$ with divergent values) and any resolution procedure selecting a value, there exists an equally-present value disagreeing with the selection. No resolution is information-theoretically justified.

  \emph{Proof:} By incoherence, at least two values exist. Any selection leaves another value disagreeing. No side information distinguishes them.

\item
  \textbf{Theorem~\ref{thm:dof-one-coherence} (Optimal Rate):} DOF = 1 guarantees coherence. Exactly one independent encoding makes disagreement impossible.

  \emph{Proof:} All other locations are derived from the single source. Derivation enforces agreement. Single source determines all values.

\item
  \textbf{Theorem~\ref{thm:ssot-iff} (Realizability Requirements):} An encoding system achieves DOF = 1 via derivation if and only if it provides: (a) causal update propagation (source changes automatically trigger derived location updates), and (b) provenance observability (derivation structure is queryable).

  \emph{Proof:} Necessity by constructing incoherent configurations when either is missing. Sufficiency by exhibiting derivation mechanisms achieving DOF = 1. The requirements are information-theoretic encoder properties, not implementation details.

\item
  \textbf{Theorem~\ref{thm:unbounded-gap} (Rate-Complexity Tradeoff):} Modification complexity scales as: DOF = 1 achieves $O(1)$; DOF = $n > 1$ requires $\Omega(n)$. The ratio grows without bound: $\lim_{n \to \infty} \frac{n}{1} = \infty$.

  \emph{Proof:} DOF = 1 updates single source (constant). DOF = $n$ must synchronize $n$ independent locations (linear).
\end{enumerate}

\textbf{Forcing property.} DOF = 1 is the \textbf{unique} rate guaranteeing coherence. DOF = 0 means unencoded; DOF $> 1$ permits incoherence. Given coherence as a requirement, there is no design freedom---the solution is mathematically forced.

\subsection{Scope}\label{sec:scope}

This work characterizes SSOT for \emph{structural facts} (class existence, method signatures, type relationships) within \emph{single-language} systems. The complexity analysis is asymptotic, applying to systems where $n$ grows. External tooling can approximate SSOT behavior but operates outside language semantics.

\textbf{Multi-language systems.} When a system spans multiple languages (e.g., Python backend + TypeScript frontend + protobuf schemas), cross-language SSOT requires external code generation tools. The analysis in this paper characterizes single-language SSOT; multi-language SSOT is noted as future work (Section~\ref{sec:conclusion}).

\subsection{Contributions}\label{sec:contributions}

This paper makes six contributions:

\textbf{1. Epistemic foundations (Section~\ref{sec:epistemic}):}
\begin{itemize}
\tightlist
\item Definition of coherence and incoherence for encoding systems
\item \textbf{Theorem~\ref{thm:oracle-arbitrary} (Oracle Arbitrariness):} Under incoherence, no resolution is principled. The epistemic core.
\item \textbf{Theorem~\ref{thm:dof-one-coherence} (Coherence Forcing):} DOF = 1 guarantees coherence
\item \textbf{Theorem~\ref{thm:dof-gt-one-incoherence}:} DOF $> 1$ permits incoherence
\item \textbf{Corollary~\ref{cor:coherence-forces-ssot}:} Given coherence requirement, DOF = 1 is necessary and sufficient
\end{itemize}

\textbf{2. Software instantiation (Section~\ref{sec:edit-space}):}
\begin{itemize}
\tightlist
\item Mapping: encoding systems $\to$ codebases, facts $\to$ structural specifications
\item Definition of SSOT as DOF = 1 for software
\item Theorem~\ref{thm:ssot-determinate}: SSOT eliminates indeterminacy
\end{itemize}

\textbf{3. Realizability requirements (Section~\ref{sec:requirements}):}
\begin{itemize}
\tightlist
\item Theorem~\ref{thm:causal-necessary}: Causal update propagation is necessary
\item Theorem~\ref{thm:provenance-necessary}: Provenance observability is necessary
\item Theorem~\ref{thm:ssot-iff}: Both together are sufficient
\item Connection to IT: causal propagation $\approx$ channel with feedback; provenance observability $\approx$ Slepian-Wolf side information
\item Connection to WOM codes: structural irreversibility constraint analogous to write-once constraint
\end{itemize}

\textbf{4. Language evaluation (Section~\ref{sec:evaluation}):}
\begin{itemize}
\tightlist
\item Exhaustive evaluation of 10 mainstream languages
\item Extended evaluation of 3 non-mainstream languages (CLOS, Smalltalk, Ruby)
\item Theorem~\ref{thm:three-lang}: Exactly three languages satisfy requirements
\end{itemize}

\textbf{5. Complexity bounds (Section~\ref{sec:bounds}):}
\begin{itemize}
\tightlist
\item Theorem~\ref{thm:upper-bound}: SSOT achieves $O(1)$ coherence restoration
\item Theorem~\ref{thm:lower-bound}: Non-SSOT requires $\Omega(n)$ modifications
\item Theorem~\ref{thm:unbounded-gap}: The gap is unbounded
\end{itemize}

\textbf{6. Practical demonstration (Section~\ref{sec:empirical}):}
\begin{itemize}
\tightlist
\item Before/after examples from OpenHCS (production Python codebase)
\item PR \#44~\cite{openhcsPR44}: Migration from 47 scattered checks to 1 ABC (DOF 47 $\to$ 1)
\item Empirical validation that coherence is achievable in practice
\end{itemize}

\subsection{Empirical Context: OpenHCS}\label{sec:openhcs-context}

\textbf{What it does:} OpenHCS~\cite{openhcs2025} is an open-source bioimage analysis platform for high-content screening (45K LoC Python). It processes microscopy images through configurable pipelines, with GUI-based design and Python code export. The system requires:

\begin{itemize}
\tightlist
\item Automatic registration of analysis components
\item Type-safe configuration with inheritance
\item Runtime enumeration of available processors
\item Provenance tracking for reproducibility
\end{itemize}

\textbf{Why it matters for this paper:} OpenHCS requires SSOT for structural facts. When a new image processor is added (by subclassing \texttt{BaseProcessor}), it must automatically appear in:

\begin{itemize}
\tightlist
\item The GUI component palette
\item The configuration schema
\item The serialization registry
\item The documentation generator
\end{itemize}

Without SSOT, adding a processor requires updating 4+ locations. With SSOT, only the class definition is needed. Python's \texttt{\_\_init\_subclass\_\_} and \texttt{\_\_subclasses\_\_()} handle the rest.

\textbf{Key finding:} PR \#44~\cite{openhcsPR44} migrated from duck typing (\texttt{hasattr()} checks) to nominal typing (ABC contracts). This eliminated 47 scattered checks, reducing DOF from 47 to 1. The migration validates both:
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item The theoretical prediction: DOF reduction is achievable
\item The practical benefit: Maintenance cost decreased measurably
\end{enumerate}

\subsection{Decision Procedure, Not Preference}\label{sec:decision}

The contribution of this paper is not the theorems alone, but their consequence: \emph{language selection for coherent representation becomes a decision procedure}.

Given coherence as a requirement:
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item DOF = 1 is necessary (Corollary~\ref{cor:coherence-forces-ssot})
\item DOF = 1 for structural facts requires definition-time hooks AND introspection (Theorem~\ref{thm:ssot-iff})
\item Languages lacking these features cannot achieve coherence for structural facts
\end{enumerate}

\textbf{Implications:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Language design.} Future languages should include definition-time hooks and introspection if coherent structural representation is a design goal.
\item
  \textbf{Architecture.} When coherence is required, language selection is constrained. ``I prefer Go'' is not valid when structural coherence is required.
\item
  \textbf{Tooling.} External tools can work around language limitations but operate outside language semantics.
\item
  \textbf{Pedagogy.} DRY should be taught as epistemic necessity with language requirements, not as a vague guideline.
\end{enumerate}

\subsection{Paper Structure}\label{sec:structure}

Section~\ref{sec:foundations} establishes epistemic foundations (coherence, oracle arbitrariness) and instantiates them to software. Section~\ref{sec:ssot} defines SSOT as the coherent representation and proves its properties. Section~\ref{sec:requirements} derives language requirements with necessity proofs. Section~\ref{sec:evaluation} evaluates mainstream languages exhaustively. Section~\ref{sec:bounds} proves complexity bounds. Section~\ref{sec:empirical} demonstrates practical application. Section~\ref{sec:related} surveys related work. Appendix~\ref{sec:rebuttals} addresses anticipated objections. Appendix~\ref{sec:lean} contains complete Lean 4 proof listings.

\subsection{Anticipated Objections}\label{sec:objection-summary}

Before proceeding, we address objections readers are likely forming. Each is refuted in detail in Appendix~\ref{sec:rebuttals}; here we summarize the key points.

\paragraph{``The model doesn't capture real Python/Rust semantics.''}
The model is validated through instantiation proofs (\S\ref{sec:rebuttals}, Part I). \texttt{PythonInstantiation.lean} proves that all Python observables factor through the (B, S) axes. \texttt{LangPython.lean} directly encodes Python's datamodel specification. The model is falsifiable: produce Python code where two types with identical \texttt{\_\_bases\_\_} and \texttt{\_\_dict\_\_} behave differently, or where \texttt{\_\_init\_subclass\_\_} fails to fire.

\paragraph{``Rust can achieve SSOT with proc macros and static registries.''}
No. Proc macros are per-item isolated---they cannot see other items during expansion. Registration is bypassable: you can \texttt{impl Trait} without any \texttt{\#[derive]} annotation. The \texttt{inventory} crate uses linker tricks external to language semantics. Contrast Python: \texttt{\_\_init\_subclass\_\_} fires automatically and \emph{cannot be bypassed}. This is enforcement vs. enablement (\S\ref{sec:rebuttals}, Part III).

\paragraph{``The requirements are circular---you define structural facts as fixed at definition time, then prove you need definition-time hooks.''}
No. We define structural facts by their \emph{syntactic locus} (encoded in type definitions). The observation that they are fixed at definition time is a \emph{consequence} of this locus. The theorem that hooks are required is \emph{derived} from the observation. The circularity objection mistakes consequence for premise (\S\ref{sec:rebuttals}, Part II).

\paragraph{``Build.rs / external tools can achieve SSOT.''}
External tools operate outside language semantics. They can fail, be misconfigured, or be bypassed. They provide no runtime verification---the program cannot confirm derivation occurred. Build tool configuration becomes a second source (DOF $\geq$ 2). This approximates SSOT but does not achieve it (\S\ref{sec:rebuttals}, Parts II--III).

\paragraph{``The DOF = 1 definition is too restrictive.''}
The definition is \emph{derived}, not chosen. DOF = 0 means the fact is unrepresented. DOF $> 1$ means multiple sources can diverge. DOF = 1 is the unique optimal point. Systems with DOF $> 1$ may be pragmatically acceptable but do not satisfy SSOT (\S\ref{sec:rebuttals}, Part II).

\paragraph{``You just need discipline, not language features.''}
Discipline \emph{is} the external oracle. The theorem states: with DOF $> 1$, consistency requires an external oracle. ``Code review and documentation'' are exactly that oracle---human-maintained, fallible, bypassable. Language enforcement cannot be forgotten; human discipline can (\S\ref{sec:rebuttals}, Part IV).

\paragraph{``The proofs are trivial (\texttt{rfl}).''}
When modeling is correct, theorems become definitional. This is a feature. Not all proofs are \texttt{rfl}: \texttt{rust\_lacks\_introspection} is 40 lines of actual reasoning. The contribution is making the right definitions so that consequences follow structurally (\S\ref{sec:rebuttals}, Part V).

\medskip
\noindent\textbf{If you have an objection not listed above,} check Appendix~\ref{sec:rebuttals} (16 objections addressed) before concluding it has not been considered.

%==============================================================================
