\section*{Mechanized Proofs (Lean 4)}\label{sec:lean}

The core theorems in this paper (capacity, realizability, complexity bounds) are machine-checked in Lean 4. The complete proof corpus (9,369 lines across 29 files, 441 theorems/lemmas, 0 \texttt{sorry} placeholders) is provided in Supplement~A. The entropy and mutual-information results in Section~\ref{sec:info-converse} apply standard information theory (Fano's inequality) and are not separately formalized.

\subsection*{Theorem Correspondence}

The following table maps core paper theorems to their Lean formalizations:

\begin{center}
\begin{tabular}{llp{4.5cm}}
\toprule
\textbf{Paper Theorem} & \textbf{Lean Theorem} & \textbf{File} \\
\midrule
\multicolumn{3}{l}{\emph{Capacity Theorem (Section~\ref{sec:capacity})}} \\
Thm.~\ref{thm:dof-one-coherence} & \texttt{dof\_one\_implies\_coherent} & \texttt{Coherence.lean} \\
Thm.~\ref{thm:dof-gt-one-incoherence} & \texttt{dof\_gt\_one\_incoherence\_possible} & \texttt{Coherence.lean} \\
Thm.~\ref{thm:coherence-capacity} & \texttt{determinate\_truth\_forces\_ssot} & \texttt{Coherence.lean} \\
Thm.~\ref{thm:capacity-achievability} & \texttt{dof\_one\_implies\_coherent} & \texttt{Coherence.lean} \\
Thm.~\ref{thm:capacity-converse} & \texttt{non\_ssot\_permits\_incoherence} & \texttt{Coherence.lean} \\
Thm.~\ref{thm:oracle-arbitrary} & \texttt{oracle\_arbitrary} & \texttt{Coherence.lean} \\
\midrule
\multicolumn{3}{l}{\emph{Side Information (Section~\ref{sec:side-information})}} \\
Thm.~\ref{thm:side-info} & \texttt{coherence\_restoration\_eq\_dof} & \texttt{Coherence.lean} \\
\midrule
\multicolumn{3}{l}{\emph{Realizability (Section~\ref{sec:requirements})}} \\
Thm.~\ref{thm:timing-forces} & \texttt{structural\_facts\_fixed\_at\_definition} & \texttt{Foundations.lean} \\
Thm.~\ref{thm:causal-necessary} & \texttt{definition\_hooks\_necessary} & \texttt{Requirements.lean} \\
Thm.~\ref{thm:provenance-necessary} & \texttt{introspection\_necessary\_for\_verification} & \texttt{Requirements.lean} \\
Thm.~\ref{thm:independence} & \texttt{both\_requirements\_independent} & \texttt{Requirements.lean} \\
Thm.~\ref{thm:ssot-iff} & \texttt{model\_completeness} & \texttt{Foundations.lean} \\
\midrule
\multicolumn{3}{l}{\emph{Rate-Complexity Bounds (Section~\ref{sec:bounds})}} \\
Thm.~\ref{thm:upper-bound} & \texttt{ssot\_upper\_bound} & \texttt{Bounds.lean} \\
Thm.~\ref{thm:lower-bound} & \texttt{non\_ssot\_lower\_bound} & \texttt{Bounds.lean} \\
Thm.~\ref{thm:unbounded-gap} & \texttt{ssot\_advantage\_unbounded} & \texttt{Bounds.lean} \\
\bottomrule
\end{tabular}
\end{center}

\subsection*{Verification Summary}

\begin{center}
\begin{tabular}{lcc}
\toprule
\textbf{Component} & \textbf{Lines} & \textbf{Theorems} \\
\midrule
Core encoding theory (\texttt{SSOT.lean}, \texttt{Coherence.lean}, \texttt{Dof.lean}) & 509 & 29 \\
Grounded operational semantics (\texttt{AbstractClassSystem.lean}, etc.) & 5,963 & 180 \\
Encoding theory bridge (\texttt{SSOTGrounded.lean}, \texttt{Foundations.lean}) & 1,184 & 45 \\
Computational system instantiations (\texttt{Lang*.lean}, \texttt{*Instantiation.lean}) & 1,713 & 187 \\
\midrule
\textbf{Total} & \textbf{9,369} & \textbf{441} \\
\bottomrule
\end{tabular}
\end{center}

\subsection*{Verification Instructions}

To verify locally:
\begin{enumerate}
\item Install Lean 4 and Lake: \url{https://leanprover.github.io/}
\item From the repository root: \texttt{lake build --project proofs}
\item The build verifies all 441 theorems; there are no \texttt{sorry} placeholders.
\end{enumerate}

\subsection*{Proof Architecture}

The formalization grounds the abstract encoding theory in operational semantics:

\begin{itemize}
\item \textbf{Core definitions} (\texttt{SSOT.lean}): DOF as \texttt{Nat}, \texttt{satisfies\_SSOT dof := dof = 1}
\item \textbf{Coherence} (\texttt{Coherence.lean}): \texttt{EncodingSystem} with \texttt{is\_coherent}/\texttt{is\_incoherent} predicates; achievability and converse proofs
\item \textbf{Timing trichotomy} (\texttt{Foundations.lean}): \texttt{TimingRelation} type with exhaustiveness proof; derivation mechanism enumeration
\item \textbf{Realizability} (\texttt{Requirements.lean}): \texttt{LanguageFeatures} structure; necessity proofs for definition hooks and introspection
\item \textbf{Impossibility} (\texttt{Foundations.lean}): Constructive witnesses showing only \texttt{source\_hooks} achieves SSOT
\end{itemize}

The key insight: computational system claims (e.g., ``Python achieves DOF = 1'') derive from formalized operational semantics, not boolean flags. The proof chain traces from abstract theorems through \texttt{execute\_class\_statement} to concrete language features.

Full listings, the model correspondence argument, and detailed proof commentary are in Supplement~A.
