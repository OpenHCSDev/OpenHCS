\section{Conclusion}\label{sec:conclusion}
%==============================================================================

\subsection*{Methodology and Disclosure}

\textbf{Role of LLMs in this work.} This paper was developed through
human-AI collaboration. The author provided the core intuitions (the
DOF formalization, the DEF+INTRO conjecture, the language evaluation
criteria), while large language models (Claude, GPT-4) served as
implementation partners for drafting proofs, formalizing definitions,
and generating LaTeX.

The Lean 4 proofs were iteratively developed: the author specified
theorems to prove, the LLM proposed proof strategies, and the Lean
compiler verified correctness. This is epistemically sound: a Lean proof
that compiles is correct regardless of generation method. The proofs are
\emph{costly signals} (per the companion paper on credibility) whose
validity is independent of their provenance.

\textbf{What the author contributed:} The DOF = 1 formalization of SSOT,
the DEF+INTRO language requirements, the claim that Python uniquely
satisfies these among mainstream languages, the OpenHCS case studies,
and the complexity bounds.

\textbf{What LLMs contributed:} LaTeX drafting, Lean tactic exploration,
prose refinement, and literature search assistance.

Transparency about this methodology reflects our belief that the
contribution is the insight and the verified proof, not the typing
labor.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

We have provided the first formal foundations for the Single Source of Truth principle. The key contributions are:

\textbf{1. Formal Definition:} SSOT is defined as DOF = 1, where DOF (Degrees of Freedom) counts independent encoding locations for a fact. This definition is derived from the structure of the problem, not chosen arbitrarily.

\textbf{2. Uniqueness Theorem:} We prove that SSOT (DOF=1) is the \textbf{unique} minimal representation for structural facts (Theorem~\ref{thm:ssot-unique}). Any system with DOF $> 1$ contains redundancy and is therefore non-minimal. This follows from the general uniqueness theorem for minimal complete representations (Paper 1).

\textbf{3. Language Requirements:} We prove that SSOT for structural facts requires (1) definition-time hooks AND (2) introspectable derivation. Both are necessary; both together are sufficient. This is an if-and-only-if theorem.

\textbf{4. Language Evaluation:} Among mainstream languages, only Python satisfies both requirements. CLOS and Smalltalk also satisfy them but are not mainstream. This is proved by exhaustive evaluation.

\textbf{5. Complexity Bounds:} SSOT achieves $O(1)$ modification complexity; non-SSOT requires $\Omega(n)$. The gap is unbounded: for any constant $k$, there exists a codebase size where SSOT provides at least $k\times$ reduction.

\textbf{6. Mathematical Necessity:} The uniqueness theorem (Theorem~\ref{thm:ssot-unique}) establishes that DOF=1 is the unique minimal representation: $|\{r : \text{minimal}(r)\}| = 1$. This singleton solution space eliminates design freedom. Claiming ``SSOT is a valid design choice among alternatives'' while accepting uniqueness instantiates $P \land \neg P$: uniqueness entails $\neg\exists$ alternatives with equal minimality; preference presupposes $\exists$ such alternatives. Given minimality as a requirement, the mathematics forces DRY. This is not a guideline---it is the unique solution to the stated constraints.

\textbf{7. Practical Demonstration:} Concrete before/after examples from OpenHCS demonstrate the patterns in practice. PR \#44 provides a verifiable example: migration from 47 \texttt{hasattr()} checks to ABC contracts, achieving DOF 47 $\to$ 1.

\textbf{Implications:}

\begin{enumerate}
\item \textbf{For practitioners:} If SSOT for structural facts is required, Python (or CLOS/Smalltalk) is necessary. Other mainstream languages cannot achieve SSOT within the language.

\item \textbf{For language designers:} Definition-time hooks and introspection should be considered if DRY is a design goal. Their absence is a deliberate choice with consequences.

\item \textbf{For researchers:} Software engineering principles can be formalized and machine-checked. This paper demonstrates the methodology.
\end{enumerate}

\textbf{Limitations:}
\begin{itemize}
\tightlist
\item Results apply to \emph{structural} facts. Configuration values and runtime state have different characteristics.
\item The complexity bounds are asymptotic. Small codebases may not benefit significantly.
\item Examples are from a single codebase. The patterns are general, but readers should verify applicability to their domains.
\end{itemize}

\textbf{Future Work:}
\begin{itemize}
\tightlist
\item Extend the formalization to non-structural facts
\item Develop automated DOF measurement tools
\item Study the relationship between DOF and other software quality metrics
\item Investigate SSOT in multi-language systems
\end{itemize}

\textbf{Connection to Leverage Framework:}

SSOT achieves \emph{infinite leverage} in the framework of the companion paper on leverage-driven architecture:
\[
L(\text{SSOT}) = \frac{|\text{Derivations}|}{1} \to \infty
\]

A single source derives arbitrarily many facts. This is the theoretical maximum---no architecture can exceed infinite leverage. The leverage framework provides a unified view: this paper (SSOT) and the companion paper on typing discipline selection are both instances of leverage maximization. The metatheorem---``maximize leverage''---subsumes both results.

\subsection{Data Availability}\label{sec:data-availability}

\textbf{OpenHCS Codebase:} The OpenHCS platform (45K LoC Python) is available at \url{https://github.com/trissim/openhcs}~\cite{openhcs2025}. The codebase demonstrates the SSOT patterns described in Section~\ref{sec:empirical}.

\textbf{PR \#44:} The migration from duck typing (\texttt{hasattr()}) to ABC contracts is documented in a publicly verifiable pull request~\cite{openhcsPR44}: \url{https://github.com/trissim/openhcs/pull/44}. Readers can inspect the before/after diff to verify the DOF 47 $\to$ 1 reduction.

\textbf{Lean 4 Proofs:} The complete Lean 4 formalization (1,753 lines across 13 files, 0 \texttt{sorry} placeholders)~\cite{openhcsLeanProofs} is included as supplementary material. Reviewers can verify the proofs by running \texttt{lake build} in the proof directory.

