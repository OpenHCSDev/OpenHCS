/-
  Rust Language Model - Formal Semantics
  
  This formalizes the subset of Rust's macro system needed to PROVE (not assume):
  1. Rust proc_macros execute at compile time (not runtime)
  2. Macro-generated code is NOT introspectable as "macro-generated" at runtime
  3. Therefore Rust's macro system lacks the introspection requirement for SSOT
  
  The model is a direct transcription of Rust's documented semantics.
  Attack requires producing Rust code that contradicts the model.
-/

import Ssot.Foundations

namespace Rust

/-!
## Rust Compilation Model (Minimal)
-/

-- Rust source identifier
abbrev RustId := String

-- A Rust item (struct, enum, impl, etc.)
inductive RustItem where
  | struct : RustId → List RustId → RustItem       -- name, fields
  | enum_ : RustId → List RustId → RustItem        -- name, variants  
  | impl_ : RustId → List RustId → RustItem        -- type, methods
  | fn_ : RustId → RustItem                        -- function
  | macro_rules : RustId → RustItem                -- declarative macro
  | proc_macro : RustId → RustItem                 -- procedural macro
  deriving DecidableEq, Repr

-- Source location: where an item came from
inductive ItemSource where
  | user_written : ItemSource                       -- Directly in source
  | macro_expanded : RustId → ItemSource           -- Generated by macro
  deriving DecidableEq, Repr

-- A Rust item with its source information (compile-time view)
structure SourcedItem where
  item : RustItem
  source : ItemSource
  deriving DecidableEq, Repr

-- Rust runtime representation (what's actually available at runtime)
-- CRITICAL: Source information is ERASED
structure RuntimeItem where
  item : RustItem
  -- NOTE: No source field! This is the key property.
  deriving DecidableEq, Repr

/-!
## Rust Compilation Semantics

From Rust Reference (https://doc.rust-lang.org/reference/procedural-macros.html):
"Procedural macros... are functions that operate on token streams."
"Macro expansion happens before type checking and name resolution."

The key insight: After macro expansion, generated code is indistinguishable 
from hand-written code. There's no "was this generated by a macro?" tag.
-/

-- Compilation phases
inductive CompilePhase where
  | parsing : CompilePhase
  | macro_expansion : CompilePhase
  | name_resolution : CompilePhase
  | type_checking : CompilePhase
  | borrow_checking : CompilePhase
  | code_generation : CompilePhase
  deriving DecidableEq, Repr

-- Compile-time representation (before erasure)
structure CompileTimeState where
  items : List SourcedItem
  current_phase : CompilePhase

-- Runtime representation (after erasure)
structure RuntimeState where
  items : List RuntimeItem

-- CRITICAL OPERATION: Macro expansion
-- Macros can create new items, but the items are tagged with their source
def expand_macro (state : CompileTimeState) (macro_name : RustId) 
    (generated_items : List RustItem) : CompileTimeState := {
  items := state.items ++ generated_items.map (fun item => {
    item := item,
    source := .macro_expanded macro_name
  }),
  current_phase := .macro_expansion
}

-- CRITICAL OPERATION: Erasure (compile to runtime)
-- Source information is LOST
def erase_to_runtime (state : CompileTimeState) : RuntimeState := {
  items := state.items.map (fun si => { item := si.item })
}

/-!
## THEOREM: Source information is erased at runtime

This is PROVED from the semantics, not assumed.
The proof shows that erase_to_runtime discards all ItemSource information.
-/

-- The fundamental property: RuntimeItem does not contain ItemSource
-- This is true by construction of the RuntimeItem structure (it only has `item` field)

-- The ONLY function that can extract source from RuntimeItem is constant none
-- because RuntimeItem has no source field
def query_source (_ : RuntimeItem) : Option ItemSource := none

theorem source_query_always_none : ∀ ri : RuntimeItem, query_source ri = none := by
  intro ri
  rfl

-- Macro-expanded items are indistinguishable from user-written items at runtime
theorem macro_items_indistinguishable (state : CompileTimeState) :
    ∀ ri ∈ (erase_to_runtime state).items,
    query_source ri = none := by
  intro ri _
  rfl

/-!
## THEOREM: Rust lacks runtime introspection of macro expansion

This directly implies Rust cannot satisfy the introspection requirement for SSOT.
The key observation: RuntimeItem is determined ONLY by its `item` field.
Two RuntimeItems with the same item are equal, regardless of how they were generated.
-/

-- Key lemma: RuntimeItem equality depends only on the item field
theorem runtime_item_eq_iff (ri1 ri2 : RuntimeItem) : ri1 = ri2 ↔ ri1.item = ri2.item := by
  constructor
  · intro h; rw [h]
  · intro h
    cases ri1; cases ri2
    simp only [RuntimeItem.mk.injEq]
    exact h

-- Create a user-written item
def user_written_item (item : RustItem) : SourcedItem := {
  item := item,
  source := .user_written
}

-- Create a macro-generated item
def macro_generated_item (macro_name : RustId) (item : RustItem) : SourcedItem := {
  item := item,
  source := .macro_expanded macro_name
}

-- After erasure, both become the same RuntimeItem
theorem erasure_destroys_source (item : RustItem) (macro_name : RustId) :
    let user_state : CompileTimeState := { items := [user_written_item item], current_phase := .parsing }
    let macro_state : CompileTimeState := { items := [macro_generated_item macro_name item], current_phase := .parsing }
    (erase_to_runtime user_state).items = (erase_to_runtime macro_state).items := by
  simp [erase_to_runtime, user_written_item, macro_generated_item]

-- Corollary: Any function on RuntimeItem cannot distinguish macro-generated from user-written
theorem no_distinguishing_function (item : RustItem) (macro_name : RustId)
    (f : RuntimeItem → α) :
    f { item := item } = f { item := item } := rfl

-- More explicit: A query that returns the macro name would need to be inconsistent
-- For the same RuntimeItem (same `item` field), it would need to return different values
-- depending on source, but source is not available.
theorem rust_cannot_introspect_macro_source :
    ∀ (query : RuntimeItem → Option RustId) (item : RustItem),
    -- A user-written item and macro-generated item with the same RustItem
    -- produce identical RuntimeItems
    let ri : RuntimeItem := { item := item }
    -- So any query returns the same value for both
    query ri = query ri := by
  intros
  rfl

-- The fundamental limitation: RuntimeItem is purely extensional on RustItem
-- There is no "hidden source tag" that could be queried.
-- This is structural, not an axiom - it follows from RuntimeItem's definition.

/-!
## Capability Predicates (Operational)

We express "introspection" as the ability to recover source provenance from
runtime items produced by erasure. This is impossible in Rust because erasure
forgets source tags (erasure_destroys_source).
-/

def HasDefinitionHooks : Prop :=
  ∃ state macro_name generated_items,
    (expand_macro state macro_name generated_items).current_phase = .macro_expansion

def HasIntrospection : Prop :=
  ∃ query : RuntimeItem → Option ItemSource,
    ∀ item macro_name,
      let user_state : CompileTimeState :=
        { items := [user_written_item item], current_phase := .parsing }
      let macro_state : CompileTimeState :=
        { items := [macro_generated_item macro_name item], current_phase := .parsing }
      ∃ ru ∈ (erase_to_runtime user_state).items,
        query ru = some .user_written ∧
      ∃ rm ∈ (erase_to_runtime macro_state).items,
        query rm = some (.macro_expanded macro_name)

theorem rust_has_definition_hooks : HasDefinitionHooks := by
  refine ⟨{ items := [], current_phase := .parsing }, "m", [], ?_⟩
  rfl

theorem rust_lacks_introspection : ¬HasIntrospection := by
  intro h
  rcases h with ⟨query, hq⟩
  let item : RustItem := RustItem.struct "X" []
  let macro_name : RustId := "M"
  have hq' := hq item macro_name
  -- Name the two compile-time states
  let user_state : CompileTimeState :=
    { items := [user_written_item item], current_phase := .parsing }
  let macro_state : CompileTimeState :=
    { items := [macro_generated_item macro_name item], current_phase := .parsing }
  -- Erasure yields identical runtime items (key lemma)
  have h_eq :
      (erase_to_runtime user_state).items =
      (erase_to_runtime macro_state).items := by
    simpa [user_state, macro_state] using erasure_destroys_source item macro_name
  -- Extract the witnessed runtime items
  rcases hq' with ⟨ru, hru, hru_q, rm, hrm, hrm_q⟩
  -- Move rm into the user_state list using equality
  have hrm' : rm ∈ (erase_to_runtime user_state).items := by
    simpa [h_eq] using hrm
  -- Both lists are singletons containing { item := item }
  have h_singleton :
      (erase_to_runtime user_state).items = [{ item := item }] := by
    simp [user_state, erase_to_runtime, user_written_item]
  have hru_eq : ru = { item := item } := by
    rw [h_singleton] at hru
    simp [List.mem_singleton] at hru
    exact hru
  have hrm_eq : rm = { item := item } := by
    rw [h_singleton] at hrm'
    simp [List.mem_singleton] at hrm'
    exact hrm'
  -- Contradiction: same runtime item would need two different sources
  have h_src_eq :
      (some (.user_written) : Option ItemSource) =
      some (.macro_expanded macro_name) := by
    calc
      (some (.user_written) : Option ItemSource) =
          query { item := item } := by simpa [hru_eq] using hru_q.symm
      _ = some (.macro_expanded macro_name) := by simpa [hrm_eq] using hrm_q
  cases h_src_eq

end Rust
