\section{Complexity Bounds}\label{sec:bounds}
%==============================================================================

We now prove the complexity bounds that make SSOT valuable. The key result: the gap between SSOT-complete and SSOT-incomplete architectures is \emph{unbounded}---it grows without limit as codebases scale.

\subsection{Cost Model}\label{sec:cost-model}

\begin{definition}[Modification Cost Model]\label{def:cost-model}
Let $\delta_F$ be a modification to fact $F$ in codebase $C$. The \emph{effective modification complexity} $M_{\text{effective}}(C, \delta_F)$ is the number of syntactically distinct edit operations a developer must perform manually. Formally:
\[
M_{\text{effective}}(C, \delta_F) = |\{L \in \text{Locations}(C) : \text{requires\_manual\_edit}(L, \delta_F)\}|
\]
where $\text{requires\_manual\_edit}(L, \delta_F)$ holds iff location $L$ must be updated by the developer (not by automatic derivation) to maintain coherence after $\delta_F$.
\end{definition}

\textbf{Unit of cost:} One edit = one syntactic modification to one location. We count locations, not keystrokes or characters. This abstracts over edit complexity to focus on the scaling behavior.

\textbf{What we measure:} Manual edits only. Derived locations that update automatically have zero cost. This distinguishes SSOT (where derivation handles propagation) from non-SSOT (where all updates are manual).

\subsection{Upper Bound: SSOT Achieves O(1)}\label{sec:upper-bound}

\begin{theorem}[SSOT Upper Bound]\label{thm:upper-bound}
For a codebase satisfying SSOT for fact $F$:
\[
M_{\text{effective}}(C, \delta_F) = O(1)
\]
Effective modification complexity is constant regardless of codebase size.
\end{theorem}

\begin{proof}
Let $C$ satisfy SSOT for fact $F$. By Definition~\ref{def:ssot}, $\text{DOF}(C, F) = 1$. Let $L_s$ be the single independent encoding location.

When $F$ changes:
\begin{enumerate}
\tightlist
\item The developer updates $L_s$ (1 edit)
\item All derived locations $L_1, \ldots, L_k$ are automatically updated by the derivation mechanism
\item Total manual edits: 1
\end{enumerate}

The number of derived locations $k$ may grow with codebase size, but the number of \emph{manual} edits remains 1. Therefore, $M_{\text{effective}}(C, \delta_F) = O(1)$.
\end{proof}

\textbf{Note on ``effective'' vs. ``total'' complexity:} Total modification complexity $M(C, \delta_F)$ counts all locations that change. Effective modification complexity counts only manual edits. With SSOT, total complexity may be $O(n)$ (many derived locations change), but effective complexity is $O(1)$ (one manual edit).

\subsection{Lower Bound: Non-SSOT Requires \texorpdfstring{$\Omega(n)$}{Omega(n)}}\label{sec:lower-bound}

\begin{theorem}[Non-SSOT Lower Bound]\label{thm:lower-bound}
For a codebase \emph{not} satisfying SSOT for fact $F$, if $F$ is encoded at $n$ independent locations:
\[
M_{\text{effective}}(C, \delta_F) = \Omega(n)
\]
\end{theorem}

\begin{proof}
Let $C$ not satisfy SSOT for $F$. By Definition~\ref{def:ssot}, $\text{DOF}(C, F) > 1$. Let $\text{DOF}(C, F) = n$ where $n > 1$.

By Definition~\ref{def:independent}, the $n$ encoding locations are independent---updating one does not automatically update the others. When $F$ changes:
\begin{enumerate}
\tightlist
\item Each of the $n$ independent locations must be updated manually
\item No automatic propagation exists between independent locations
\item Total manual edits: $n$
\end{enumerate}

Therefore, $M_{\text{effective}}(C, \delta_F) = \Omega(n)$.
\end{proof}

\subsection{The Unbounded Gap}\label{sec:gap}

\begin{theorem}[Unbounded Gap]\label{thm:unbounded-gap}
The ratio of modification complexity between SSOT-incomplete and SSOT-complete architectures grows without bound:
\[
\lim_{n \to \infty} \frac{M_{\text{incomplete}}(n)}{M_{\text{complete}}} = \lim_{n \to \infty} \frac{n}{1} = \infty
\]
\end{theorem}

\begin{proof}
By Theorem~\ref{thm:upper-bound}, $M_{\text{complete}} = O(1)$. Specifically, $M_{\text{complete}} = 1$ for any codebase size.

By Theorem~\ref{thm:lower-bound}, $M_{\text{incomplete}}(n) = \Omega(n)$ where $n$ is the number of independent encoding locations.

The ratio is:
\[
\frac{M_{\text{incomplete}}(n)}{M_{\text{complete}}} = \frac{n}{1} = n
\]

As $n \to \infty$, the ratio $\to \infty$. The gap is unbounded.
\end{proof}

\begin{corollary}[Arbitrary Reduction Factor]\label{cor:arbitrary-reduction}
For any constant $k$, there exists a codebase size $n$ such that SSOT provides at least $k\times$ reduction in modification complexity.
\end{corollary}

\begin{proof}
Choose $n = k$. Then $M_{\text{incomplete}}(n) = n = k$ and $M_{\text{complete}} = 1$. The reduction factor is $k/1 = k$.
\end{proof}

\subsection{Practical Implications}\label{sec:practical-implications}

The unbounded gap has practical implications:

\textbf{1. SSOT matters more at scale.} For small codebases ($n = 3$), the difference between 3 edits and 1 edit is minor. For large codebases ($n = 50$), the difference between 50 edits and 1 edit is significant.

\textbf{2. The gap compounds over time.} Each modification to fact $F$ incurs the complexity cost. If $F$ changes $m$ times over the project lifetime, total cost is $O(mn)$ without SSOT vs. $O(m)$ with SSOT.

\textbf{3. The gap affects error rates.} Each manual edit is an opportunity for error. With $n$ edits, the probability of at least one error is $1 - (1-p)^n$ where $p$ is the per-edit error probability. As $n$ grows, this approaches 1.

\begin{example}[Error Rate Calculation]\label{ex:error-rate}
Assume a 1\% error rate per edit ($p = 0.01$).

\begin{center}
\begin{tabular}{ccc}
\toprule
\textbf{Edits ($n$)} & \textbf{P(at least one error)} & \textbf{Architecture} \\
\midrule
1 & 1.0\% & SSOT \\
10 & 9.6\% & Non-SSOT \\
50 & 39.5\% & Non-SSOT \\
100 & 63.4\% & Non-SSOT \\
\bottomrule
\end{tabular}
\end{center}

With 50 encoding locations, there is a 39.5\% chance of introducing an error when modifying fact $F$. With SSOT, the chance is 1\%.
\end{example}

\subsection{Amortized Analysis}\label{sec:amortized}

The complexity bounds assume a single modification. Over the lifetime of a codebase, facts are modified many times.

\begin{theorem}[Amortized Complexity]\label{thm:amortized}
Let fact $F$ be modified $m$ times over the project lifetime. Let $n$ be the number of encoding locations. Total modification cost is:
\begin{itemize}
\tightlist
\item SSOT: $O(m)$
\item Non-SSOT: $O(mn)$
\end{itemize}
\end{theorem}

\begin{proof}
Each modification costs $O(1)$ with SSOT and $O(n)$ without. Over $m$ modifications, total cost is $m \cdot O(1) = O(m)$ with SSOT and $m \cdot O(n) = O(mn)$ without.
\end{proof}

For a fact modified 100 times with 50 encoding locations:
\begin{itemize}
\tightlist
\item SSOT: 100 edits total
\item Non-SSOT: 5,000 edits total
\end{itemize}

The 50$\times$ reduction factor applies to every modification, compounding over the project lifetime.

%==============================================================================
