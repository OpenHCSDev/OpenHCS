\section{Single Source of Truth}\label{sec:ssot}
%==============================================================================

Having established the epistemic foundations (Section~\ref{sec:epistemic}), we now define SSOT as the instantiation of coherence to software and prove its necessity.

\subsection{SSOT as Epistemic Coherence}\label{sec:ssot-def}

SSOT is not a design guideline. It is the unique representation guaranteeing epistemic coherence for facts encoded in software.

\begin{definition}[Single Source of Truth]\label{def:ssot}
Codebase $C$ satisfies \emph{SSOT} for fact $F$ iff:
\[
\text{DOF}(C, F) = 1
\]
Equivalently: exactly one independent encoding location exists for $F$.
\end{definition}

\textbf{Epistemic interpretation:}
\begin{itemize}
\tightlist
\item DOF = 1 means exactly one independent encoding location
\item All other locations are derived (cannot diverge from source)
\item Incoherence is \emph{impossible}, not merely unlikely
\item Truth is determinate: the single source IS the value of $F$
\end{itemize}

\begin{theorem}[SSOT Eliminates Indeterminacy]\label{thm:ssot-determinate}
If $\text{DOF}(C, F) = 1$, then for all reachable states of $C$, the value of $F$ is determinate: all encodings agree.
\end{theorem}

\begin{proof}
By Theorem~\ref{thm:dof-one-coherence}, DOF = 1 guarantees coherence. Coherence means all encodings hold the same value. Therefore, the value of $F$ is uniquely determined by the single source.
\end{proof}

Hunt \& Thomas's ``single, unambiguous, authoritative representation''~\cite{hunt1999pragmatic} corresponds precisely to this epistemic structure:
\begin{itemize}
\tightlist
\item \textbf{Single:} DOF = 1
\item \textbf{Unambiguous:} No incoherent states possible (Theorem~\ref{thm:dof-one-coherence})
\item \textbf{Authoritative:} The source determines all derived values
\end{itemize}

\begin{theorem}[SSOT Optimality]\label{thm:ssot-optimal}
If $C$ satisfies SSOT for $F$, then modification complexity is 1: updating the single source maintains coherence.
\end{theorem}

\begin{proof}
Let $C$ satisfy SSOT for $F$, meaning $\text{DOF}(C, F) = 1$. Let $L_s$ be the single independent encoding location. All other encodings $L_1, \ldots, L_k$ are derived from $L_s$.

When fact $F$ changes:
\begin{enumerate}
\tightlist
\item The developer updates $L_s$ (1 edit)
\item By Definition~\ref{def:derived}, $L_1, \ldots, L_k$ are automatically updated
\item Coherence is maintained: all locations agree on the new value
\end{enumerate}

Coherence restoration requires 1 edit.
\end{proof}

\begin{theorem}[SSOT Uniqueness]\label{thm:ssot-unique}
SSOT (DOF=1) is the \textbf{unique} coherent representation for structural facts. DOF = 0 fails to represent; DOF $> 1$ permits incoherence.
\end{theorem}

\begin{proof}
By Theorem~\ref{thm:dof-one-coherence}, DOF = 1 guarantees coherence.
By Theorem~\ref{thm:dof-gt-one-incoherence}, DOF $> 1$ permits incoherence.

This leaves only DOF = 1 as coherent representation. DOF = 0 means no independent location encodes $F$---the fact is not represented.

Therefore, DOF = 1 is uniquely coherent. This is epistemic necessity, not design choice.
\end{proof}

\begin{corollary}[Incoherence Under Redundancy]\label{cor:no-redundancy}
Multiple independent sources encoding the same fact permit incoherent states. DOF $> 1 \Rightarrow$ incoherence reachable.
\end{corollary}

\begin{proof}
Direct application of Theorem~\ref{thm:dof-gt-one-incoherence}. With DOF $> 1$, independent locations can be modified separately, reaching states where they disagree.
\end{proof}

\subsection{Coherence Restoration Complexity}\label{sec:ssot-vs-m}

When fact $F$ changes, how many edits are required to restore coherence?

\begin{itemize}
\tightlist
\item With DOF = 1: 1 edit (the single source). All derived locations update automatically.
\item With DOF $= n > 1$: $n$ edits. Each independent location must be updated manually.
\end{itemize}

With SSOT, many locations may encode $F$, but coherence restoration requires only 1 edit. The derivation mechanism handles the rest.

\begin{example}[Coherence with Many Encodings]\label{ex:ssot-large-m}
Consider a codebase where 50 classes inherit from \texttt{BaseProcessor}:

\begin{verbatim}
class BaseProcessor(ABC):
    @abstractmethod
    def process(self, data: np.ndarray) -> np.ndarray: ...

class Detector(BaseProcessor): ...
class Segmenter(BaseProcessor): ...
# ... 48 more subclasses
\end{verbatim}

The fact $F$ = ``All processors must have a \texttt{process} method'' is encoded in 51 locations.

\textbf{Without SSOT (DOF = 51):} Changing the signature requires 51 edits. After each edit, coherence is partially restored. Only after all 51 edits is the system coherent.

\textbf{With SSOT (DOF = 1):} The ABC contract is the single source. Changing the ABC updates the specification; derived locations (type checker flags, runtime enforcement) update automatically. The \emph{contract specification} has a single source.

Note: Implementations are separate facts. SSOT for the contract does not eliminate implementation edits---it ensures the specification is determinate.
\end{example}

\subsection{Derivation: The Coherence Mechanism}\label{sec:derivation}

Derivation is the mechanism by which DOF is reduced without losing encodings. A derived location cannot diverge from its source, eliminating it as a source of incoherence.

\begin{definition}[Derivation]\label{def:derivation}
Location $L_{\text{derived}}$ is \emph{derived from} $L_{\text{source}}$ for fact $F$ iff:
\[
\text{updated}(L_{\text{source}}) \rightarrow \text{automatically\_updated}(L_{\text{derived}})
\]
No manual intervention is required. Coherence is maintained automatically.
\end{definition}

Derivation can occur at different times:

\begin{center}
\begin{tabular}{lp{7cm}}
\toprule
\textbf{Derivation Time} & \textbf{Examples} \\
\midrule
Compile time & C++ templates, Rust macros, code generation \\
Definition time & Python metaclasses, \texttt{\_\_init\_subclass\_\_}, class decorators \\
Runtime & Lazy computation, memoization \\
\bottomrule
\end{tabular}
\end{center}

For \emph{structural facts}, derivation must occur at \emph{definition time}. Structural facts (class existence, method signatures) are fixed when the class is defined. Compile-time is too early (source not parsed). Runtime is too late (structure already fixed).

\begin{theorem}[Derivation Preserves Coherence]\label{thm:derivation-excludes}
If $L_{\text{derived}}$ is derived from $L_{\text{source}}$, then $L_{\text{derived}}$ cannot diverge from $L_{\text{source}}$ and does not contribute to DOF.
\end{theorem}

\begin{proof}
By Definition~\ref{def:derivation}, derived locations are automatically updated when the source changes. Let $L_d$ be derived from $L_s$. If $L_s$ encodes value $v$, then $L_d$ encodes $f(v)$ for some function $f$. When $L_s$ changes to $v'$, $L_d$ automatically changes to $f(v')$.

There is no reachable state where $L_s = v'$ and $L_d = f(v)$ with $v' \neq v$. Divergence is impossible. Therefore, $L_d$ does not contribute to DOF.
\end{proof}

\begin{corollary}[Derivation Achieves Coherence]\label{cor:metaprogramming}
If all encodings of $F$ except one are derived from that one, then $\text{DOF}(C, F) = 1$ and coherence is guaranteed.
\end{corollary}

\begin{proof}
Let $L_s$ be the non-derived encoding. All other encodings $L_1, \ldots, L_k$ are derived from $L_s$. By Theorem~\ref{thm:derivation-excludes}, none can diverge. Only $L_s$ is independent. Therefore, $\text{DOF}(C, F) = 1$, and by Theorem~\ref{thm:dof-one-coherence}, coherence is guaranteed.
\end{proof}

\subsection{Coherence Patterns in Python}\label{sec:ssot-patterns}

Python provides several mechanisms for achieving DOF = 1 (coherent representation):

\textbf{Pattern 1: Subclass Registration via \texttt{\_\_init\_subclass\_\_}}

\begin{verbatim}
class Registry:
    _registry = {}

    def __init_subclass__(cls, **kwargs):
        super().__init_subclass__(**kwargs)
        Registry._registry[cls.__name__] = cls

class Handler(Registry):
    pass

class PNGHandler(Handler):  # Automatically registered
    pass
\end{verbatim}

The fact ``\texttt{PNGHandler} is in the registry'' is encoded in two locations:
\begin{enumerate}
\tightlist
\item The class definition (source)
\item The registry dictionary (derived via \texttt{\_\_init\_subclass\_\_})
\end{enumerate}

DOF = 1 because the registry entry is derived. Incoherence is impossible: the registry cannot disagree with the class hierarchy.

\textbf{Pattern 2: Subclass Enumeration via \texttt{\_\_subclasses\_\_()}}

\begin{verbatim}
class Processor(ABC):
    @classmethod
    def all_processors(cls):
        return cls.__subclasses__()

class Detector(Processor): pass
class Segmenter(Processor): pass

# Usage: Processor.all_processors() -> [Detector, Segmenter]
\end{verbatim}

The fact ``which classes are processors'' has DOF = 1: \texttt{\_\_subclasses\_\_()} is computed from the class definitions. No separate list can become stale.

\textbf{Pattern 3: ABC Contracts}

\begin{verbatim}
class ImageLoader(ABC):
    @abstractmethod
    def load(self, path: str) -> np.ndarray: ...

    @abstractmethod
    def supported_extensions(self) -> List[str]: ...
\end{verbatim}

The contract ``loaders must implement \texttt{load} and \texttt{supported\_extensions}'' is encoded once in the ABC. The ABC is the single source; compliance is enforced. Truth about the contract is determinate.

%==============================================================================
