\section{Introduction}\label{introduction}

\subsection{The Epistemic Problem}\label{sec:epistemic-problem}

When multiple locations encode the same fact, which location holds the truth?

This question has no principled answer. If location $L_1$ says ``threshold = 0.5'' and location $L_2$ says ``threshold = 0.7'', no information internal to the encoding system determines which is correct. Any resolution is arbitrary---it requires external information (developer intent, timestamps, priority rules) that the encodings themselves do not contain.

This is not a software engineering problem. It is an \textbf{epistemic} problem: the determinacy of truth under redundant encoding.

\begin{quote}
\textbf{Oracle Arbitrariness Theorem.} For any incoherent encoding system and any oracle that resolves it to a value, there exists an equally-present value that disagrees with the oracle's choice.
\end{quote}

The theorem is proved formally (Theorem~\ref{thm:oracle-arbitrary}). Its consequence: \textbf{DOF = 1 is epistemically necessary} for coherent representation. With exactly one independent source, disagreement is impossible. Truth is determinate.

\subsection{Software as Instance}\label{sec:software-instance}

Programming languages instantiate this epistemic structure. A codebase is an encoding system. Structural facts (class existence, method signatures, type relationships) are the facts being encoded. The ``Don't Repeat Yourself'' (DRY) principle~\cite{hunt1999pragmatic} is the software engineering recognition of epistemic necessity.

This paper proves:
\begin{enumerate}
\item \textbf{The epistemic foundation:} DOF = 1 is the unique representation guaranteeing coherence
\item \textbf{The software instantiation:} Achieving DOF = 1 for structural facts requires specific language features
\item \textbf{The impossibility result:} Most mainstream languages lack these features and cannot achieve coherence
\end{enumerate}

\subsection{Metatheoretic Foundations}\label{metatheoretic-foundations}

Following the tradition of formal language design criteria (Liskov \& Wing~\cite{liskov1994behavioral} for subtyping; Cook et al.~\cite{cook1989inheritance} for inheritance semantics), we formalize correctness criteria for SSOT-completeness in programming languages. Our contribution is not advocating specific languages, but deriving the necessary and sufficient requirements that enable Single Source of Truth for structural facts.

The derivation theory (independence, derivability, axis collapse) is established in Paper 1~\cite{paper1_typing_discipline}. This paper proves the coherence consequences and instantiates them to programming languages.

\subsection{The Universal Principle}\label{sec:universal-principle}

This paper proves an epistemic result that applies beyond programming:

\begin{enumerate}
\item \textbf{DOF = 1 guarantees coherence.} With exactly one independent encoding, disagreement is impossible. Truth is determinate.

\item \textbf{DOF $> 1$ permits incoherence.} With multiple independent encodings, disagreeing states are reachable. Truth becomes indeterminate.

\item \textbf{DOF = 1 is uniquely optimal.} DOF = 0 means the fact is unrepresented. DOF $> 1$ permits incoherence. Only DOF = 1 achieves coherent representation.
\end{enumerate}

\textbf{The forcing theorem.} Given coherence as a requirement, DOF = 1 is the unique solution. We do not claim all systems require coherence. We prove that systems requiring coherence have no design freedom---the solution is forced.

\textbf{The language instantiation.} For \emph{structural facts} in programming languages, DOF = 1 requires specific language features: definition-time hooks and introspection. Languages lacking either \emph{cannot achieve} DOF = 1 for structural facts regardless of programmer effort. This is an impossibility result (Theorem~\ref{thm:ssot-iff}).

The epistemic principle is universal. The language evaluation is its instantiation to software. Both are machine-checked.

\subsection{Overview}\label{overview}

This paper establishes \textbf{coherence impossibility theorems} for programming languages: we prove that most mainstream languages \textbf{cannot guarantee coherence} for structural facts. All results are machine-checked in Lean 4~\cite{demoura2021lean4} (2,104 lines across 13 files, 0 \texttt{sorry} placeholders).

\textbf{Incompleteness.} We prove that Java, C++, C\#, JavaScript, Go, Rust, TypeScript, Kotlin, and Swift lack the semantic machinery to achieve DOF = 1 (coherent representation) for structural facts. This is not a limitation of particular implementations. It is a fundamental property of their language semantics: incoherent states are always reachable.

\textbf{Completeness.} We prove that Python, Common Lisp (CLOS), and Smalltalk possess the necessary semantic features. Among mainstream languages (top-10 TIOBE, consistent 5+ year presence), Python is unique in this capability.

\textbf{Connection to software engineering practice.} The ``Don't Repeat Yourself'' (DRY) principle~\cite{hunt1999pragmatic}, articulated as ``Every piece of knowledge must have a single, unambiguous, authoritative representation within a system'' (Hunt \& Thomas, 1999), is the practitioner's recognition of epistemic necessity. We prove DRY reduces to DOF = 1, which is the unique coherent representation (Theorem~\ref{thm:dof-one-coherence}). To our knowledge, this is the first formalization of DRY/SSOT as an epistemic requirement.

\textbf{Note on terminology:} The term ``Single Source of Truth'' also appears in data management literature, referring to authoritative data repositories. Our usage is distinct: we mean SSOT for \emph{program structure} (class existence, method signatures, type relationships), not for data storage.

The core insight: coherence for \emph{structural facts} requires language features that most mainstream languages lack:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Definition-time hooks} (Theorem~\ref{thm:hooks-necessary}): Code must execute when a class/function is \emph{defined}, not when it is \emph{used}. This enables derivation at the moment structure is established.
\item
  \textbf{Introspectable derivation} (Theorem~\ref{thm:introspection-necessary}): The program must be able to query what was derived and from what. This enables verification of the derivation relationship.
\item
  \textbf{Both are necessary} (Theorem~\ref{thm:independence}): Neither feature alone suffices. Without both, independent locations remain, and incoherence is possible.
\end{enumerate}

These requirements are \textbf{information-theoretic}: Languages lacking either capability cannot eliminate independent locations regardless of programmer effort.

\subsection{Core Theorems}\label{sec:core-theorems}

We establish four theorems characterizing coherence achievability:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Theorem~\ref{thm:oracle-arbitrary} (Oracle Arbitrariness):} In any incoherent encoding system, no resolution is principled. For any oracle selecting a value, there exists an equally-present value that disagrees.

  \emph{Proof technique:} By incoherence, at least two values exist. Any selection leaves the other disagreeing.

\item
  \textbf{Theorem~\ref{thm:dof-one-coherence} (Coherence Forcing):} DOF = 1 guarantees coherence. With exactly one independent source, disagreement is impossible.

  \emph{Proof technique:} All other locations are derived (cannot diverge). Single source determines all values.

\item
  \textbf{Theorem~\ref{thm:ssot-iff} (Language Requirements):} A language enables DOF = 1 for structural facts if and only if it provides (1) definition-time hooks AND (2) introspectable derivation.

  \emph{Proof technique:} Necessity by exhibiting incoherent states when either is missing. Sufficiency by construction.

\item
  \textbf{Theorem~\ref{thm:unbounded-gap} (Coherence Restoration Gap):} The complexity of restoring coherence after modification is unbounded: $O(1)$ for DOF = 1 vs $\Omega(n)$ for DOF $= n > 1$.

  \emph{Proof technique:} Asymptotic analysis: $\lim_{n \to \infty} \frac{n}{1} = \infty$.
\end{enumerate}

\textbf{Forced solution.} Given coherence as a requirement, DOF = 1 is the unique solution (Corollary~\ref{cor:coherence-forces-ssot}). Language selection becomes \textbf{determined}: incomplete languages cannot achieve coherence regardless of implementation effort. This is not preference. It is epistemic necessity.

\subsection{Scope}\label{sec:scope}

This work characterizes SSOT for \emph{structural facts} (class existence, method signatures, type relationships) within \emph{single-language} systems. The complexity analysis is asymptotic, applying to systems where $n$ grows. External tooling can approximate SSOT behavior but operates outside language semantics.

\textbf{Multi-language systems.} When a system spans multiple languages (e.g., Python backend + TypeScript frontend + protobuf schemas), cross-language SSOT requires external code generation tools. The analysis in this paper characterizes single-language SSOT; multi-language SSOT is noted as future work (Section~\ref{sec:conclusion}).

\subsection{Contributions}\label{sec:contributions}

This paper makes six contributions:

\textbf{1. Epistemic foundations (Section~\ref{sec:epistemic}):}
\begin{itemize}
\tightlist
\item Definition of coherence and incoherence for encoding systems
\item \textbf{Theorem~\ref{thm:oracle-arbitrary} (Oracle Arbitrariness):} Under incoherence, no resolution is principled. The epistemic core.
\item \textbf{Theorem~\ref{thm:dof-one-coherence} (Coherence Forcing):} DOF = 1 guarantees coherence
\item \textbf{Theorem~\ref{thm:dof-gt-one-incoherence}:} DOF $> 1$ permits incoherence
\item \textbf{Corollary~\ref{cor:coherence-forces-ssot}:} Given coherence requirement, DOF = 1 is necessary and sufficient
\end{itemize}

\textbf{2. Software instantiation (Section~\ref{sec:edit-space}):}
\begin{itemize}
\tightlist
\item Mapping: encoding systems $\to$ codebases, facts $\to$ structural specifications
\item Definition of SSOT as DOF = 1 for software
\item Theorem~\ref{thm:ssot-determinate}: SSOT eliminates indeterminacy
\end{itemize}

\textbf{3. Language requirements (Section~\ref{sec:requirements}):}
\begin{itemize}
\tightlist
\item Theorem~\ref{thm:hooks-necessary}: Definition-time hooks are necessary
\item Theorem~\ref{thm:introspection-necessary}: Introspection is necessary
\item Theorem~\ref{thm:ssot-iff}: Both together are sufficient
\item Proof that these requirements are forced by the structure of the problem
\end{itemize}

\textbf{4. Language evaluation (Section~\ref{sec:evaluation}):}
\begin{itemize}
\tightlist
\item Exhaustive evaluation of 10 mainstream languages
\item Extended evaluation of 3 non-mainstream languages (CLOS, Smalltalk, Ruby)
\item Theorem~\ref{thm:three-lang}: Exactly three languages satisfy requirements
\end{itemize}

\textbf{5. Complexity bounds (Section~\ref{sec:bounds}):}
\begin{itemize}
\tightlist
\item Theorem~\ref{thm:upper-bound}: SSOT achieves $O(1)$ coherence restoration
\item Theorem~\ref{thm:lower-bound}: Non-SSOT requires $\Omega(n)$ modifications
\item Theorem~\ref{thm:unbounded-gap}: The gap is unbounded
\end{itemize}

\textbf{6. Practical demonstration (Section~\ref{sec:empirical}):}
\begin{itemize}
\tightlist
\item Before/after examples from OpenHCS (production Python codebase)
\item PR \#44~\cite{openhcsPR44}: Migration from 47 scattered checks to 1 ABC (DOF 47 $\to$ 1)
\item Empirical validation that coherence is achievable in practice
\end{itemize}

\subsection{Empirical Context: OpenHCS}\label{sec:openhcs-context}

\textbf{What it does:} OpenHCS~\cite{openhcs2025} is an open-source bioimage analysis platform for high-content screening (45K LoC Python). It processes microscopy images through configurable pipelines, with GUI-based design and Python code export. The system requires:

\begin{itemize}
\tightlist
\item Automatic registration of analysis components
\item Type-safe configuration with inheritance
\item Runtime enumeration of available processors
\item Provenance tracking for reproducibility
\end{itemize}

\textbf{Why it matters for this paper:} OpenHCS requires SSOT for structural facts. When a new image processor is added (by subclassing \texttt{BaseProcessor}), it must automatically appear in:

\begin{itemize}
\tightlist
\item The GUI component palette
\item The configuration schema
\item The serialization registry
\item The documentation generator
\end{itemize}

Without SSOT, adding a processor requires updating 4+ locations. With SSOT, only the class definition is needed. Python's \texttt{\_\_init\_subclass\_\_} and \texttt{\_\_subclasses\_\_()} handle the rest.

\textbf{Key finding:} PR \#44~\cite{openhcsPR44} migrated from duck typing (\texttt{hasattr()} checks) to nominal typing (ABC contracts). This eliminated 47 scattered checks, reducing DOF from 47 to 1. The migration validates both:
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item The theoretical prediction: DOF reduction is achievable
\item The practical benefit: Maintenance cost decreased measurably
\end{enumerate}

\subsection{Decision Procedure, Not Preference}\label{sec:decision}

The contribution of this paper is not the theorems alone, but their consequence: \emph{language selection for coherent representation becomes a decision procedure}.

Given coherence as a requirement:
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item DOF = 1 is necessary (Corollary~\ref{cor:coherence-forces-ssot})
\item DOF = 1 for structural facts requires definition-time hooks AND introspection (Theorem~\ref{thm:ssot-iff})
\item Languages lacking these features cannot achieve coherence for structural facts
\end{enumerate}

\textbf{Implications:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Language design.} Future languages should include definition-time hooks and introspection if coherent structural representation is a design goal.
\item
  \textbf{Architecture.} When coherence is required, language selection is constrained. ``I prefer Go'' is not valid when structural coherence is required.
\item
  \textbf{Tooling.} External tools can work around language limitations but operate outside language semantics.
\item
  \textbf{Pedagogy.} DRY should be taught as epistemic necessity with language requirements, not as a vague guideline.
\end{enumerate}

\subsection{Paper Structure}\label{sec:structure}

Section~\ref{sec:foundations} establishes epistemic foundations (coherence, oracle arbitrariness) and instantiates them to software. Section~\ref{sec:ssot} defines SSOT as the coherent representation and proves its properties. Section~\ref{sec:requirements} derives language requirements with necessity proofs. Section~\ref{sec:evaluation} evaluates mainstream languages exhaustively. Section~\ref{sec:bounds} proves complexity bounds. Section~\ref{sec:empirical} demonstrates practical application. Section~\ref{sec:related} surveys related work. Appendix~\ref{sec:rebuttals} addresses anticipated objections. Appendix~\ref{sec:lean} contains complete Lean 4 proof listings.

\subsection{Anticipated Objections}\label{sec:objection-summary}

Before proceeding, we address objections readers are likely forming. Each is refuted in detail in Appendix~\ref{sec:rebuttals}; here we summarize the key points.

\paragraph{``The model doesn't capture real Python/Rust semantics.''}
The model is validated through instantiation proofs (\S\ref{sec:rebuttals}, Part I). \texttt{PythonInstantiation.lean} proves that all Python observables factor through the (B, S) axes. \texttt{LangPython.lean} directly encodes Python's datamodel specification. The model is falsifiable: produce Python code where two types with identical \texttt{\_\_bases\_\_} and \texttt{\_\_dict\_\_} behave differently, or where \texttt{\_\_init\_subclass\_\_} fails to fire.

\paragraph{``Rust can achieve SSOT with proc macros and static registries.''}
No. Proc macros are per-item isolated---they cannot see other items during expansion. Registration is bypassable: you can \texttt{impl Trait} without any \texttt{\#[derive]} annotation. The \texttt{inventory} crate uses linker tricks external to language semantics. Contrast Python: \texttt{\_\_init\_subclass\_\_} fires automatically and \emph{cannot be bypassed}. This is enforcement vs. enablement (\S\ref{sec:rebuttals}, Part III).

\paragraph{``The requirements are circular---you define structural facts as fixed at definition time, then prove you need definition-time hooks.''}
No. We define structural facts by their \emph{syntactic locus} (encoded in type definitions). The observation that they are fixed at definition time is a \emph{consequence} of this locus. The theorem that hooks are required is \emph{derived} from the observation. The circularity objection mistakes consequence for premise (\S\ref{sec:rebuttals}, Part II).

\paragraph{``Build.rs / external tools can achieve SSOT.''}
External tools operate outside language semantics. They can fail, be misconfigured, or be bypassed. They provide no runtime verification---the program cannot confirm derivation occurred. Build tool configuration becomes a second source (DOF $\geq$ 2). This approximates SSOT but does not achieve it (\S\ref{sec:rebuttals}, Parts II--III).

\paragraph{``The DOF = 1 definition is too restrictive.''}
The definition is \emph{derived}, not chosen. DOF = 0 means the fact is unrepresented. DOF $> 1$ means multiple sources can diverge. DOF = 1 is the unique optimal point. Systems with DOF $> 1$ may be pragmatically acceptable but do not satisfy SSOT (\S\ref{sec:rebuttals}, Part II).

\paragraph{``You just need discipline, not language features.''}
Discipline \emph{is} the external oracle. The theorem states: with DOF $> 1$, consistency requires an external oracle. ``Code review and documentation'' are exactly that oracle---human-maintained, fallible, bypassable. Language enforcement cannot be forgotten; human discipline can (\S\ref{sec:rebuttals}, Part IV).

\paragraph{``The proofs are trivial (\texttt{rfl}).''}
When modeling is correct, theorems become definitional. This is a feature. Not all proofs are \texttt{rfl}: \texttt{rust\_lacks\_introspection} is 40 lines of actual reasoning. The contribution is making the right definitions so that consequences follow structurally (\S\ref{sec:rebuttals}, Part V).

\medskip
\noindent\textbf{If you have an objection not listed above,} check Appendix~\ref{sec:rebuttals} (16 objections addressed) before concluding it has not been considered.

%==============================================================================
