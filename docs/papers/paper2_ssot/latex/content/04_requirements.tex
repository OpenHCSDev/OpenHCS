\section{Language Requirements for SSOT}\label{sec:requirements}
%==============================================================================

We now derive the language features necessary and sufficient for achieving SSOT. This section answers: \emph{What must a language provide for SSOT to be possible?}

The requirements are derived from SSOT's definition. The proofs establish necessity.

\subsection{The Foundational Axiom}\label{sec:axiom}

The derivation rests on one axiom, which follows from how programming languages work:

\begin{axiom}[Structural Fixation]\label{axiom:fixation}
Structural facts are fixed at definition time. After a class/type is defined, its inheritance relationships, method signatures, and other structural properties cannot be retroactively changed.
\end{axiom}

This is not controversial. In every mainstream language:
\begin{itemize}
\tightlist
\item Once \texttt{class Foo extends Bar} is compiled/interpreted, \texttt{Foo}'s parent cannot become \texttt{Baz}
\item Once \texttt{def process(self, x: int)} is defined, the signature cannot retroactively become \texttt{(self, x: str)}
\item Once \texttt{trait Handler} is implemented for \texttt{PNGDecoder}, that relationship is permanent
\end{itemize}

Languages that allow runtime modification (Python's \texttt{\_\_bases\_\_}, Ruby's reopening) are modifying \emph{future} behavior, not \emph{past} structure. The fact that ``\texttt{PNGHandler} was defined as a subclass of \texttt{Handler}'' is fixed at the moment of definition.

\textbf{All subsequent theorems are logical consequences of this axiom.} Rejecting the axiom requires demonstrating a language where structural facts can be retroactively modified---which does not exist.

\subsection{The Timing Constraint}\label{sec:timing}

The key insight is that structural facts have a \emph{timing constraint}. Unlike configuration values (which can be changed at any time), structural facts are fixed at specific moments:

\begin{definition}[Structural Timing]\label{def:structural-timing}
A structural fact $F$ (class existence, inheritance relationship, method signature) is \emph{fixed} when its defining construct is executed. After that point, the structure cannot be retroactively modified.
\end{definition}

In Python, classes are defined when the \texttt{class} statement executes:

\begin{verbatim}
class Detector(Processor):  # Structure fixed HERE
    def detect(self, img): ...

# After this point, Detector's inheritance cannot be changed
\end{verbatim}

In Java, classes are defined at compile time:

\begin{verbatim}
public class Detector extends Processor {  // Structure fixed at COMPILE TIME
    public void detect(Image img) { ... }
}
\end{verbatim}

\textbf{Critical Distinction: Compile-Time vs. Definition-Time}

These terms are often confused. We define them precisely:

\begin{definition}[Compile-Time]\label{def:compile-time}
\emph{Compile-time} is when source code is translated to an executable form (bytecode, machine code). Compile-time occurs \emph{before the program runs}.
\end{definition}

\begin{definition}[Definition-Time]\label{def:definition-time}
\emph{Definition-time} is when a class/type definition is \emph{executed}. In Python, this is \emph{at runtime} when the \texttt{class} statement runs. In Java, this is \emph{at compile-time} when \texttt{javac} processes the file.
\end{definition}

The key insight: \textbf{Python's \texttt{class} statement is executable code.} When Python encounters:

\begin{verbatim}
class Foo(Bar):
    x = 1
\end{verbatim}

It \emph{executes} code that:
\begin{enumerate}
\tightlist
\item Creates a new namespace
\item Executes the class body in that namespace
\item Calls the metaclass to create the class object
\item Calls \texttt{\_\_init\_subclass\_\_} on parent classes
\item Binds the name \texttt{Foo} to the new class
\end{enumerate}

This is why Python has ``definition-time hooks''---they execute when the definition runs.

Java's \texttt{class} declaration is \emph{not} executable---it is a static declaration processed by the compiler. No user code can hook into this process.

The timing constraint has profound implications for derivation:

\begin{theorem}[Timing Forces Definition-Time Derivation]\label{thm:timing-forces}
Derivation for structural facts must occur at or before the moment the structure is fixed.
\end{theorem}

\begin{proof}
Let $F$ be a structural fact. Let $t_{\text{fix}}$ be the moment $F$ is fixed. Any derivation $D$ that depends on $F$ must execute at some time $t_D$.

Case 1: $t_D < t_{\text{fix}}$. Then $D$ executes before $F$ is fixed. $D$ cannot derive from $F$ because $F$ does not yet exist.

Case 2: $t_D > t_{\text{fix}}$. Then $D$ executes after $F$ is fixed. $D$ can read $F$ but cannot modify structure derived from $F$---the structure is already fixed.

Case 3: $t_D = t_{\text{fix}}$. Then $D$ executes at the moment $F$ is fixed. $D$ can both read $F$ and modify derived structures before they are fixed.

Therefore, derivation for structural facts must occur at definition time ($t_D = t_{\text{fix}}$).
\end{proof}

\subsection{Requirement 1: Definition-Time Hooks}\label{sec:hooks}

\begin{definition}[Definition-Time Hook]\label{def:hook}
A \emph{definition-time hook} is a language construct that executes arbitrary code when a definition (class, function, module) is \emph{created}, not when it is \emph{used}.
\end{definition}

This concept has theoretical foundations in metaobject protocols~\cite{kiczales1991art}, where class initialization in CLOS allows arbitrary code execution at definition time. Python's implementation of this capability is derived from the same tradition.

\textbf{Python's definition-time hooks:}

\begin{center}
\begin{tabular}{lp{8cm}}
\toprule
\textbf{Hook} & \textbf{When it executes} \\
\midrule
\texttt{\_\_init\_subclass\_\_} & When a subclass is defined \\
Metaclass \texttt{\_\_new\_\_}/\texttt{\_\_init\_\_} & When a class using that metaclass is defined \\
Class decorator & Immediately after class body executes \\
\texttt{\_\_set\_name\_\_} & When a descriptor is assigned to a class attribute \\
\bottomrule
\end{tabular}
\end{center}

\textbf{Example: \texttt{\_\_init\_subclass\_\_} registration}

\begin{verbatim}
class Registry:
    _handlers = {}

    def __init_subclass__(cls, format=None, **kwargs):
        super().__init_subclass__(**kwargs)
        if format:
            Registry._handlers[format] = cls

class PNGHandler(Registry, format="png"):
    pass  # Automatically registered when class is defined

class JPGHandler(Registry, format="jpg"):
    pass  # Automatically registered when class is defined

# Registry._handlers == {"png": PNGHandler, "jpg": JPGHandler}
\end{verbatim}

The registration happens at definition time, not at first use. When the \texttt{class PNGHandler} statement executes, \texttt{\_\_init\_subclass\_\_} runs and adds the handler to the registry.

\begin{theorem}[Definition-Time Hooks are Necessary]\label{thm:hooks-necessary}
SSOT for structural facts requires definition-time hooks.
\end{theorem}

\begin{proof}
By Theorem~\ref{thm:timing-forces}, derivation for structural facts must occur at definition time. Without definition-time hooks, no code can execute at that moment. Therefore, derivation is impossible. Without derivation, secondary encodings cannot be automatically updated. DOF $>$ 1 is unavoidable.

Contrapositive: If a language lacks definition-time hooks, SSOT for structural facts is impossible.
\end{proof}

\textbf{Languages lacking definition-time hooks:}

\begin{itemize}
\tightlist
\item \textbf{Java}: Annotations are metadata, not executable hooks. They are processed by external tools (annotation processors), not by the language at class definition.
\item \textbf{C++}: Templates expand at compile time but do not execute arbitrary code. SFINAE and \texttt{constexpr if} are not hooks---they select branches, not execute callbacks.
\item \textbf{Go}: No hook mechanism. Interfaces are implicit. No code runs at type definition.
\item \textbf{Rust}: Procedural macros run at compile time but are opaque at runtime. The macro expansion is not introspectable.
\end{itemize}

\subsection{Requirement 2: Introspectable Derivation}\label{sec:introspection}

Definition-time hooks enable derivation. But SSOT also requires \emph{verification}---the ability to confirm that DOF = 1. This requires \emph{computational reflection}---the ability of a program to reason about its own structure~\cite{smith1984reflection}.

\begin{definition}[Introspectable Derivation]\label{def:introspection}
Derivation is \emph{introspectable} iff the program can query:
\begin{enumerate}
\tightlist
\item What structures were derived
\item From which source each derived structure came
\item What the current state of derived structures is
\end{enumerate}
\end{definition}

\textbf{Python's introspection capabilities:}

\begin{center}
\begin{tabular}{lp{7cm}}
\toprule
\textbf{Query} & \textbf{Python Mechanism} \\
\midrule
What subclasses exist? & \texttt{cls.\_\_subclasses\_\_()} \\
What is the inheritance chain? & \texttt{cls.\_\_mro\_\_} \\
What attributes does a class have? & \texttt{dir(cls)}, \texttt{vars(cls)} \\
What type is this object? & \texttt{type(obj)}, \texttt{isinstance(obj, cls)} \\
What methods are abstract? & \texttt{cls.\_\_abstractmethods\_\_} \\
\bottomrule
\end{tabular}
\end{center}

\textbf{Example: Verifying registration completeness}

\begin{verbatim}
def verify_registration():
    """Verify all subclasses are registered."""
    all_subclasses = set(ImageLoader.__subclasses__())
    registered = set(LOADER_REGISTRY.values())

    unregistered = all_subclasses - registered
    if unregistered:
        raise RuntimeError(f"Unregistered loaders: {unregistered}")
\end{verbatim}

This verification is only possible because Python provides \texttt{\_\_subclasses\_\_()}. In languages without this capability, the programmer cannot enumerate what subclasses exist.

\begin{theorem}[Introspection is Necessary for Verifiable SSOT]\label{thm:introspection-necessary}
Verifying that SSOT holds requires introspection.
\end{theorem}

\begin{proof}
Verification of SSOT requires confirming DOF = 1. This requires:
\begin{enumerate}
\tightlist
\item Enumerating all locations encoding fact $F$
\item Determining which are independent vs. derived
\item Confirming exactly one is independent
\end{enumerate}

Step (1) requires introspection: the program must query what structures exist and what they encode. Without introspection, the program cannot enumerate encodings. Verification is impossible.

Without verifiable SSOT, the programmer cannot confirm SSOT holds. They must trust that their code is correct without runtime confirmation. Bugs in derivation logic go undetected.
\end{proof}

\textbf{Languages lacking introspection for derivation:}

\begin{itemize}
\tightlist
\item \textbf{C++}: Cannot ask ``what types instantiated template \texttt{Foo<T>}?''
\item \textbf{Rust}: Procedural macro expansion is opaque at runtime. Cannot query what was generated.
\item \textbf{TypeScript}: Types are erased at runtime. Cannot query type relationships.
\item \textbf{Go}: No type registry. Cannot enumerate types implementing an interface.
\end{itemize}

\subsection{Independence of Requirements}\label{sec:independence}

The two requirements---definition-time hooks and introspection---are independent. Neither implies the other.

\begin{theorem}[Requirements are Independent]\label{thm:independence}
\begin{enumerate}
\tightlist
\item A language can have definition-time hooks without introspection
\item A language can have introspection without definition-time hooks
\end{enumerate}
\end{theorem}

\begin{proof}
\textbf{(1) Hooks without introspection:} Rust procedural macros execute at compile time (a form of definition-time hook) but the generated code is opaque at runtime. The program cannot query what the macro generated.

\textbf{(2) Introspection without hooks:} Java provides \texttt{Class.getMethods()}, \texttt{Class.getInterfaces()}, etc. (introspection) but no code executes when a class is defined. Annotations are metadata, not executable hooks.

Therefore, the requirements are independent.
\end{proof}

\subsection{The Completeness Theorem}\label{sec:completeness}

\begin{theorem}[Necessary and Sufficient Conditions for SSOT]\label{thm:ssot-iff}
A language $L$ enables complete SSOT for structural facts if and only if:
\begin{enumerate}
\tightlist
\item $L$ provides definition-time hooks, AND
\item $L$ provides introspectable derivation results
\end{enumerate}
\end{theorem}

\begin{proof}
$(\Rightarrow)$ \textbf{Necessity:} Suppose $L$ enables complete SSOT for structural facts.
\begin{itemize}
\tightlist
\item By Theorem~\ref{thm:hooks-necessary}, $L$ must provide definition-time hooks
\item By Theorem~\ref{thm:introspection-necessary}, $L$ must provide introspection
\end{itemize}

$(\Leftarrow)$ \textbf{Sufficiency:} Suppose $L$ provides both definition-time hooks and introspection.
\begin{itemize}
\tightlist
\item Definition-time hooks enable derivation at the right moment (when structure is fixed)
\item Introspection enables verification that all secondary encodings are derived
\item Therefore, SSOT is achievable: create one source, derive all others, verify completeness
\end{itemize}

The if-and-only-if follows.
\end{proof}

\begin{corollary}[SSOT-Complete Languages]\label{cor:ssot-complete}
A language is \emph{SSOT-complete} iff it satisfies both requirements. A language is \emph{SSOT-incomplete} otherwise.
\end{corollary}

\subsection{The Logical Chain (Summary)}\label{sec:chain}

For clarity, we summarize the complete derivation from axiom to conclusion:

\begin{center}
\fbox{\parbox{0.9\textwidth}{
\textbf{Axiom~\ref{axiom:fixation}:} Structural facts are fixed at definition time.

$\downarrow$ (definitional)

\textbf{Theorem~\ref{thm:timing-forces}:} Derivation for structural facts must occur at definition time.

$\downarrow$ (logical necessity)

\textbf{Theorem~\ref{thm:hooks-necessary}:} Definition-time hooks are necessary for SSOT.

\textbf{Theorem~\ref{thm:introspection-necessary}:} Introspection is necessary for verifiable SSOT.

$\downarrow$ (conjunction)

\textbf{Theorem~\ref{thm:ssot-iff}:} A language enables SSOT iff it has both hooks and introspection.

$\downarrow$ (evaluation)

\textbf{Corollary:} Python, CLOS, Smalltalk are SSOT-complete. Java, C++, Rust, Go are not.
}}
\end{center}

\textbf{Every step is machine-checked in Lean 4.} The proofs compile with zero \texttt{sorry} placeholders. Rejecting this chain requires identifying a specific flaw in the axiom, the logic, or the Lean formalization.

\subsection{Concrete Impossibility Demonstration}\label{sec:impossibility}

We now demonstrate \emph{exactly why} SSOT-incomplete languages cannot achieve SSOT for structural facts. This is not about ``Java being worse''---it is about what Java \emph{cannot express}.

\textbf{The Structural Fact:} ``\texttt{PNGHandler} handles \texttt{.png} files.''

This fact must be encoded in two places:
\begin{enumerate}
\tightlist
\item The class definition (where the handler is defined)
\item The registry/dispatcher (where formatâ†’handler mapping lives)
\end{enumerate}

\textbf{Python achieves SSOT:}

\begin{verbatim}
class ImageHandler:
    _registry = {}

    def __init_subclass__(cls, format=None, **kwargs):
        super().__init_subclass__(**kwargs)
        if format:
            ImageHandler._registry[format] = cls  # DERIVED

class PNGHandler(ImageHandler, format="png"):  # SOURCE
    def load(self, path): ...
\end{verbatim}

DOF = 1. The \texttt{format="png"} in the class definition is the \emph{single source}. The registry entry is \emph{derived} automatically by \texttt{\_\_init\_subclass\_\_}. Adding a new handler requires changing exactly one location.

\textbf{Java cannot achieve SSOT:}

\begin{verbatim}
// File 1: PNGHandler.java
@Handler(format = "png")  // Annotation is METADATA, not executable
public class PNGHandler implements ImageHandler {
    public BufferedImage load(String path) { ... }
}

// File 2: HandlerRegistry.java (SEPARATE SOURCE!)
public class HandlerRegistry {
    static {
        register("png", PNGHandler.class);  // Must be maintained manually
        register("jpg", JPGHandler.class);
        // Forgot to add TIFFHandler? Runtime error.
    }
}
\end{verbatim}

DOF = 2. The \texttt{@Handler(format = "png")} annotation is \emph{data}, not code. It does not execute when the class is defined. The registry must be maintained separately.

\begin{theorem}[Generated Files Are Second Encodings]\label{thm:generated-second}
A generated source file constitutes a second encoding, not a derivation. Therefore, code generation does not achieve SSOT.
\end{theorem}

\begin{proof}
Let $F$ be a structural fact (e.g., ``PNGHandler handles .png files'').

Let $E_1$ be the annotation: \texttt{@Handler(format="png")} on \texttt{PNGHandler.java}.

Let $E_2$ be the generated file: \texttt{HandlerRegistry.java} containing \texttt{register("png", PNGHandler.class)}.

By Definition~\ref{def:dof}, $E_1$ and $E_2$ are both encodings of $F$ iff modifying either can change the system's behavior regarding $F$.

Test: If we delete or modify \texttt{HandlerRegistry.java}, does the system's behavior change? \textbf{Yes}---the handler will not be registered.

Test: If we modify the annotation, does the system's behavior change? \textbf{Yes}---the generated file will have different content.

Therefore, $E_1$ and $E_2$ are independent encodings. DOF $= 2$.
Formally: if an artifact $r$ is absent from the program's runtime
equality relation (cannot be queried or mutated in-process), then
$\text{encodes}(r,F)$ introduces an independent DOF.

The fact that $E_2$ was \emph{generated from} $E_1$ does not make it a derivation in the SSOT sense, because:
\begin{enumerate}
\tightlist
\item $E_2$ exists as a separate artifact that can be edited, deleted, or fail to generate
\item $E_2$ must be separately compiled
\item The generation process is external to the language and can be bypassed
\end{enumerate}

Contrast with Python, where the registry entry exists only in memory, created by the class statement itself. There is no second file. DOF $= 1$.
\end{proof}

\textbf{Why Rust proc macros don't help:}

\begin{theorem}[Opaque Expansion Prevents Verification]\label{thm:opaque-expansion}
If macro/template expansion is opaque at runtime, SSOT cannot be verified.
\end{theorem}

\begin{proof}
Verification of SSOT requires answering: ``Is every encoding of $F$ derived from the single source?''

This requires enumerating all encodings. If expansion is opaque, the program cannot query what was generated.

In Rust, after \texttt{\#[derive(Handler)]} expands, the program cannot ask ``what did this macro generate?'' The expansion is compiled into the binary but not introspectable.

Without introspection, the program cannot verify DOF $= 1$. SSOT may hold but cannot be confirmed.
\end{proof}

\textbf{The Gap is Fundamental:}

The distinction is not ``Python has nicer syntax.'' The distinction is:
\begin{itemize}
\tightlist
\item Python: Class definition \emph{executes code} that creates derived structures \emph{in memory}
\item Java: Class definition \emph{produces data} that external tools process into \emph{separate files}
\item Rust: Macro expansion \emph{is invisible at runtime}---verification impossible
\end{itemize}

This is a language design choice with permanent consequences. No amount of clever coding in Java can make the registry \emph{derived from} the class definition, because Java provides no mechanism for code to execute at class definition time.

%==============================================================================
