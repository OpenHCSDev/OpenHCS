\section{Preemptive Rebuttals}\label{sec:rebuttals}

This appendix addresses anticipated objections. Each objection is stated in its strongest form, then refuted.

\subsection{Objection: The SSOT Definition is Too Narrow}

\textbf{Objection:} ``Your definition of SSOT as DOF = 1 is too restrictive. Real-world systems have acceptable levels of duplication.''

\textbf{Response:} The definition is \textbf{derived}, not chosen. DOF = 1 is the unique optimal point:

\begin{center}
\begin{tabular}{cl}
\toprule
\textbf{DOF} & \textbf{Meaning} \\
\midrule
0 & Fact is not encoded (underspecification) \\
1 & Single source of truth (optimal) \\
$>$1 & Multiple sources can diverge (inconsistency risk) \\
\bottomrule
\end{tabular}
\end{center}

DOF = 2 means two locations can hold different values for the same fact. The \emph{possibility} of inconsistency exists. The definition is mathematical: SSOT requires DOF = 1. Systems with DOF $>$ 1 may be pragmatically acceptable but do not satisfy SSOT.

\subsection{External Tools vs Language-Level SSOT}

External tools (annotation processors, code generators, build systems) can approximate SSOT behavior. These differ from language-level SSOT in three dimensions:

\begin{enumerate}
\item \textbf{External to language semantics:} Build tools can fail, be misconfigured, or be bypassed. They operate outside the language model.

\item \textbf{No runtime verification:} The program cannot confirm that derivation occurred correctly. Python's \texttt{\_\_subclasses\_\_()} verifies registration completeness at runtime. External tools provide no runtime guarantee.

\item \textbf{Configuration-dependent:} External tools require project-specific setup. Python's \texttt{\_\_init\_subclass\_\_} works in any environment without configuration.
\end{enumerate}

The analysis characterizes SSOT \emph{within language semantics}, where DOF = 1 holds at runtime.

\subsection{Derivation Order}

The analysis proceeds from definition to language evaluation:

\begin{enumerate}
\item Define SSOT mathematically (DOF = 1)
\item Prove necessary language features (definition-time hooks + introspection)
\item Evaluate languages against derived criteria
\item Result: Python, CLOS, and Smalltalk satisfy both requirements
\end{enumerate}

Three languages satisfy the criteria. Two (CLOS, Smalltalk) are not mainstream. This validates that the requirements characterize a genuine language capability class. The requirements are derived from SSOT's definition, independent of any particular language's feature set.

\subsection{Empirical Validation}

The case studies demonstrate patterns, with publicly verifiable instances:

\begin{itemize}
\tightlist
\item PR \#44: 47 \texttt{hasattr()} checks → 1 ABC definition (verifiable via GitHub diff)
\item Three general patterns: contract enforcement, automatic registration, automatic discovery
\item Each pattern represents a mechanism, applicable to codebases exhibiting similar structure
\end{itemize}

The theoretical contribution is the formal proof. The examples demonstrate applicability.

\subsection{Asymptotic Analysis}

The complexity bounds are derived from the mechanism:

\begin{itemize}
\tightlist
\item SSOT: changing a fact requires 1 edit (the single source)
\item Non-SSOT: changing a fact requires $n$ edits (one per encoding location)
\item The ratio $n/1$ grows unbounded as $n$ increases
\end{itemize}

PR \#44 demonstrates the mechanism at $n = 47$: 47 \texttt{hasattr()} checks → 1 ABC definition. The 47$\times$ reduction is observable via GitHub diff. The gap widens as codebases grow.

\subsection{Cost-Benefit Analysis}

SSOT involves trade-offs:
\begin{itemize}
\tightlist
\item \textbf{Benefit:} Modification complexity $O(1)$ vs $\Omega(n)$
\item \textbf{Cost:} Metaprogramming complexity, potential performance overhead
\end{itemize}

The analysis characterizes what SSOT requires. The decision to use SSOT depends on codebase scale and change frequency.

\subsection{Machine-Checked Formalization}

The proofs formalize definitions precisely. Machine-checked proofs provide:

\begin{enumerate}
\item \textbf{Precision:} Lean requires every step to be explicit
\item \textbf{Verification:} Computer-checked, eliminating human error
\item \textbf{Reproducibility:} Anyone can run the proofs and verify results
\end{enumerate}

The contribution is formalization itself: converting informal principles into machine-verifiable theorems. Simple proofs from precise definitions are the goal.

\subsection{Build Tool Analysis}

External build tools shift the SSOT problem:

\begin{enumerate}
\item \textbf{DOF $\geq$ 2:} Build tool configuration becomes a second source. Let $C$ be codebase, $T$ be tool. Then $\text{DOF}(C \cup T, F) \geq 2$ because both source and config encode $F$.

\item \textbf{No runtime verification:} Generated code lacks derivation provenance. Cannot query ``was this method generated or hand-written?''

\item \textbf{Cache invalidation:} Build tools must track dependencies. Stale caches cause bugs absent from language-native derivation.

\item \textbf{Build latency:} Every edit requires build step. Language-native SSOT (Python metaclasses) executes during \texttt{import}.
\end{enumerate}

External tools reduce DOF from $n$ to $k$ where $k$ is the number of tool configurations. Since $k > 1$, SSOT (DOF = 1) is not satisfied.

Cross-language code generation (e.g., protobuf) requires external tools. The analysis characterizes single-language SSOT.

%==============================================================================
