\section{Optimal Encoding Rate (DOF = 1)}\label{sec:ssot}
%==============================================================================

Having established the encoding model (Section~\ref{sec:epistemic}), we now prove that DOF = 1 is the unique optimal rate guaranteeing coherence under modification constraints.

\subsection{DOF = 1 as Optimal Rate}\label{sec:ssot-def}

DOF = 1 is not a design guideline. It is the information-theoretically optimal rate guaranteeing coherence for facts encoded in systems with modification constraints.

\begin{definition}[Optimal Encoding (DOF = 1)]\label{def:ssot}
Encoding system $C$ achieves \emph{optimal encoding rate} for fact $F$ iff:
\[
\text{DOF}(C, F) = 1
\]
Equivalently: exactly one independent encoding location exists for $F$. All other encodings are derived.
\end{definition}

\textbf{This generalizes the ``Single Source of Truth'' (SSOT) principle from software engineering to universal encoding theory.}

\textbf{Encoding-theoretic interpretation:}
\begin{itemize}
\tightlist
\item DOF = 1 means exactly one independent encoding location
\item All other locations are derived (cannot diverge from source)
\item Incoherence is \emph{impossible}, not merely unlikely
\item The encoding rate is minimized subject to coherence constraint
\end{itemize}

\begin{theorem}[DOF = 1 Guarantees Determinacy]\label{thm:ssot-determinate}
If $\text{DOF}(C, F) = 1$, then for all reachable states of $C$, the value of $F$ is determinate: all encodings agree.
\end{theorem}

\begin{proof}
By Theorem~\ref{thm:dof-one-coherence}, DOF = 1 guarantees coherence. Coherence means all encodings hold the same value. Therefore, the value of $F$ is uniquely determined by the single source.
\end{proof}

Hunt \& Thomas's ``single, unambiguous, authoritative representation''~\cite{hunt1999pragmatic} (SSOT principle) corresponds precisely to this encoding-theoretic structure:
\begin{itemize}
\tightlist
\item \textbf{Single:} DOF = 1 (exactly one independent encoding)
\item \textbf{Unambiguous:} No incoherent states possible (Theorem~\ref{thm:dof-one-coherence})
\item \textbf{Authoritative:} The source determines all derived values (Definition~\ref{def:derived})
\end{itemize}

Our contribution is proving that SSOT is not a heuristic but an information-theoretic optimality condition.

\begin{theorem}[DOF = 1 Achieves $O(1)$ Update]\label{thm:ssot-optimal}
If $\text{DOF}(C, F) = 1$, then coherence restoration requires $O(1)$ updates: modifying the single source maintains coherence automatically via derivation.
\end{theorem}

\begin{proof}
Let $\text{DOF}(C, F) = 1$. Let $L_s$ be the single independent encoding location. All other encodings $L_1, \ldots, L_k$ are derived from $L_s$.

When fact $F$ changes:
\begin{enumerate}
\tightlist
\item Update $L_s$ (1 edit)
\item By Definition~\ref{def:derived}, $L_1, \ldots, L_k$ are automatically updated
\item Coherence is maintained: all locations agree on the new value
\end{enumerate}

Coherence restoration requires exactly 1 manual update. The number of encoding locations $k$ is irrelevant. Complexity is $O(1)$.
\end{proof}

\begin{theorem}[Uniqueness of Optimal Rate]\label{thm:ssot-unique}
DOF = 1 is the \textbf{unique} rate guaranteeing coherence. DOF = 0 fails to represent $F$; DOF $> 1$ permits incoherence.
\end{theorem}

\begin{proof}
By Theorem~\ref{thm:dof-one-coherence}, DOF = 1 guarantees coherence.
By Theorem~\ref{thm:dof-gt-one-incoherence}, DOF $> 1$ permits incoherence.

This leaves only DOF = 1 as coherence-guaranteeing rate. DOF = 0 means no independent location encodes $F$---the fact is not represented.

Therefore, DOF = 1 is uniquely optimal. This is information-theoretic necessity, not design choice.
\end{proof}

\begin{corollary}[Incoherence Under Redundancy]\label{cor:no-redundancy}
Multiple independent sources encoding the same fact permit incoherent states. DOF $> 1 \Rightarrow$ incoherence reachable.
\end{corollary}

\begin{proof}
Direct application of Theorem~\ref{thm:dof-gt-one-incoherence}. With DOF $> 1$, independent locations can be modified separately, reaching states where they disagree.
\end{proof}

\subsection{Rate-Complexity Tradeoff}\label{sec:ssot-vs-m}

The DOF metric creates a fundamental tradeoff between encoding rate and modification complexity.

\textbf{Question:} When fact $F$ changes, how many manual updates are required to restore coherence?

\begin{itemize}
\tightlist
\item \textbf{DOF = 1:} $O(1)$ updates. The single source determines all derived locations automatically.
\item \textbf{DOF = $n > 1$:} $\Omega(n)$ updates. Each independent location must be synchronized manually.
\end{itemize}

This is a \emph{rate-distortion} analog: higher encoding rate (DOF $> 1$) incurs higher modification complexity. DOF = 1 achieves minimal complexity under the coherence constraint.

\textbf{Key insight:} Many locations can encode $F$ (high total encoding locations), but if DOF = 1, coherence restoration requires only 1 manual update. The derivation mechanism handles propagation automatically.

\begin{example}[Encoding Rate vs. Modification Complexity]\label{ex:ssot-large-m}
Consider an encoding system where a fact $F$ = ``all processors must implement operation $P$'' is encoded at 51 locations:
\begin{itemize}
\tightlist
\item 1 abstract specification location
\item 50 concrete implementation locations
\end{itemize}

\textbf{Architecture A (DOF = 51):} All 51 locations are independent.
\begin{itemize}
\tightlist
\item Modification complexity: Changing $F$ requires 51 manual updates
\item Coherence risk: After $k < 51$ updates, system is incoherent (partial updates)
\item Only after all 51 updates is coherence restored
\end{itemize}

\textbf{Architecture B (DOF = 1):} The abstract specification is the single source; implementations are derived.
\begin{itemize}
\tightlist
\item Modification complexity: Changing $F$ requires 1 update (the specification)
\item Coherence guarantee: Derived locations update automatically via enforcement mechanism
\item The \emph{specification} has a single authoritative source
\end{itemize}

\textbf{Computational realization (software):} Abstract base classes with enforcement (type checkers, runtime validation) achieve DOF = 1 for contract specifications. Changing the abstract method signature updates the contract; type checkers flag non-compliant implementations.

Note: Implementations are separate facts. DOF = 1 for the contract specification does not eliminate implementation updates---it ensures the specification itself is determinate.
\end{example}

\subsection{Derivation: The Coherence Mechanism}\label{sec:derivation}

Derivation is the mechanism by which DOF is reduced without losing encodings. A derived location cannot diverge from its source, eliminating it as a source of incoherence.

\begin{definition}[Derivation]\label{def:derivation}
Location $L_{\text{derived}}$ is \emph{derived from} $L_{\text{source}}$ for fact $F$ iff:
\[
\text{updated}(L_{\text{source}}) \rightarrow \text{automatically\_updated}(L_{\text{derived}})
\]
No manual intervention is required. Coherence is maintained automatically.
\end{definition}

Derivation can occur at different times depending on the encoding system:

\begin{center}
\begin{tabular}{lp{9cm}}
\toprule
\textbf{Derivation Time} & \textbf{Examples Across Domains} \\
\midrule
Compile/Build time & C++ templates, Rust macros, database schema generation, infrastructure-as-code compilation \\
Definition time & Python metaclasses, ORM model registration, dynamic schema creation \\
Query/Access time & Database views, computed columns, lazy evaluation \\
\bottomrule
\end{tabular}
\end{center}

\textbf{Structural facts require definition-time derivation.} Structural facts (class existence, schema structure, service topology) are fixed when defined. Compile-time derivation that runs before the definition is fixed is too early (the declarative source is not yet fixed). Runtime is too late (structure already immutable). Definition-time is the unique opportunity for structural derivation.

\begin{theorem}[Derivation Preserves Coherence]\label{thm:derivation-excludes}
If $L_{\text{derived}}$ is derived from $L_{\text{source}}$, then $L_{\text{derived}}$ cannot diverge from $L_{\text{source}}$ and does not contribute to DOF.
\end{theorem}

\begin{proof}
By Definition~\ref{def:derivation}, derived locations are automatically updated when the source changes. Let $L_d$ be derived from $L_s$. If $L_s$ encodes value $v$, then $L_d$ encodes $f(v)$ for some function $f$. When $L_s$ changes to $v'$, $L_d$ automatically changes to $f(v')$.

There is no reachable state where $L_s = v'$ and $L_d = f(v)$ with $v' \neq v$. Divergence is impossible. Therefore, $L_d$ does not contribute to DOF.
\end{proof}

\begin{corollary}[Derivation Achieves Coherence]\label{cor:metaprogramming}
If all encodings of $F$ except one are derived from that one, then $\text{DOF}(C, F) = 1$ and coherence is guaranteed.
\end{corollary}

\begin{proof}
Let $L_s$ be the non-derived encoding. All other encodings $L_1, \ldots, L_k$ are derived from $L_s$. By Theorem~\ref{thm:derivation-excludes}, none can diverge. Only $L_s$ is independent. Therefore, $\text{DOF}(C, F) = 1$, and by Theorem~\ref{thm:dof-one-coherence}, coherence is guaranteed.
\end{proof}

\subsection{Computational Realizations of DOF = 1}\label{sec:ssot-patterns}

DOF = 1 is achieved across computational domains using definition-time derivation mechanisms. We show examples from software, databases, and configuration systems.

\textbf{Software: Subclass Registration (Python)}

\begin{verbatim}
class Registry:
    _registry = {}
    def __init_subclass__(cls, **kwargs):
        Registry._registry[cls.__name__] = cls

class PNGHandler(Registry):  # Automatically registered
    pass
\end{verbatim}

\textbf{Encoding structure:}
\begin{itemize}
\tightlist
\item Source: Class definition (declared once)
\item Derived: Registry dictionary entry (computed at definition time via \texttt{\_\_init\_subclass\_\_})
\item DOF = 1: Registry cannot diverge from class hierarchy
\end{itemize}

\textbf{Databases: Materialized Views}

\begin{verbatim}
CREATE TABLE users (id INT, name TEXT, created_at TIMESTAMP);
CREATE MATERIALIZED VIEW user_count AS
  SELECT COUNT(*) FROM users;
\end{verbatim}

\textbf{Encoding structure:}
\begin{itemize}
\tightlist
\item Source: Base table \texttt{users}
\item Derived: Materialized view \texttt{user\_count} (updated on refresh)
\item DOF = 1: View cannot diverge from base table (consistency guaranteed by DBMS)
\end{itemize}

\textbf{Configuration: Infrastructure as Code (Terraform)}

\begin{verbatim}
resource "aws_instance" "app" {
  ami = "ami-12345"
  instance_type = "t2.micro"
}

output "instance_ip" {
  value = aws_instance.app.public_ip
}
\end{verbatim}

\textbf{Encoding structure:}
\begin{itemize}
\tightlist
\item Source: Resource declaration (authoritative configuration)
\item Derived: Output value (computed from resource state)
\item DOF = 1: Output cannot diverge from actual resource (computed at apply time)
\end{itemize}

\textbf{Common pattern:} In all cases, the source is declared once, and derived locations are computed automatically at definition/build/query time. Manual synchronization is eliminated. Coherence is guaranteed by the system, not developer discipline.

%==============================================================================
