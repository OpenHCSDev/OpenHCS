\section{Corollary: Programming-Language Instantiation}\label{sec:evaluation}
%==============================================================================

We instantiate Theorem~\ref{thm:ssot-iff} in the domain of programming languages. This section is a formal corollary of the realizability theorem: once a language's definition-time hooks and introspection capabilities are fixed, DOF = 1 realizability for structural facts is determined.

\begin{corollary}[Language Realizability Criterion]\label{cor:lang-realizability}
A programming language can realize DOF = 1 for structural facts iff it provides both (i) definition-time hooks and (ii) introspectable derivations. This is the direct instantiation of Theorem~\ref{thm:ssot-iff}.
\end{corollary}

\textbf{Instantiation map.} In the abstract model, an independent encoding is a location that can diverge under edits. In programming languages, structural facts are encoded at definition sites; \emph{definition-time hooks} implement derivation (automatic propagation), and \emph{introspection} implements provenance observability. Thus DEF corresponds to causal propagation and INTRO corresponds to queryable derivations; DOF = 1 is achievable exactly when both are present.

We instantiate this corollary over a representative language class (Definition~\ref{def:mainstream}).

\begin{definition}[Mainstream Language]\label{def:mainstream}
A language is \emph{mainstream} iff it appears in the top 20 of at least two of the following indices consistently over 5+ years:
\begin{enumerate}
\tightlist
\item TIOBE Index~\cite{tiobe2024} (monthly language popularity)
\item Stack Overflow Developer Survey (annual)
\item GitHub Octoverse (annual repository statistics)
\item RedMonk Programming Language Rankings (quarterly)
\end{enumerate}
\end{definition}

\subsection{Evaluation Criteria}\label{sec:criteria}

The abstract realizability conditions (causal update propagation and provenance observability) map directly to concrete language capabilities (definition-time hooks and runtime introspection). For TIT readers we summarize this mapping here and defer the full language-by-language evaluation, extended code examples, and detailed rationale to Supplement~A.

\subsection{Summary Classification}\label{sec:classification-summary}

Theorem~\ref{thm:ssot-iff} partitions languages into two classes:

\begin{center}
\begin{tabular}{lcc}
\toprule
\textbf{Language} & \textbf{Def-time hooks} & \textbf{Introspection} \\
\midrule
\multicolumn{3}{l}{\emph{DOF-1-complete (both requirements):}} \\
Python & \texttt{\_\_init\_subclass\_\_} & \texttt{\_\_subclasses\_\_()} \\
CLOS & \texttt{:after} methods & MOP queries \\
Smalltalk & class creation protocol & \texttt{subclasses} \\
\midrule
\multicolumn{3}{l}{\emph{DOF-1-incomplete (missing $\geq 1$ requirement):}} \\
Java & \textemdash & reflection \\
C++ & \textemdash & \textemdash \\
Rust & proc macros (compile-time) & \textemdash \\
Go & \textemdash & \textemdash \\
\bottomrule
\end{tabular}
\end{center}

\textbf{Interpretation.} DOF-1-complete languages can achieve DOF = 1 for structural facts using language-native mechanisms. DOF-1-incomplete languages require external tooling (code generation, IDE refactoring) which operates outside language semantics and can be bypassed (cf.\ Theorem~\ref{thm:independence} on why external tools do not establish derivation).

Supplement~A contains the complete evaluation with justifications, worked code examples demonstrating each mechanism, and discussion of edge cases.
