\section{Introduction}\label{introduction}

\subsection{The Encoding Problem}\label{sec:encoding-problem}

Consider an information system storing a fact $F$ (e.g., a threshold value, a configuration parameter, or a structural relationship) at $n$ locations. When can such a system guarantee \textbf{coherence}---the impossibility of disagreement among locations?

If location $L_1$ encodes ``threshold = 0.5'' while location $L_2$ encodes ``threshold = 0.7'', which is correct? No information internal to the system determines this. Any resolution requires external side information (timestamps, priority orderings, external oracles) not present in the encodings themselves.

This is an \textbf{information-theoretic} problem: what rate (number of independent encoding locations) guarantees zero-error decoding under modification constraints? We prove that exactly one independent encoding (DOF = 1, where DOF counts independent storage locations) is necessary and sufficient for guaranteed coherence.

\begin{theorem}[Resolution Impossibility, informal]
For any incoherent encoding system (DOF $> 1$ with divergent values) and any resolution procedure selecting a value, there exists an equally-present value that disagrees. No resolution is information-theoretically justified.
\end{theorem}

This parallels zero-error capacity constraints~\cite{korner1973graphs,lovasz1979shannon}: without sufficient side information, error-free decoding is impossible. Our contribution extends this to \textbf{interactive encoding systems} with modification requirements.

\subsection{The Optimal Rate Theorem}\label{sec:optimal-rate}

We prove that DOF = 1 is the \textbf{unique optimal rate} for coherent encoding:

\begin{itemize}
\tightlist
\item \textbf{DOF = 0:} Fact $F$ is not encoded (no information stored)
\item \textbf{DOF = 1:} Coherence guaranteed (unique independent source)
\item \textbf{DOF $> 1$:} Incoherent configurations reachable (multiple independent sources can diverge)
\end{itemize}

This generalizes Rissanen's Minimum Description Length (MDL) principle~\cite{rissanen1978mdl,gruenwald2007mdl} to systems with update constraints. MDL optimizes description length for static data; we optimize encoding rate for modifiable facts. The singleton solution space---exactly one rate achieves coherence---makes this a \textbf{forcing theorem}: given coherence as a requirement, DOF = 1 is mathematically necessary.

\subsection{Applications Across Domains}\label{sec:applications}

The abstract encoding model applies wherever facts are stored redundantly:

\begin{itemize}
\tightlist
\item \textbf{Distributed databases:} Replica consistency under partition constraints~\cite{brewer2000cap}
\item \textbf{Version control:} Merge resolution when branches diverge~\cite{hunt2002vcdiff}
\item \textbf{Configuration systems:} Multi-file settings with coherence requirements~\cite{delaet2010survey}
\item \textbf{Software systems:} Class registries, type definitions, interface contracts~\cite{hunt1999pragmatic}
\end{itemize}

In each domain, the question is identical: given multiple encoding locations, which is authoritative? Our theorems characterize when this question has a unique answer (DOF = 1) versus when it requires arbitrary external resolution (DOF $> 1$).

\subsection{Connection to Classical Information Theory}\label{sec:connection-it}

Our results extend classical encoding theory in three ways:

\textbf{1. From static to interactive encoding.} Shannon's source coding theorem~\cite{shannon1948mathematical} characterizes optimal encoding for static data. Slepian-Wolf~\cite{slepian1973noiseless} extends this to distributed sources with side information. We extend to \textbf{interactive systems} where encodings can be modified and must remain coherent across modifications.

\textbf{2. Zero-error requirement with modification constraints.} Classical zero-error capacity~\cite{korner1973graphs,lovasz1979shannon} characterizes communication without errors. We characterize \textbf{encoding without incoherence}---a storage analog where errors are disagreements among locations, not bit flips.

\textbf{3. Rate-complexity tradeoffs.} Rate-distortion theory~\cite{cover2006elements} trades encoding rate against distortion. We trade encoding rate (DOF) against modification complexity: DOF = 1 achieves $O(1)$ updates; DOF $> 1$ requires $\Omega(n)$ synchronization.

\subsection{Realizability in Computational Systems}\label{sec:realizability}

A key question: can the abstract optimality (DOF = 1) be \textbf{realized} in computational systems? We prove realizability requires two information-theoretic encoder properties:

\begin{enumerate}
\item \textbf{Causal update propagation:} Changes to the source must automatically trigger updates to derived locations. This is analogous to channel coding with feedback---the encoder (source) and decoder (derived locations) are coupled in real-time. Without causal propagation, a temporal window exists where source and derived locations diverge (temporary incoherence).

\item \textbf{Provenance observability:} The system must support queries about derivation structure (what is derived from what). This is the encoding-system analog of Slepian-Wolf side information~\cite{slepian1973noiseless}---the decoder has access to structural information enabling verification.
\end{enumerate}

These abstract to arbitrary encoding systems; programming language features (definition-time hooks, introspection) are one instantiation. Distributed databases use triggers and system catalogs; configuration systems use dependency graphs and state queries.

\textbf{Connection to multi-version coding.} Rashmi et al.~\cite{rashmi2015multiversion} prove an ``inevitable storage cost for consistency'' in distributed storage. Our realizability theorem is analogous: systems lacking causal propagation or provenance observability \emph{cannot} achieve DOF = 1---the cost is fundamental, not implementation-specific.

\textbf{Applications across computational systems.} We include a programming-language instantiation and a worked case study as \emph{corollaries} of the abstract theory. These sections exemplify the realizability theorem; the core theorems and their proofs are independent of any specific language or system.

\subsection{Paper Organization and Main Results}\label{overview}

This paper establishes four \emph{core} theorems characterizing optimal encoding under coherence constraints. All results are machine-checked in Lean 4~\cite{demoura2021lean4} (9,351 lines, 541 theorems, 0 \texttt{sorry} placeholders).

\textbf{Section~\ref{sec:foundations}---Encoding Model.} We formalize multi-location encoding systems: facts stored at multiple locations with independence and derivability relations. DOF (Degrees of Freedom) counts independent locations. Coherence means all locations agree. Section~\ref{sec:cap-flp} formalizes encoding-theoretic CAP/FLP analogs inside this model.

\textbf{Section~\ref{sec:ssot}---Optimal Rate.} We prove DOF = 1 is the unique rate guaranteeing coherence (Theorem~\ref{thm:dof-optimal}). The proof constructs incoherent configurations for all DOF $> 1$ and shows DOF = 1 makes disagreement impossible.

\textbf{Section~\ref{sec:requirements}---Realizability.} We derive necessary and sufficient conditions for encoding systems to achieve DOF = 1 via derivation (Theorem~\ref{thm:ssot-iff}). Both causal update propagation and provenance observability are required---these are information-theoretic encoder properties that abstract across domains.

\textbf{Section~\ref{sec:evaluation}---Corollary Instantiation.} We provide a programming-language instantiation of the realizability criteria as a corollary of Theorem~\ref{thm:ssot-iff}; the core proofs remain abstract.

\textbf{Section~\ref{sec:bounds}---Complexity Bounds.} We prove the rate-complexity tradeoff: DOF = 1 achieves $O(1)$ modification cost; DOF $> 1$ requires $\Omega(n)$ (Theorem~\ref{thm:unbounded-gap}). The gap grows without bound.

\textbf{Section~\ref{sec:empirical}---Worked Instantiation.} A case study from a production system (OpenHCS~\cite{openhcs2025}) instantiates the realizability requirements.


\subsection{Core Theorems}\label{sec:core-theorems}

We establish four \emph{core} theorems characterizing optimal encoding under coherence constraints:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Theorem~\ref{thm:oracle-arbitrary} (Resolution Impossibility):} For any incoherent encoding system (DOF $> 1$ with divergent values) and any resolution procedure selecting a value, there exists an equally-present value disagreeing with the selection. No resolution is information-theoretically justified.

  \emph{Proof:} By incoherence, at least two values exist. Any selection leaves another value disagreeing. No side information distinguishes them.

\item
  \textbf{Theorem~\ref{thm:dof-one-coherence} (Optimal Rate):} DOF = 1 guarantees coherence. Exactly one independent encoding makes disagreement impossible.

  \emph{Proof:} All other locations are derived from the single source. Derivation enforces agreement. Single source determines all values.

\item
  \textbf{Theorem~\ref{thm:ssot-iff} (Realizability Requirements):} An encoding system achieves DOF = 1 via derivation if and only if it provides: (a) causal update propagation (source changes automatically trigger derived location updates), and (b) provenance observability (derivation structure is queryable).

  \emph{Proof:} Necessity by constructing incoherent configurations when either is missing. Sufficiency by exhibiting derivation mechanisms achieving DOF = 1. The requirements are information-theoretic encoder properties, not implementation details.

\item
  \textbf{Theorem~\ref{thm:unbounded-gap} (Rate-Complexity Tradeoff):} Modification complexity scales as: DOF = 1 achieves $O(1)$; DOF = $n > 1$ requires $\Omega(n)$. The ratio grows without bound: $\lim_{n \to \infty} \frac{n}{1} = \infty$.

  \emph{Proof:} DOF = 1 updates single source (constant). DOF = $n$ must synchronize $n$ independent locations (linear).
\end{enumerate}

\textbf{Forcing property.} DOF = 1 is the \textbf{unique} rate guaranteeing coherence. DOF = 0 means unencoded; DOF $> 1$ permits incoherence. Given coherence as a requirement, there is no design freedom---the solution is mathematically forced.

\subsection{Scope}\label{sec:scope}

This work characterizes SSOT for \emph{structural facts} (class existence, method signatures, type relationships) within \emph{single-language} systems. The complexity analysis is asymptotic, applying to systems where $n$ grows. External tooling can approximate SSOT behavior but operates outside language semantics.

\textbf{Multi-language systems.} When a system spans multiple languages (e.g., Python backend + TypeScript frontend + protobuf schemas), cross-language SSOT requires external code generation tools. The analysis in this paper characterizes single-language SSOT; multi-language SSOT is noted as future work (Section~\ref{sec:conclusion}).

\subsection{Contributions}\label{sec:contributions}

This paper makes six contributions:

\textbf{1. Epistemic foundations (Section~\ref{sec:epistemic}):}
\begin{itemize}
\tightlist
\item Definition of coherence and incoherence for encoding systems
\item \textbf{Theorem~\ref{thm:oracle-arbitrary} (Oracle Arbitrariness):} Under incoherence, no resolution is principled. The epistemic core.
\item \textbf{Theorem~\ref{thm:dof-one-coherence} (Coherence Forcing):} DOF = 1 guarantees coherence
\item \textbf{Theorem~\ref{thm:dof-gt-one-incoherence}:} DOF $> 1$ permits incoherence
\item \textbf{Corollary~\ref{cor:coherence-forces-ssot}:} Given coherence requirement, DOF = 1 is necessary and sufficient
\end{itemize}

\textbf{2. Software instantiation (Section~\ref{sec:edit-space}):}
\begin{itemize}
\tightlist
\item Mapping: encoding systems $\to$ codebases, facts $\to$ structural specifications
\item Definition of SSOT as DOF = 1 for software
\item Theorem~\ref{thm:ssot-determinate}: SSOT eliminates indeterminacy
\end{itemize}

\textbf{3. Realizability requirements (Section~\ref{sec:requirements}):}
\begin{itemize}
\tightlist
\item Theorem~\ref{thm:causal-necessary}: Causal update propagation is necessary
\item Theorem~\ref{thm:provenance-necessary}: Provenance observability is necessary
\item Theorem~\ref{thm:ssot-iff}: Both together are sufficient
\item Connection to IT: causal propagation $\approx$ channel with feedback; provenance observability $\approx$ Slepian-Wolf side information
\item Connection to WOM codes: structural irreversibility constraint analogous to write-once constraint
\end{itemize}

\textbf{4. Language instantiation (Section~\ref{sec:evaluation}):}
\begin{itemize}
\tightlist
\item Representative instantiation over a mainstream language class
\item Extended instantiation of three MOP-equipped languages (CLOS, Smalltalk, Ruby)
\item Theorem~\ref{thm:three-lang}: Exactly three languages satisfy requirements within the evaluated class
\end{itemize}

\textbf{5. Complexity bounds (Section~\ref{sec:bounds}):}
\begin{itemize}
\tightlist
\item Theorem~\ref{thm:upper-bound}: SSOT achieves $O(1)$ coherence restoration
\item Theorem~\ref{thm:lower-bound}: Non-SSOT requires $\Omega(n)$ modifications
\item Theorem~\ref{thm:unbounded-gap}: The gap is unbounded
\end{itemize}

\textbf{6. Worked instantiation (Section~\ref{sec:empirical}):}
\begin{itemize}
\tightlist
\item Before/after examples from OpenHCS (production Python codebase)
\item PR \#44~\cite{openhcsPR44}: Migration from 47 scattered checks to 1 ABC (DOF 47 $\to$ 1)
\item Concrete instantiation of realizability mechanisms in a production system
\end{itemize}

\textbf{Note on scope.} The programming-language instantiation and worked case study (Sections~\ref{sec:evaluation} and~\ref{sec:empirical}) are corollaries of the realizability theorem. The core information-theoretic results are contained in Sections~\ref{sec:foundations}--\ref{sec:bounds}.


%==============================================================================
