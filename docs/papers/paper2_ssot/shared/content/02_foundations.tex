\section{Formal Foundations}\label{sec:foundations}
%==============================================================================

We formalize the concepts underlying DRY/SSOT using state space theory. The formalization proceeds in four stages: (1) define the space of possible edits, (2) define what a ``fact'' is, (3) define what it means for code to ``encode'' a fact, (4) define the key metric: degrees of freedom.

\subsection{Edit Space and Codebases}\label{sec:edit-space}

\begin{definition}[Codebase]
A \emph{codebase} $C$ is a finite collection of source files, each containing a sequence of syntactic constructs (classes, functions, statements, expressions).
\end{definition}

\begin{definition}[Location]
A \emph{location} $L \in C$ is a syntactically identifiable region of code: a class definition, a function body, a configuration value, a type annotation, etc.
\end{definition}

\begin{definition}[Edit Space]
For a codebase $C$, the \emph{edit space} $E(C)$ is the set of all syntactically valid modifications to $C$. Each edit $\delta \in E(C)$ transforms $C$ into a new codebase $C' = \delta(C)$.
\end{definition}

The edit space is large---exponential in codebase size. But we are not interested in arbitrary edits. We are interested in edits that \emph{change a specific fact}.

\subsection{Facts: Atomic Units of Specification}\label{sec:facts}

\begin{definition}[Fact]\label{def:fact}
A \emph{fact} $F$ is an atomic unit of program specification---a single piece of knowledge that can be independently modified. Facts are the indivisible units of meaning in a specification.
\end{definition}

The granularity of facts is determined by the specification, not the implementation. If two pieces of information must always change together, they constitute a single fact. If they can change independently, they are separate facts.

\noindent\textbf{Examples of facts:}

\begin{center}
\begin{tabular}{lp{8cm}}
\toprule
\textbf{Fact} & \textbf{Description} \\
\midrule
$F_1$: ``threshold = 0.5'' & A configuration value \\
$F_2$: ``\texttt{PNGLoader} handles \texttt{.png}'' & A type-to-handler mapping \\
$F_3$: ``\texttt{validate()} returns \texttt{bool}'' & A method signature \\
$F_4$: ``\texttt{Detector} is a subclass of \texttt{Processor}'' & An inheritance relationship \\
$F_5$: ``\texttt{Config} has field \texttt{name: str}'' & A dataclass field \\
\bottomrule
\end{tabular}
\end{center}

\begin{definition}[Structural Fact]\label{def:structural-fact}
A fact $F$ is \emph{structural} iff it concerns the structure of the type system: class existence, inheritance relationships, method signatures, or attribute definitions. Structural facts are fixed at \emph{definition time}, not runtime.
\end{definition}

The distinction between structural and non-structural facts is crucial. A configuration value (``threshold = 0.5'') can be changed at runtime. A method signature (``\texttt{validate()} returns \texttt{bool}'') is fixed when the class is defined. SSOT for structural facts requires different mechanisms than SSOT for configuration values.

\subsection{Encoding: The Correctness Relationship}\label{sec:encoding}

\begin{definition}[Encodes]\label{def:encodes}
Location $L$ \emph{encodes} fact $F$, written $\text{encodes}(L, F)$, iff correctness requires updating $L$ when $F$ changes.

Formally:
\[
\text{encodes}(L, F) \Longleftrightarrow \forall \delta_F: \neg\text{updated}(L, \delta_F) \rightarrow \text{incorrect}(\delta_F(C))
\]

where $\delta_F$ is an edit targeting fact $F$.
\end{definition}

\textbf{Key insight:} This definition is \textbf{forced} by correctness, not chosen. We do not decide what encodes what---correctness requirements determine it. If failing to update location $L$ when fact $F$ changes produces an incorrect program, then $L$ encodes $F$. This is an objective, observable property.

\begin{example}[Encoding in Practice]\label{ex:encoding}
Consider a type registry:

\begin{verbatim}
# Location L1: Class definition
class PNGLoader(ImageLoader):
    format = "png"

# Location L2: Registry entry
LOADERS = {"png": PNGLoader, "jpg": JPGLoader}

# Location L3: Documentation
# Supported formats: png, jpg
\end{verbatim}

The fact $F$ = ``\texttt{PNGLoader} handles \texttt{png}'' is encoded at:
\begin{itemize}
\tightlist
\item $L_1$: The class definition (primary encoding)
\item $L_2$: The registry dictionary (secondary encoding)
\item $L_3$: The documentation comment (tertiary encoding)
\end{itemize}

If $F$ changes (e.g., to ``\texttt{PNGLoader} handles \texttt{png} and \texttt{apng}''), all three locations must be updated for correctness. The program is incorrect if $L_2$ still says \texttt{\{"png": PNGLoader\}} when the class now handles both formats.
\end{example}

\subsection{Modification Complexity}\label{sec:mod-complexity}

\begin{definition}[Modification Complexity]\label{def:mod-complexity}
\[
M(C, \delta_F) = |\{L \in C : \text{encodes}(L, F)\}|
\]
The number of locations that must be updated when fact $F$ changes.
\end{definition}

Modification complexity is the central metric of this paper. It measures the \emph{cost} of changing a fact. A codebase with $M(C, \delta_F) = 47$ requires 47 edits to correctly implement a change to fact $F$. A codebase with $M(C, \delta_F) = 1$ requires only 1 edit.

\begin{theorem}[Correctness Forcing]\label{thm:correctness-forcing}
$M(C, \delta_F)$ is the \textbf{minimum} number of edits required for correctness. Fewer edits imply an incorrect program.
\end{theorem}

\begin{proof}
Suppose $M(C, \delta_F) = k$, meaning $k$ locations encode $F$. By Definition~\ref{def:encodes}, each encoding location must be updated when $F$ changes. If only $j < k$ locations are updated, then $k - j$ locations still reflect the old value of $F$. These locations create inconsistencies:

\begin{enumerate}
\tightlist
\item The specification says $F$ has value $v'$ (new)
\item Locations $L_1, \ldots, L_j$ reflect $v'$
\item Locations $L_{j+1}, \ldots, L_k$ reflect $v$ (old)
\end{enumerate}

By Definition~\ref{def:encodes}, the program is incorrect. Therefore, all $k$ locations must be updated, and $k$ is the minimum. \qed
\end{proof}

\subsection{Independence and Degrees of Freedom}\label{sec:dof}

Not all encoding locations are created equal. Some are \emph{derived} from others.

\begin{definition}[Independent Locations]\label{def:independent}
Locations $L_1, L_2$ are \emph{independent} for fact $F$ iff they can diverge---updating $L_1$ does not automatically update $L_2$, and vice versa.

Formally: $L_1$ and $L_2$ are independent iff there exists a sequence of edits that makes $L_1$ and $L_2$ encode different values for $F$.
\end{definition}

\begin{definition}[Derived Location]\label{def:derived}
Location $L_{\text{derived}}$ is \emph{derived from} $L_{\text{source}}$ iff updating $L_{\text{source}}$ automatically updates $L_{\text{derived}}$. Derived locations are not independent of their sources.
\end{definition}

\begin{example}[Independent vs. Derived]\label{ex:independence}
Consider two architectures for the type registry:

\textbf{Architecture A (independent locations):}
\begin{verbatim}
# L1: Class definition
class PNGLoader(ImageLoader): ...

# L2: Manual registry (independent of L1)
LOADERS = {"png": PNGLoader}
\end{verbatim}

Here $L_1$ and $L_2$ are independent. A developer can change $L_1$ without updating $L_2$, causing inconsistency.

\textbf{Architecture B (derived location):}
\begin{verbatim}
# L1: Class definition with registration
class PNGLoader(ImageLoader):
    format = "png"

# L2: Derived registry (computed from L1)
LOADERS = {cls.format: cls for cls in ImageLoader.__subclasses__()}
\end{verbatim}

Here $L_2$ is derived from $L_1$. Updating the class definition automatically updates the registry. They cannot diverge.
\end{example}

\begin{definition}[Degrees of Freedom]\label{def:dof}
\[
\text{DOF}(C, F) = |\{L \in C : \text{encodes}(L, F) \land \text{independent}(L)\}|
\]
The number of \emph{independent} locations encoding fact $F$.
\end{definition}

DOF is the key metric. Modification complexity $M$ counts all encoding locations. DOF counts only the independent ones. If all but one encoding location is derived, DOF = 1 even though $M$ may be large.

\begin{theorem}[DOF = Inconsistency Potential]\label{thm:dof-inconsistency}
$\text{DOF}(C, F) = k$ implies $k$ different values for $F$ can coexist in $C$ simultaneously.
\end{theorem}

\begin{proof}
Each independent location can hold a different value. By Definition~\ref{def:independent}, no constraint forces agreement between independent locations. Therefore, $k$ independent locations can hold $k$ distinct values. The program may compile and run, but it encodes inconsistent specifications. \qed
\end{proof}

\begin{corollary}[DOF $>$ 1 Implies Inconsistency Risk]\label{cor:dof-risk}
$\text{DOF}(C, F) > 1$ implies potential inconsistency. The codebase can enter a state where different parts encode different values for the same fact.
\end{corollary}

\subsection{The DOF Lattice}\label{sec:dof-lattice}

DOF values form a lattice with distinct meanings:

\begin{center}
\begin{tabular}{cl}
\toprule
\textbf{DOF} & \textbf{Meaning} \\
\midrule
0 & Fact $F$ is not encoded anywhere (missing specification) \\
1 & Exactly one source of truth (optimal) \\
$k > 1$ & $k$ independent sources (inconsistency possible) \\
\bottomrule
\end{tabular}
\end{center}

\begin{theorem}[DOF = 1 is Optimal]\label{thm:dof-optimal}
For any fact $F$ that must be encoded, $\text{DOF}(C, F) = 1$ is the unique optimal value:
\begin{enumerate}
\tightlist
\item DOF = 0: Fact is not specified (underspecification)
\item DOF = 1: Exactly one source (optimal)
\item DOF $>$ 1: Multiple sources can diverge (overspecification with inconsistency risk)
\end{enumerate}
\end{theorem}

\begin{proof}
\begin{enumerate}
\item DOF = 0 means no location encodes $F$. The program cannot correctly implement $F$ because it has no representation. This is underspecification.
\item DOF = 1 means exactly one independent location encodes $F$. All other encodings (if any) are derived. Updating the single source updates all derived locations. Inconsistency is impossible.
\item DOF $>$ 1 means multiple independent locations encode $F$. By Corollary~\ref{cor:dof-risk}, they can diverge. This is overspecification with inconsistency risk.
\end{enumerate}

Therefore, DOF = 1 is the unique value that avoids both underspecification and inconsistency risk. \qed
\end{proof}

%==============================================================================
