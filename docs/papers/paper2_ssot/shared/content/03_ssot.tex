\section{Single Source of Truth}\label{sec:ssot}
%==============================================================================

Having established the formal foundations, we now define SSOT precisely and prove its optimality.

\subsection{SSOT Definition}\label{sec:ssot-def}

\begin{definition}[Single Source of Truth]\label{def:ssot}
Codebase $C$ satisfies \emph{SSOT} for fact $F$ iff:
\[
|\{L \in C : \text{encodes}(L, F) \land \text{independent}(L)\}| = 1
\]
Equivalently: $\text{DOF}(C, F) = 1$.
\end{definition}

SSOT is the formalization of DRY. Hunt \& Thomas's ``single, unambiguous, authoritative representation'' corresponds precisely to DOF = 1. The representation is:
\begin{itemize}
\tightlist
\item \textbf{Single:} Only one independent encoding exists
\item \textbf{Unambiguous:} All other encodings are derived, hence cannot diverge
\item \textbf{Authoritative:} The single source determines all derived representations
\end{itemize}

\begin{theorem}[SSOT Optimality]\label{thm:ssot-optimal}
If $C$ satisfies SSOT for $F$, then the effective modification complexity is 1: updating the single source updates all derived representations.
\end{theorem}

\begin{proof}
Let $C$ satisfy SSOT for $F$, meaning $\text{DOF}(C, F) = 1$. Let $L_s$ be the single independent encoding location. All other encodings $L_1, \ldots, L_k$ are derived from $L_s$.

When fact $F$ changes:
\begin{enumerate}
\tightlist
\item The developer updates $L_s$ (1 edit)
\item By Definition~\ref{def:derived}, $L_1, \ldots, L_k$ are automatically updated
\item Total manual edits: 1
\end{enumerate}

The program is correct after 1 edit. Therefore, effective modification complexity is 1. \qed
\end{proof}

\begin{theorem}[SSOT Uniqueness]\label{thm:ssot-unique}
SSOT (DOF=1) is the \textbf{unique} minimal representation for structural facts. Any system with DOF $> 1$ contains redundancy and is therefore non-minimal.
\end{theorem}

\begin{proof}
This follows from the general uniqueness theorem for minimal complete representations established in Paper 1 \cite{paper1_typing_discipline}.

Specifically, Paper 1 proves:
\begin{enumerate}
\item \textbf{Minimal sets contain no redundant elements} (Lemma \texttt{minimal\_no\_redundant\_axes}): If a representation is minimal (every element necessary), then it contains zero redundant elements.

\item \textbf{Uniqueness of minimal complete sets} (Theorem \texttt{minimal\_complete\_unique\_orthogonal}): For any domain $D$, all minimal complete representations have equal cardinality.
\end{enumerate}

Applied to SSOT:
\begin{itemize}
\item A representation with DOF=1 has exactly 1 independent source (by definition)
\item A representation with DOF $> 1$ has multiple independent sources encoding the same fact $F$
\item Multiple independent encodings of the same fact constitute redundancy
\item By Paper 1's lemma, redundancy implies non-minimality
\item Therefore, DOF=1 is the unique minimal representation
\end{itemize}

This is not a design choice. It is a mathematical necessity forced by the requirement of minimality. \qed
\end{proof}

\begin{corollary}[Redundancy Impossibility]\label{cor:no-redundancy}
Minimal representations contain zero redundant sources. DOF $> 1 \Rightarrow$ non-minimal.
\end{corollary}

\begin{proof}
Direct application of Paper 1, Lemma \texttt{minimal\_no\_redundant\_axes}. If a system is minimal (removing any element breaks completeness), it cannot contain redundant elements. Multiple independent sources encoding the same structural fact are redundant by definition. \qed
\end{proof}

\subsection{SSOT vs. Modification Complexity}\label{sec:ssot-vs-m}

Note the distinction between $M(C, \delta_F)$ and effective modification complexity:

\begin{itemize}
\tightlist
\item $M(C, \delta_F)$ counts \emph{all} locations that must be updated
\item Effective modification complexity counts only \emph{manual} updates
\end{itemize}

With SSOT, $M$ may be large (many locations encode $F$), but effective complexity is 1 (only the source requires manual update). The derivation mechanism handles the rest.

\begin{example}[SSOT with Large M]\label{ex:ssot-large-m}
Consider a codebase where 50 classes inherit from \texttt{BaseProcessor}:

\begin{verbatim}
class BaseProcessor(ABC):
    @abstractmethod
    def process(self, data: np.ndarray) -> np.ndarray: ...

class Detector(BaseProcessor): ...
class Segmenter(BaseProcessor): ...
# ... 48 more subclasses
\end{verbatim}

The fact $F$ = ``All processors must have a \texttt{process} method'' is encoded in 51 locations:
\begin{itemize}
\tightlist
\item 1 ABC definition
\item 50 concrete implementations
\end{itemize}

Without SSOT: Changing the signature (e.g., adding a parameter) requires 51 edits.

With SSOT: The ABC contract is the single source. Python's ABC mechanism enforces that all subclasses implement \texttt{process}. Changing the ABC updates the contract; the type checker (or runtime) flags non-compliant subclasses. The developer updates each subclass, but the \emph{specification} of what must be updated is derived from the ABC.

Note: SSOT does not eliminate the need to update implementations. It ensures the \emph{specification} of the contract has a single source. The implementations are separate facts.
\end{example}

\subsection{Derivation Mechanisms}\label{sec:derivation}

\begin{definition}[Derivation]\label{def:derivation}
Location $L_{\text{derived}}$ is \emph{derived from} $L_{\text{source}}$ for fact $F$ iff:
\[
\text{updated}(L_{\text{source}}) \rightarrow \text{automatically\_updated}(L_{\text{derived}})
\]
No manual intervention is required. The update propagates automatically.
\end{definition}

Derivation can occur at different times:

\begin{center}
\begin{tabular}{lp{7cm}}
\toprule
\textbf{Derivation Time} & \textbf{Examples} \\
\midrule
Compile time & C++ templates, Rust macros, code generation \\
Definition time & Python metaclasses, \texttt{\_\_init\_subclass\_\_}, class decorators \\
Runtime & Lazy computation, memoization \\
\bottomrule
\end{tabular}
\end{center}

For \emph{structural facts}, derivation must occur at \emph{definition time}. This is because structural facts (class existence, method signatures) are fixed when the class is defined. Compile-time derivation is too early (source code hasn't been parsed). Runtime derivation is too late (structure is already fixed).

\begin{theorem}[Derivation Excludes from DOF]\label{thm:derivation-excludes}
If $L_{\text{derived}}$ is derived from $L_{\text{source}}$, then $L_{\text{derived}}$ does not contribute to DOF.
\end{theorem}

\begin{proof}
By Definition~\ref{def:independent}, locations are independent iff they can diverge. By Definition~\ref{def:derivation}, derived locations are automatically updated when the source changes. They cannot diverge.

Formally: Let $L_d$ be derived from $L_s$. Suppose $L_s$ encodes value $v$ for fact $F$. Then $L_d$ encodes $f(v)$ for some function $f$ (possibly the identity). When $L_s$ changes to $v'$, $L_d$ automatically changes to $f(v')$. There is no state where $L_s = v'$ and $L_d = f(v)$. They cannot diverge.

Therefore, $L_d$ is not independent of $L_s$, and does not contribute to DOF. \qed
\end{proof}

\begin{corollary}[Metaprogramming Achieves SSOT]\label{cor:metaprogramming}
If all encodings of $F$ except one are derived from that one, then $\text{DOF}(C, F) = 1$.
\end{corollary}

\begin{proof}
Let $L_s$ be the non-derived encoding. All other encodings $L_1, \ldots, L_k$ are derived from $L_s$. By Theorem~\ref{thm:derivation-excludes}, none of $L_1, \ldots, L_k$ contribute to DOF. Only $L_s$ contributes. Therefore, $\text{DOF}(C, F) = 1$. \qed
\end{proof}

\subsection{SSOT Patterns in Python}\label{sec:ssot-patterns}

Python provides several mechanisms for achieving SSOT:

\textbf{Pattern 1: Subclass Registration via \texttt{\_\_init\_subclass\_\_}}

\begin{verbatim}
class Registry:
    _registry = {}

    def __init_subclass__(cls, **kwargs):
        super().__init_subclass__(**kwargs)
        Registry._registry[cls.__name__] = cls

class Handler(Registry):
    pass

class PNGHandler(Handler):  # Automatically registered
    pass
\end{verbatim}

The fact ``\texttt{PNGHandler} is in the registry'' is encoded in two locations:
\begin{enumerate}
\tightlist
\item The class definition (source)
\item The registry dictionary (derived via \texttt{\_\_init\_subclass\_\_})
\end{enumerate}

DOF = 1 because the registry entry is derived.

\textbf{Pattern 2: Subclass Enumeration via \texttt{\_\_subclasses\_\_()}}

\begin{verbatim}
class Processor(ABC):
    @classmethod
    def all_processors(cls):
        return cls.__subclasses__()

class Detector(Processor): pass
class Segmenter(Processor): pass

# Usage: Processor.all_processors() -> [Detector, Segmenter]
\end{verbatim}

The fact ``which classes are processors'' is encoded:
\begin{enumerate}
\tightlist
\item In each class definition (via inheritance)
\item In the \texttt{\_\_subclasses\_\_()} result (derived)
\end{enumerate}

DOF = 1 because \texttt{\_\_subclasses\_\_()} is computed from the class definitions.

\textbf{Pattern 3: ABC Contracts}

\begin{verbatim}
class ImageLoader(ABC):
    @abstractmethod
    def load(self, path: str) -> np.ndarray: ...

    @abstractmethod
    def supported_extensions(self) -> List[str]: ...
\end{verbatim}

The fact ``loaders must implement \texttt{load} and \texttt{supported\_extensions}'' is encoded once in the ABC. All subclasses must comply. The ABC is the single source; compliance is enforced.

%==============================================================================
