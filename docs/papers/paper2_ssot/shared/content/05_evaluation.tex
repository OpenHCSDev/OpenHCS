\section{Language Evaluation}\label{sec:evaluation}
%==============================================================================

We now evaluate mainstream programming languages against the SSOT requirements established in Section~\ref{sec:requirements}. This evaluation is exhaustive: we check every mainstream language against formally-defined criteria.

\subsection{Evaluation Criteria}\label{sec:criteria}

We evaluate languages on four criteria, derived from the SSOT requirements:

\begin{center}
\begin{tabular}{llp{6cm}}
\toprule
\textbf{Criterion} & \textbf{Abbrev} & \textbf{Test} \\
\midrule
Definition-time hooks & DEF & Can arbitrary code execute when a class is defined? \\
Introspectable results & INTRO & Can the program query what was derived? \\
Structural modification & STRUCT & Can hooks modify the structure being defined? \\
Hierarchy queries & HIER & Can the program enumerate subclasses/implementers? \\
\bottomrule
\end{tabular}
\end{center}

\textbf{DEF} and \textbf{INTRO} are the two requirements from Theorem~\ref{thm:ssot-iff}. \textbf{STRUCT} and \textbf{HIER} are refinements that distinguish partial from complete support.

\textbf{Scoring (Precise Definitions):}
\begin{itemize}
\tightlist
\item \checkmark = Full support: The feature is available, usable for SSOT, and does not require external tools
\item $\times$ = No support: The feature is absent or fundamentally cannot be used for SSOT
\end{itemize}

\textbf{Note:} For mainstream languages, we do not use ``Partial'' ratings---a language either has the capability or it does not. For non-mainstream languages in Section~\ref{sec:non-mainstream}, we note partial support where relevant since these languages are not our primary focus. For INTRO, we require \emph{subclass enumeration}---the ability to answer ``what classes inherit from X?'' at runtime. Java's \texttt{getMethods()} does not satisfy this because it cannot enumerate subclasses without classpath scanning via external libraries.

\subsection{Mainstream Language Definition}\label{sec:mainstream-def}

\begin{definition}[Mainstream Language]\label{def:mainstream}
A language is \emph{mainstream} iff it appears in the top 20 of at least two of the following indices consistently over 5+ years:
\begin{enumerate}
\tightlist
\item TIOBE Index (monthly language popularity)
\item Stack Overflow Developer Survey (annual)
\item GitHub Octoverse (annual repository statistics)
\item RedMonk Programming Language Rankings (quarterly)
\end{enumerate}
\end{definition}

This definition excludes niche languages (Haskell, Erlang, Clojure) while including all languages a typical software organization might consider. The 5-year consistency requirement excludes flash-in-the-pan languages.

\subsection{Mainstream Language Evaluation}\label{sec:mainstream-eval}

\begin{center}
\begin{tabular}{lccccc}
\toprule
\textbf{Language} & \textbf{DEF} & \textbf{INTRO} & \textbf{STRUCT} & \textbf{HIER} & \textbf{SSOT?} \\
\midrule
Python & \checkmark & \checkmark & \checkmark & \checkmark & \textbf{YES} \\
JavaScript & $\times$ & $\times$ & $\times$ & $\times$ & NO \\
Java & $\times$ & $\times$ & $\times$ & $\times$ & NO \\
C++ & $\times$ & $\times$ & $\times$ & $\times$ & NO \\
C\# & $\times$ & $\times$ & $\times$ & $\times$ & NO \\
TypeScript & $\times$ & $\times$ & $\times$ & $\times$ & NO \\
Go & $\times$ & $\times$ & $\times$ & $\times$ & NO \\
Rust & $\times$ & $\times$ & $\times$ & $\times$ & NO \\
Kotlin & $\times$ & $\times$ & $\times$ & $\times$ & NO \\
Swift & $\times$ & $\times$ & $\times$ & $\times$ & NO \\
\bottomrule
\end{tabular}
\end{center}

\subsubsection{Python: Full SSOT Support}

Python provides all four capabilities:

\textbf{DEF (Definition-time hooks):}
\begin{itemize}
\tightlist
\item \texttt{\_\_init\_subclass\_\_}: Executes when a subclass is defined
\item Metaclasses: \texttt{\_\_new\_\_} and \texttt{\_\_init\_\_} execute at class creation
\item Class decorators: Execute immediately after class body
\end{itemize}

\textbf{INTRO (Introspection):}
\begin{itemize}
\tightlist
\item \texttt{\_\_subclasses\_\_()}: Returns list of direct subclasses
\item \texttt{\_\_mro\_\_}: Returns method resolution order
\item \texttt{type()}, \texttt{isinstance()}, \texttt{issubclass()}: Type queries
\item \texttt{dir()}, \texttt{vars()}, \texttt{getattr()}: Attribute introspection
\end{itemize}

\textbf{STRUCT (Structural modification):}
\begin{itemize}
\tightlist
\item Metaclasses can add/remove/modify class attributes
\item \texttt{\_\_init\_subclass\_\_} can modify the subclass being defined
\item Decorators can return a different class entirely
\end{itemize}

\textbf{HIER (Hierarchy queries):}
\begin{itemize}
\tightlist
\item \texttt{\_\_subclasses\_\_()}: Enumerate subclasses
\item \texttt{\_\_bases\_\_}: Query parent classes
\item \texttt{\_\_mro\_\_}: Full inheritance chain
\end{itemize}

\subsubsection{JavaScript: No SSOT Support}

JavaScript lacks definition-time hooks:

\textbf{DEF:} $\times$. No code executes when a class is defined. The \texttt{class} syntax is declarative. Decorators (Stage 3 proposal) are not yet standard and have limited capabilities.

\textbf{INTRO:} $\times$. \texttt{Object.getPrototypeOf()}, \texttt{instanceof} exist but \emph{cannot enumerate subclasses}. No equivalent to \texttt{\_\_subclasses\_\_()}.

\textbf{STRUCT:} $\times$. Cannot modify class structure at definition time.

\textbf{HIER:} $\times$. Cannot enumerate subclasses. No equivalent to \texttt{\_\_subclasses\_\_()}.

\subsubsection{Java: No SSOT Support}

Java's annotations are metadata, not executable hooks:

\textbf{DEF:} $\times$. Annotations are processed by external tools (annotation processors), not by the JVM at class loading. The class is already fully defined when annotation processing occurs.

\textbf{INTRO:} $\times$. \texttt{Class.getMethods()}, \texttt{Class.getInterfaces()}, \texttt{Class.getSuperclass()} exist but \emph{cannot enumerate subclasses}. The JVM does not track subclass relationships. External libraries (Reflections, ClassGraph) provide this via classpath scanning---but that is external tooling, not a language feature.

\textbf{STRUCT:} $\times$. Cannot modify class structure at runtime. Bytecode manipulation (ASM, ByteBuddy) is external tooling, not language-level support.

\textbf{HIER:} $\times$. Cannot enumerate subclasses without external libraries (Reflections, ClassGraph).

\textbf{Why annotation processors don't count:}
\begin{enumerate}
\tightlist
\item They run at compile time, not definition time---the class being processed is already fixed
\item They cannot modify the class being defined; they generate \emph{new} classes
\item Generated classes are separate compilation units, not derived facts within the source
\item Results are not introspectable at runtime---you cannot query ``was this method generated?''
\end{enumerate}

\textbf{Why Lombok doesn't count:} Lombok approximates SSOT but violates it: the Lombok configuration becomes a second source of truth. Changes require updating both source and Lombok annotations. The tool can fail, be misconfigured, or be bypassed.

\subsubsection{C++: No SSOT Support}

C++ templates are compile-time, not definition-time:

\textbf{DEF:} $\times$. Templates expand at compile time but do not execute arbitrary code. \texttt{constexpr} functions are evaluated at compile time but cannot hook into class definition.

\textbf{INTRO:} $\times$. No runtime type introspection. RTTI (\texttt{typeid}, \texttt{dynamic\_cast}) provides minimal information. Cannot enumerate template instantiations.

\textbf{STRUCT:} $\times$. Cannot modify class structure after definition.

\textbf{HIER:} $\times$. Cannot enumerate subclasses. No runtime class registry.

\subsubsection{Go: No SSOT Support}

Go's design philosophy explicitly rejects metaprogramming:

\textbf{DEF:} $\times$. No hook mechanism. Types are defined declaratively. No code executes at type definition.

\textbf{INTRO:} $\times$. \texttt{reflect} package provides limited introspection but cannot enumerate types implementing an interface.

\textbf{STRUCT:} $\times$. Cannot modify type structure.

\textbf{HIER:} $\times$. Interfaces are implicit (structural typing). Cannot enumerate implementers.

\subsubsection{Rust: No SSOT Support}

Rust's procedural macros are compile-time and opaque:

\textbf{DEF:} $\times$. Procedural macros execute at compile time, not definition time. The generated code is not introspectable at runtime.

\textbf{INTRO:} $\times$. No runtime type introspection. \texttt{std::any::TypeId} provides minimal information.

\textbf{STRUCT:} $\times$. Cannot modify type structure at runtime.

\textbf{HIER:} $\times$. Cannot enumerate trait implementers.

\textbf{Why procedural macros don't count:}
\begin{enumerate}
\tightlist
\item They execute at compile time, not definition time---the generated code is baked into the binary
\item \texttt{\#[derive(Debug)]} generates code, but you cannot query ``does this type derive Debug?'' at runtime
\item Verification requires source inspection or documentation, not runtime query
\item No equivalent to Python's \texttt{\_\_subclasses\_\_()}---you cannot enumerate trait implementers
\end{enumerate}

\textbf{Consequence:} Rust achieves \emph{compile-time} SSOT but not \emph{runtime} SSOT. For applications requiring runtime reflection (ORMs, serialization frameworks, dependency injection), Rust requires manual synchronization or external codegen tools.

\begin{theorem}[Python Uniqueness in Mainstream]\label{thm:python-unique}
Among mainstream languages, Python is the only language satisfying all SSOT requirements.
\end{theorem}

\begin{proof}
By exhaustive evaluation. We checked all 10 mainstream languages against the four criteria. Only Python satisfies all four. The evaluation is complete---no mainstream language is omitted. \qed
\end{proof}

\subsection{Non-Mainstream Languages}\label{sec:non-mainstream}

Three non-mainstream languages also satisfy SSOT requirements:

\begin{center}
\begin{tabular}{lccccc}
\toprule
\textbf{Language} & \textbf{DEF} & \textbf{INTRO} & \textbf{STRUCT} & \textbf{HIER} & \textbf{SSOT?} \\
\midrule
Common Lisp (CLOS) & \checkmark & \checkmark & \checkmark & \checkmark & \textbf{YES} \\
Smalltalk & \checkmark & \checkmark & \checkmark & \checkmark & \textbf{YES} \\
Ruby & \checkmark & \checkmark & Partial & \checkmark & Partial \\
\bottomrule
\end{tabular}
\end{center}

\subsubsection{Common Lisp (CLOS)}

CLOS (Common Lisp Object System) provides the most powerful metaobject protocol:

\textbf{DEF:} \checkmark. The MOP (Metaobject Protocol) allows arbitrary code execution at class definition via \texttt{:metaclass} and method combinations.

\textbf{INTRO:} \checkmark. \texttt{class-direct-subclasses}, \texttt{class-precedence-list}, \texttt{class-slots} provide complete introspection.

\textbf{STRUCT:} \checkmark. MOP allows complete structural modification.

\textbf{HIER:} \checkmark. \texttt{class-direct-subclasses} enumerates subclasses.

CLOS is arguably more powerful than Python for metaprogramming. However, it is not mainstream by our definition.

\subsubsection{Smalltalk}

Smalltalk pioneered many of these concepts:

\textbf{DEF:} \checkmark. Classes are objects. Creating a class sends messages that can be intercepted.

\textbf{INTRO:} \checkmark. \texttt{subclasses}, \texttt{allSubclasses}, \texttt{superclass} provide complete introspection.

\textbf{STRUCT:} \checkmark. Classes can be modified at any time.

\textbf{HIER:} \checkmark. \texttt{subclasses} enumerates subclasses.

\subsubsection{Ruby}

Ruby provides hooks but with limitations:

\textbf{DEF:} \checkmark. \texttt{inherited}, \texttt{included}, \texttt{extended} hooks execute at definition time.

\textbf{INTRO:} \checkmark. \texttt{subclasses}, \texttt{ancestors}, \texttt{instance\_methods} provide introspection.

\textbf{STRUCT:} Partial. Can add methods but cannot easily modify class structure during definition.

\textbf{HIER:} \checkmark. \texttt{subclasses} enumerates subclasses.

Ruby is close to full SSOT support but the structural modification limitations prevent complete SSOT for some use cases.

\begin{theorem}[Three-Language Theorem]\label{thm:three-lang}
Exactly three languages in common use satisfy complete SSOT requirements: Python, Common Lisp (CLOS), and Smalltalk.
\end{theorem}

\begin{proof}
By exhaustive evaluation of mainstream and notable non-mainstream languages. Python, CLOS, and Smalltalk satisfy all four criteria. Ruby satisfies three of four (partial STRUCT). All other evaluated languages fail at least two criteria. \qed
\end{proof}

\subsection{Implications for Language Selection}\label{sec:implications}

The evaluation has practical implications:

\textbf{1. If SSOT for structural facts is required:}
\begin{itemize}
\tightlist
\item Python is the only mainstream option
\item CLOS and Smalltalk are alternatives if mainstream status is not required
\item Ruby is a partial option with workarounds needed
\end{itemize}

\textbf{2. If using a non-SSOT language:}
\begin{itemize}
\tightlist
\item External tooling (code generators, linters) can help
\item But tooling is not equivalent to language-level support
\item Tooling cannot be verified at runtime
\item Tooling adds build complexity
\end{itemize}

\textbf{3. For language designers:}
\begin{itemize}
\tightlist
\item Definition-time hooks and introspection should be considered if DRY is a design goal
\item These features have costs (complexity, performance) that must be weighed
\item The absence of these features is a deliberate design choice with consequences
\end{itemize}

%==============================================================================
