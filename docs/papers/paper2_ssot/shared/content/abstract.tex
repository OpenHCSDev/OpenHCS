\begin{abstract}
\textbf{Theorem.} For structural facts in object-oriented languages, the minimal complete representation has DOF = 1 (Single Source of Truth). This representation is unique and is achievable if and only if a language provides definition-time hooks AND introspectable derivation.

We prove that most mainstream programming languages (Java, C++, C\#, JavaScript, Go, Rust, TypeScript, Kotlin, Swift) are \textbf{fundamentally incomplete} for minimal structural representations. Among evaluated mainstream languages, only Python satisfies both necessary and sufficient requirements. This incompleteness is information-theoretic: the language semantics lack the required computational machinery.

\textbf{Four Core Theorems:}

\begin{enumerate}
\item \textbf{SSOT Requirements (Necessity and Sufficiency, Theorem~\ref{thm:ssot-iff}):} A language enables Single Source of Truth for structural facts if and only if it provides (1) definition-time hooks AND (2) introspectable derivation results. These requirements are \textbf{logically forced} by the definition of SSOT, not empirically observed.

\item \textbf{SSOT Uniqueness (Theorem~\ref{thm:ssot-unique}):} SSOT (DOF=1) is the \textbf{unique} minimal representation for structural facts. Any system with DOF $> 1$ contains redundancy and is therefore non-minimal. There is no alternative minimal representation. This follows from the general uniqueness theorem for minimal complete axis sets (Paper 1).

\item \textbf{Decision Procedure (Theorem~\ref{thm:python-unique}):} We provide a complete evaluation framework. Among mainstream languages (top-10 TIOBE), Python is the only language satisfying both derived requirements. The framework enables evaluation of ANY language.

\item \textbf{Unbounded Complexity Gap (Theorem~\ref{thm:unbounded-gap}):} The ratio of modification complexity between SSOT-incomplete and SSOT-complete languages is unbounded: $O(1)$ vs $\Omega(n)$ where $n$ is the number of use sites.
\end{enumerate}

These theorems rest on:
\begin{itemize}
\item Theorem~\ref{thm:ssot-iff}: IFF proof (requirements are necessary AND sufficient)
\item Theorem~\ref{thm:ssot-unique}: Uniqueness proof (DOF=1 is the unique minimal representation, cf.\ Paper 1)
\item Theorem~\ref{thm:python-unique}: Exhaustive evaluation (all mainstream languages checked)
\item Theorem~\ref{thm:unbounded-gap}: Asymptotic analysis ($\lim_{n\to\infty} n/1 = \infty$)
\end{itemize}

Additional contributions:
\begin{itemize}
\item \textbf{Definition~\ref{def:dof} (Modification Complexity):} Formalization of edit cost as DOF in state space
\item \textbf{Redundancy Impossibility (Corollary~\ref{cor:no-redundancy}):} Minimal representations contain zero redundant sources. DOF $> 1 \Rightarrow$ non-minimal. This is not a design guideline. It is a mathematical necessity (cf.\ Paper 1, Lemma~\texttt{minimal\_no\_redundant\_axes}).
\item \textbf{Language Evaluation Framework (Theorem~\ref{thm:three-lang}):} Complete evaluation of 13 languages validates requirement completeness. Among evaluated languages, Python, Common Lisp (CLOS), and Smalltalk satisfy both requirements.
\end{itemize}

\textbf{Corollary (Mathematical Necessity):} Theorem~\ref{thm:ssot-unique} establishes that the set of minimal representations has cardinality 1: $|\{r : \text{minimal}(r)\}| = 1$. This makes DRY mathematically necessary for minimality, not a design guideline. Any system with DOF $> 1$ is provably non-minimal. Claiming ``SSOT is one valid approach among alternatives'' while accepting uniqueness instantiates $P \land \neg P$: uniqueness entails $\neg\exists$ alternatives with equal minimality; preference presupposes $\exists$ such alternatives. The mathematics forces the solution.

All theorems machine-checked in Lean 4 (1,753 lines across 13 files, 0 \texttt{sorry} placeholders). Practical demonstration via verifiable before/after code examples from OpenHCS~\cite{openhcs2025} (45K LoC Python), including PR \#44~\cite{openhcsPR44}: migration from 47 \texttt{hasattr()} checks to 1 ABC (DOF 47 $\to$ 1).

\textbf{Keywords:} DRY principle, Single Source of Truth, language design, metaprogramming, formal methods, modification complexity
\end{abstract}


