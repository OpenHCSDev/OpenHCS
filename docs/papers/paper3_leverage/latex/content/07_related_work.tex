\section{Related Work}\label{related-work}

\subsection{Software Architecture Metrics}

\textbf{Coupling and Cohesion \cite{stevens1974structured}:} Introduced coupling (inter-module dependencies) and cohesion (intra-module relatedness). Recommend high cohesion, low coupling.

\textbf{Difference:} Our framework is capability-aware. High cohesion correlates with high leverage (focused capabilities per module), but we formalize the connection to error probability.

\textbf{Cyclomatic Complexity \cite{mccabe1976complexity}:} Counts decision points in code. Higher values are commonly used as a risk indicator, though empirical studies on defect correlation show mixed results.

\textbf{Difference:} Complexity measures local control flow; leverage measures global architectural DOF. Orthogonal concerns.

\subsection{Design Patterns}

\textbf{Gang of Four \cite{gamma1994design}:} Catalogued 23 design patterns (Singleton, Factory, Observer, etc.). Patterns codify best practices but lack formal justification.

\textbf{Connection:} Many patterns maximize leverage:
\begin{itemize}
\item \textbf{Factory Pattern:} Centralizes object creation (DOF $= 1$ for creation logic)
\item \textbf{Strategy Pattern:} Encapsulates algorithms (DOF $= 1$ per strategy family)
\item \textbf{Template Method:} Defines algorithm skeleton (DOF $= 1$ for structure)
\end{itemize}

Our framework explains \emph{why} these patterns work: they maximize leverage.

\subsection{Technical Debt}

\textbf{Cunningham \cite{cunningham1992wycash}:} Introduced technical debt metaphor. Poor design creates ``debt'' that must be ``repaid'' later.

\textbf{Connection:} Low leverage = high technical debt. Scattered DOF (non-SSOT, denormalized schemas, specific endpoints) create debt. High leverage architectures minimize debt.

\subsection{Formal Methods in Software Architecture}

\textbf{Architecture Description Languages (ADLs):} Wright \cite{allen1997formal}, ACME \cite{garlan1997acme}, Aesop \cite{garlan1994exploiting}. Formalize architecture structure but not decision-making. See also Shaw and Garlan \cite{shaw1996software}.

\textbf{Difference:} ADLs describe architectures; our framework prescribes optimal architectures via leverage maximization.

\textbf{ATAM and CBAM:} Architecture Tradeoff Analysis Method \cite{kazman2000atam} and Cost Benefit Analysis Method \cite{bachmann2000cbam}. Evaluate architectures against quality attributes (performance, modifiability, security). See also Bass et al. \cite{bass2012software}.

\textbf{Difference:} ATAM is qualitative; our framework provides quantitative optimization criterion (maximize $L$).

\subsection{Software Metrics Research}

\textbf{Chidamber-Kemerer Metrics \cite{chidamber1994metrics}:} Object-oriented metrics (WMC, DIT, NOC, CBO, RFC, LCOM). Empirical validation studies \cite{basili1996comparing} found these metrics correlate with external quality attributes.

\textbf{Connection:} Metrics like CBO (Coupling Between Objects) and LCOM (Lack of Cohesion) correlate with DOF. High CBO $\implies$ high DOF. Our framework provides theoretical foundation.

\subsection{Metaprogramming and Reflection}

\textbf{Reflection \cite{maes1987concepts}:} Languages with reflection enable introspection and intercession. Essential for metaprogramming.

\textbf{Connection:} Reflection enables high leverage (SSOT). Our prior work showed Python's definition-time hooks + introspection uniquely enable SSOT for structural facts.

\textbf{Metaclasses \cite{bobrow1986commonloops, kiczales1991amop}:} Early metaobject and metaclass machinery formalized in CommonLoops; the Metaobject Protocol codified in Kiczales et al.'s AMOP. Enable metaprogramming patterns.

\textbf{Application:} Metaclasses are high-leverage mechanism (DOF $= 1$ for class structure, unlimited derivations).

