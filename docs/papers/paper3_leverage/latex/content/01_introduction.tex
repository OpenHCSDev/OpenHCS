\section{Introduction}\label{introduction}

\textbf{Theorem (Main Result).} There exists a computable function $f: \text{Requirements} \to \text{Architecture}$ such that $f(R)$ minimizes expected error probability among all architectures satisfying $R$.

\textbf{Proof sketch.} Define leverage $L(A) = |\text{Capabilities}(A)|/\text{DOF}(A)$. We prove:
\begin{enumerate}
\item Architecture with $n$ DOF is isomorphic to series system with $n$ components (Theorem~\ref{thm:dof-reliability})
\item Series system error probability: $P_{\text{error}}(n) = 1-(1-p)^n$ (standard reliability theory)
\item For $\text{Capabilities}(A_1) = \text{Capabilities}(A_2)$: $L(A_1) > L(A_2) \iff P_{\text{error}}(A_1) < P_{\text{error}}(A_2)$ (Theorem~\ref{thm:leverage-error})
\item Therefore: $f(R) = \arg\max_{A: \text{Cap}(A) \supseteq R} L(A)$ (Theorem~\ref{thm:optimal})
\end{enumerate}

This establishes decidability of architectural optimization for the error minimization objective.

\subsection{Definitions}

\textbf{Definition (Informal):} \emph{Leverage} is the ratio of capabilities to degrees of freedom:
\[
L = \frac{|\text{Capabilities}|}{\text{DOF}}
\]

\textbf{Degrees of Freedom (DOF):} Independent state variables in the architecture. Each DOF represents a location that can be modified independently:
\begin{itemize}
\item $n$ microservices $\to$ DOF $= n$ (each service is independently modifiable)
\item Code copied to $n$ locations $\to$ DOF $= n$ (each copy is independent)
\item Single source with $n$ derivations $\to$ DOF $= 1$ (only source is independent)
\item $k$ API endpoints $\to$ DOF $= k$ (each endpoint independently defined)
\end{itemize}

\textbf{Capabilities:} Requirements the architecture satisfies (e.g., ``support horizontal scaling,'' ``provide type provenance,'' ``enable independent deployment'').

\textbf{Interpretation:} High leverage means gaining many capabilities from few DOF. Low leverage means paying many DOF for few capabilities.

\subsection{DOF-Reliability Isomorphism}

\begin{theorem}[Structure Preservation]\label{thm:dof-reliability}
Define $\phi: \text{Architecture} \to \text{SeriesSystem}$ by $\phi(A) = (\text{DOF}(A), p)$ where $p$ is per-component error rate. Then:
\begin{enumerate}
\item $\phi$ is injective on architectures with equal capabilities
\item $\phi$ preserves ordering: $\text{DOF}(A_1) < \text{DOF}(A_2) \iff P_{\text{error}}(\phi(A_1)) < P_{\text{error}}(\phi(A_2))$
\item $\phi$ preserves composition: $\phi(A_1 \oplus A_2) = \phi(A_1) + \phi(A_2)$ (series connection)
\end{enumerate}
where $P_{\text{error}}(n, p) = 1 - (1-p)^n$ (standard reliability theory~\cite{patterson2013computer}).
\end{theorem}

\begin{theorem}[Linear Approximation]\label{thm:approx-bound}
For $p \in (0, 0.05)$ and $n < 100$:
\[
\left|P_{\text{error}}(n, p) - np\right| < 0.025n^2p^2
\]
The linear model $P_{\text{error}}(n, p) \approx np$ preserves all pairwise orderings in this regime.
\end{theorem}

\begin{proof}
Taylor expansion: $(1-p)^n = 1 - np + \binom{n}{2}p^2 - \cdots$. For $p < 0.05$, higher-order terms $< 0.025n^2p^2$. Ordering preservation: if $n_1 < n_2$, then $n_1p < n_2p$ (strict monotonicity).
\end{proof}

\subsection{Leverage Gap}

\begin{theorem}[Modification Complexity]\label{thm:leverage-gap}
For architectures $A_1, A_2$ with $\text{Capabilities}(A_1) = \text{Capabilities}(A_2)$:
\[
\mathbb{E}[\text{Modifications}(A_i)] = \text{DOF}(A_i) \cdot \Pr[\text{fact } F \text{ changes}]
\]
Therefore:
\[
\frac{\mathbb{E}[\text{Modifications}(A_2)]}{\mathbb{E}[\text{Modifications}(A_1)]} = \frac{\text{DOF}(A_2)}{\text{DOF}(A_1)}
\]
\end{theorem}

\begin{proof}
Each DOF is an independent modification point. When fact $F$ changes, each location encoding $F$ requires update. Expected modifications = (number of locations) $\times$ (probability of change).
\end{proof}

\subsection{Building on Prior Results}

This paper does not \emph{subsume} Papers 1 and 2---it \emph{builds on} their epistemic foundations to provide an optimization criterion.

\textbf{Dependency chain:}
\begin{enumerate}
\item \textbf{Paper 1} proves axis orthogonality $\to$ enables error independence (Theorem~\ref{thm:error-independence})
\item \textbf{Paper 2} proves DOF = 1 guarantees coherence $\to$ establishes the coherence constraint
\item \textbf{This paper} provides the optimization criterion \emph{within} the coherence constraint
\end{enumerate}

\begin{theorem}[Paper 2 Integration]\label{thm:paper2-instance}
Paper 2's SSOT theorem is the coherence foundation. This paper adds: given DOF = 1 per fact (coherence), how do we compare architectures? Answer: by leverage.
\end{theorem}

\begin{proof}
Paper 2 proves: $\text{DOF} > 1$ for a fact $F$ implies oracles can diverge (incoherence). Therefore coherent architecture requires $\text{DOF}(F) = 1$ for each fact $F$. Given this constraint, architectures differ in how many capabilities they derive from coherent representation. This ratio is leverage.
\end{proof}

\begin{theorem}[Paper 1 Integration]\label{thm:paper1-instance}
Paper 1's axis orthogonality theorem enables error independence. Nominal typing achieves higher leverage than duck typing because it provides 4 additional capabilities (provenance, identity, enumeration, conflict resolution) without increasing DOF.
\end{theorem}

\begin{proof}
By Paper 1, axes are orthogonal, so errors are independent (Theorem~\ref{thm:error-independence}). Nominal typing adds 4 B-dependent capabilities impossible with duck typing. DOF is comparable (both are type systems with similar annotation burden). Therefore $L_{\text{nominal}} = (c+4)/d > c/d = L_{\text{duck}}$.
\end{proof}

\subsection{Organization}

Section~\ref{foundations} defines Architecture, DOF, Capabilities, and Leverage. Section~\ref{probability-model} derives the error model from Paper 1's orthogonality and Paper 2's coherence theorems. Section~\ref{main-theorems} proves decidability and optimality. Section~\ref{instances} demonstrates integration with Papers 1 and 2. Section~\ref{appendix-lean} describes Lean mechanization.

\subsection{Scope and Limitations}

\textbf{What this paper provides:}
\begin{itemize}
\item Formal framework for comparing architectural alternatives
\item Provable connection between leverage and error probability
\item Decision procedure: maximize leverage subject to coherence constraint
\item Demonstration via before/after examples from production code
\end{itemize}

\textbf{Scope:}
Leverage characterizes the capability-to-DOF ratio. Performance, security, and other dimensions remain orthogonal concerns. The framework applies when requirements permit multiple architectural choices with different DOF. Error independence is \emph{derived} from Paper 1's axis orthogonality theorem, not assumed.

\subsection{Roadmap}

Section 2 provides formal foundations (definitions). Section 3 derives the probability model from Papers 1 and 2. Section 4 proves main theorems. Section 5 presents instances (SSOT, typing, microservices, APIs, configuration, databases). Section 6 demonstrates practical application via before/after examples. Section 7 surveys related work. Section 8 concludes.


