\section{Foundations}\label{foundations}

We formalize the core concepts: architecture state spaces, degrees of freedom, capabilities, and leverage.

\subsection{Architecture State Space}

\begin{definition}[Architecture]\label{def:architecture}
An \emph{architecture} is a tuple $A = (C, S, T, R)$ where:
\begin{itemize}
\item $C$ is a finite set of \emph{components} (modules, services, endpoints, etc.)
\item $S = \prod_{c \in C} S_c$ is the \emph{state space} (product of component state spaces)
\item $T : S \to \mathcal{P}(S)$ defines valid \emph{transitions} (state changes)
\item $R$ is a set of \emph{requirements} the architecture must satisfy
\end{itemize}
\end{definition}

\textbf{Intuition:} An architecture consists of components, each with a state space. The total state space is the product of component spaces. Transitions define how the system can evolve.

\begin{example}[Microservices Architecture]
\begin{itemize}
\item $C = \{\text{UserService}, \text{OrderService}, \text{PaymentService}\}$
\item $S_{\text{UserService}} = \text{UserDB} \times \text{Endpoints} \times \text{Config}$
\item Similar for other services
\item $S = S_{\text{UserService}} \times S_{\text{OrderService}} \times S_{\text{PaymentService}}$
\end{itemize}
\end{example}

\subsection{Degrees of Freedom}

\begin{definition}[Degrees of Freedom]\label{def:dof}
The \emph{degrees of freedom} of architecture $A = (C, S, T, R)$ is:
\[
\text{DOF}(A) = \dim(S)
\]
the dimension of the state space.
\end{definition}

\textbf{Operational meaning:} DOF counts independent modification points. If $\text{DOF}(A) = n$, then $n$ independent changes can be made to the architecture.

\begin{proposition}[DOF Additivity]\label{prop:dof-additive}
For architectures $A_1 = (C_1, S_1, T_1, R_1)$ and $A_2 = (C_2, S_2, T_2, R_2)$ with $C_1 \cap C_2 = \emptyset$:
\[
\text{DOF}(A_1 \oplus A_2) = \text{DOF}(A_1) + \text{DOF}(A_2)
\]
where $A_1 \oplus A_2 = (C_1 \cup C_2, S_1 \times S_2, T_1 \times T_2, R_1 \cup R_2)$.
\end{proposition}

\begin{proof}
$\dim(S_1 \times S_2) = \dim(S_1) + \dim(S_2)$ by standard linear algebra.
\end{proof}

\begin{example}[DOF Calculations]
\begin{enumerate}
\item \textbf{Monolith:} Single deployment unit $\to$ DOF $= 1$
\item \textbf{$n$ Microservices:} $n$ independent services $\to$ DOF $= n$
\item \textbf{Copied Code:} Code duplicated to $n$ locations $\to$ DOF $= n$ (each copy independent)
\item \textbf{SSOT:} Single source, $n$ derived uses $\to$ DOF $= 1$ (only source is independent)
\item \textbf{$k$ API Endpoints:} $k$ independent definitions $\to$ DOF $= k$
\item \textbf{$m$ Config Parameters:} $m$ independent settings $\to$ DOF $= m$
\end{enumerate}
\end{example}

\subsection{Capabilities}

\begin{definition}[Capability Set]\label{def:capabilities}
The \emph{capability set} of architecture $A$ is:
\[
\text{Cap}(A) = \{r \in R \mid A \text{ satisfies } r\}
\]
\end{definition}

\textbf{Examples of capabilities:}
\begin{itemize}
\item ``Support horizontal scaling''
\item ``Provide type provenance''
\item ``Enable independent deployment''
\item ``Satisfy single source of truth for class definitions''
\item ``Allow polyglot persistence''
\end{itemize}

\begin{definition}[Capability Satisfaction]\label{def:satisfies}
Architecture $A$ \emph{satisfies} requirement $r$ (written $A \vDash r$) if there exists an execution trace in $(S, T)$ that meets $r$'s specification.
\end{definition}

\subsection{Leverage}

\begin{definition}[Leverage]\label{def:leverage}
The \emph{leverage} of architecture $A$ is:
\[
L(A) = \frac{|\text{Cap}(A)|}{\text{DOF}(A)}
\]
\end{definition}

\textbf{Special cases:}
\begin{enumerate}
\item \textbf{Infinite Leverage ($L = \infty$):} Unlimited capabilities from single source (metaprogramming)
\item \textbf{Unit Leverage ($L = 1$):} Linear relationship (n capabilities from n DOF)
\item \textbf{Sublinear Leverage ($L < 1$):} Antipattern (more DOF than capabilities)
\end{enumerate}

\begin{example}[Leverage Calculations]
\begin{itemize}
\item \textbf{SSOT:} DOF $= 1$, Cap $= \{F, \text{uses of } F\}$ where $|$uses$| \to \infty$ \\
  $\Rightarrow L = \infty$

\item \textbf{Scattered Code (n copies):} DOF $= n$, Cap $= \{F\}$ \\
  $\Rightarrow L = 1/n$ (antipattern!)

\item \textbf{Generic REST Endpoint:} DOF $= 1$, Cap $= \{\text{serve } n \text{ use cases}\}$ \\
  $\Rightarrow L = n$

\item \textbf{Specific Endpoints:} DOF $= n$, Cap $= \{\text{serve } n \text{ use cases}\}$ \\
  $\Rightarrow L = 1$
\end{itemize}
\end{example}

\begin{definition}[Architectural Dominance]\label{def:dominance}
Architecture $A_1$ \emph{dominates} $A_2$ (written $A_1 \succeq A_2$) if:
\begin{enumerate}
\item $\text{Cap}(A_1) \supseteq \text{Cap}(A_2)$ (at least same capabilities)
\item $L(A_1) \geq L(A_2)$ (at least same leverage)
\end{enumerate}

$A_1$ \emph{strictly dominates} $A_2$ (written $A_1 \succ A_2$) if $A_1 \succeq A_2$ with at least one inequality strict.
\end{definition}

\subsection{Modification Complexity}

\begin{definition}[Modification Complexity]\label{def:mod-complexity}
For requirement change $\delta R$, the \emph{modification complexity} is:
\[
M(A, \delta R) = \text{expected number of independent changes to implement } \delta R
\]
\end{definition}

\begin{theorem}[Modification Bounded by DOF]\label{thm:mod-bound}
For all architectures $A$ and requirement changes $\delta R$:
\[
M(A, \delta R) \leq \text{DOF}(A)
\]
with equality when $\delta R$ affects all components.
\end{theorem}

\begin{proof}
Each change modifies at most one DOF. Since there are $\text{DOF}(A)$ independent modification points, the maximum number of changes is $\text{DOF}(A)$.
\end{proof}

\begin{example}[SSOT vs Scattered]
Consider changing a structural fact $F$ with $n$ use sites:
\begin{itemize}
\item \textbf{SSOT:} $M = 1$ (change at source, derivations update automatically)
\item \textbf{Scattered:} $M = n$ (must change each copy independently)
\end{itemize}
\end{example}

\subsection{Formalization in Lean}

All definitions in this section are formalized in \texttt{Leverage/Foundations.lean}:
\begin{itemize}
\item \texttt{Architecture}: Structure with components, state, transitions, requirements
\item \texttt{Architecture.dof}: Degrees of freedom calculation
\item \texttt{Architecture.capabilities}: Capability set
\item \texttt{Architecture.leverage}: Leverage metric
\item \texttt{Architecture.dominates}: Dominance relation
\item \texttt{dof\_additive}: Proposition \ref{prop:dof-additive}
\item \texttt{modification\_bounded\_by\_dof}: Theorem \ref{thm:mod-bound}
\end{itemize}


