\section{Tractable Special Cases}\label{sec:tractable}

We distinguish the encodings of Section~\ref{sec:encoding}. The tractability results below state the model assumption explicitly. All results are formalized in \texttt{DecisionQuotient/Tractability/}.

\begin{theorem}[Tractable Subcases]\label{thm:tractable}
SUFFICIENCY-CHECK is polynomial-time solvable in the following cases:
\begin{enumerate}
\item \textbf{Explicit-state encoding:} The input contains the full utility table over $A \times S$. SUFFICIENCY-CHECK runs in $O(|S|^2|A|)$ time; if $|A|$ is constant, $O(|S|^2)$.
\item \textbf{Separable utility (any encoding):} $U(a, s) = f(a) + g(s)$.
\item \textbf{Tree-structured utility with explicit local factors (succinct structured encoding):} There exists a rooted tree on coordinates and local functions $u_i$ such that
\[
U(a,s) = \sum_i u_i\bigl(a, s_i, s_{\mathrm{parent}(i)}\bigr),
\]
with the root term depending only on $(a, s_{\mathrm{root}})$ and all $u_i$ given explicitly as part of the input.
\end{enumerate}
\end{theorem}

\subsection{Explicit-State Encoding}

\begin{proof}[Proof of Part 1]
Given the full table of $U(a,s)$, compute $\Opt(s)$ for all $s \in S$ in $O(|S||A|)$ time. For SUFFICIENCY-CHECK on a given $I$, verify that for all pairs $(s,s')$ with $s_I = s'_I$, we have $\Opt(s) = \Opt(s')$. This takes $O(|S|^2|A|)$ time by direct enumeration and is polynomial in the explicit input length. If $|A|$ is constant, the runtime is $O(|S|^2)$.
\end{proof}

\subsection{Separable Utility}

\begin{proof}[Proof of Part 2]
If $U(a, s) = f(a) + g(s)$, then:
\[
\Opt(s) = \arg\max_{a \in A} [f(a) + g(s)] = \arg\max_{a \in A} f(a)
\]
The optimal action is independent of the state! Thus $I = \emptyset$ is always sufficient.
\end{proof}

\subsection{Tree-Structured Utility}

\begin{proof}[Proof of Part 3]
Assume the tree decomposition and explicit local tables as stated. For each node $i$ and each value of its parent coordinate, compute the set of actions that are optimal for some assignment of the subtree rooted at $i$. This is a bottom-up dynamic program that combines local tables with child summaries; each table lookup is explicit in the input. A coordinate is relevant if and only if varying its value changes the resulting optimal action set. The total runtime is polynomial in $n$, $|A|$, and the size of the local tables.
\end{proof}

\subsection{Practical Implications}

These tractable cases correspond to common modeling scenarios:

\begin{itemize}
\item \textbf{Explicit-state encoding:} Small or fully enumerated state spaces
\item \textbf{Separable utility:} Additive cost models, linear utility functions
\item \textbf{Tree-structured utility:} Hierarchical decision processes, causal models with tree structure
\end{itemize}

For problems given in the succinct encoding without these structural restrictions, the hardness results of Section~\ref{sec:hardness} apply, justifying heuristic approaches.
