\section{Formalization Methodology}\label{sec:methodology}

This section describes our Lean 4 framework for formalizing polynomial-time reductions and complexity proofs. We discuss design decisions, integration with Mathlib, and challenges specific to complexity theory in dependent type systems.

\subsection{Representing Decision Problems}

Decision problems are represented as \texttt{Prop}-valued functions over finite types:

\begin{verbatim}
def DecisionProblem (α : Type*) := α → Prop

structure Instance (P : DecisionProblem α) where
  input : α
  certificate : P input → Prop  -- witness structure for NP
\end{verbatim}

For complexity classes requiring witness bounds, we bundle size constraints:

\begin{verbatim}
structure NPWitness (P : DecisionProblem α) (x : α) where
  witness : β
  valid : P x ↔ ∃ w : β, verify x w
  size_bound : size witness ≤ poly (size x)
\end{verbatim}

\subsection{Polynomial-Time Reductions}

Karp reductions are bundled structures containing the reduction function, correctness proof, and polynomial bound:

\begin{verbatim}
structure KarpReduction (P : DecisionProblem α) (Q : DecisionProblem β) where
  f : α → β
  correct : ∀ x, P x ↔ Q (f x)
  poly_time : ∃ p : Polynomial ℕ, ∀ x, time (f x) ≤ p.eval (size x)
\end{verbatim}

Reduction composition preserves polynomial bounds:

\begin{verbatim}
def KarpReduction.comp (r₁ : KarpReduction P Q) (r₂ : KarpReduction Q R) :
    KarpReduction P R where
  f := r₂.f ∘ r₁.f
  correct := fun x => (r₁.correct x).trans (r₂.correct (r₁.f x))
  poly_time := poly_comp r₁.poly_time r₂.poly_time
\end{verbatim}

\subsection{Complexity Class Membership}

We define complexity classes via their characteristic properties:

\begin{verbatim}
def InNP (P : DecisionProblem α) : Prop :=
  ∃ V : α → β → Prop,
    (∀ x, P x ↔ ∃ w, V x w) ∧
    (∃ p, ∀ x w, V x w → size w ≤ p.eval (size x)) ∧
    PolyTimeVerifiable V

def InCoNP (P : DecisionProblem α) : Prop :=
  InNP (fun x => ¬P x)

def CoNPComplete (P : DecisionProblem α) : Prop :=
  InCoNP P ∧ ∀ Q : DecisionProblem β, InCoNP Q → KarpReduction Q P
\end{verbatim}

\subsection{The Sufficiency Problem Encoding}

The core decision problem is encoded as:

\begin{verbatim}
structure DecisionProblemWithCoords (n : ℕ) where
  actions : Finset Action
  states : Fin n → Finset State
  optimal : (Fin n → State) → Finset Action

def Sufficient (D : DecisionProblemWithCoords n) (I : Finset (Fin n)) : Prop :=
  ∀ s s' : Fin n → State,
    (∀ i ∈ I, s i = s' i) → D.optimal s = D.optimal s'
\end{verbatim}

The reduction from TAUTOLOGY constructs a decision problem where sufficiency of coordinate set $I$ is equivalent to the formula being a tautology.

\subsection{Handling Classical vs Constructive Reasoning}

Complexity theory inherently uses classical reasoning (e.g., ``$P$ or not $P$'' for decision problems). We use Lean's \texttt{Classical} namespace where necessary:

\begin{verbatim}
open Classical in
theorem sufficiency_decidable (D : DecisionProblemWithCoords n) (I : Finset (Fin n)) :
    Decidable (Sufficient D I) := by
  apply decidable_of_iff (∀ s s', _)
  · exact Fintype.decidableForallFintype
\end{verbatim}

The \texttt{\#print axioms} command verifies which axioms each theorem depends on. Our constructive lemmas (basic properties, reduction correctness) avoid classical axioms; hardness proofs necessarily use \texttt{Classical.choice}.

\subsection{Integration with Mathlib}

We build on Mathlib's existing infrastructure:

\begin{itemize}
\item \textbf{Computability:} \texttt{Mathlib.Computability.Primrec} for primitive recursive functions, used to establish polynomial bounds
\item \textbf{Finset/Fintype:} Finite sets and types for encoding bounded state spaces
\item \textbf{Polynomial:} \texttt{Mathlib.Algebra.Polynomial} for polynomial time bounds
\item \textbf{Order:} Lattice operations for sufficiency lattices
\end{itemize}

Where Mathlib lacks coverage (e.g., Karp reductions, W-hierarchy), we provide standalone definitions designed for future Mathlib contribution.

\subsection{Proof Automation}

We develop custom tactics for common reduction patterns:

\begin{verbatim}
macro "reduce_from" src:term : tactic =>
  `(tactic| (
    refine ⟨?f, ?correct, ?poly⟩
    case f => exact $src.f
    case correct => intro x; exact $src.correct x
    case poly => exact $src.poly_time
  ))
\end{verbatim}

For sufficiency proofs, we use a \texttt{sufficiency} tactic that unfolds the definition and applies extensionality:

\begin{verbatim}
macro "sufficiency" : tactic =>
  `(tactic| (
    unfold Sufficient
    intro s s' heq
    ext a
    simp only [Finset.mem_filter]
    constructor <;> intro h <;> exact h
  ))
\end{verbatim}

\subsection{Verification Commands}

Each theorem includes verification metadata:

\begin{verbatim}
#check @sufficiency_coNP_complete  -- type signature
#print axioms sufficiency_coNP_complete  -- axiom dependencies
#eval Nat.repr (countSorry `sufficiency_coNP_complete)  -- 0
\end{verbatim}

The build log (included in the artifact) records successful compilation of all \LeanTotalTheorems\ theorem/lemma statements with \LeanTotalSorry\ \texttt{sorry} placeholders.
