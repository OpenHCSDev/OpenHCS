\section{Formal Foundations}\label{sec:foundations}

We formalize decision problems with coordinate structure, sufficiency of coordinate sets, and the decision quotient, drawing on classical decision theory \cite{savage1954foundations, raiffa1961applied}.

\subsection{Decision Problems with Coordinate Structure}

\begin{definition}[Decision Problem]\label{def:decision-problem}
A \emph{decision problem with coordinate structure} is a tuple $\mathcal{D} = (A, X_1, \ldots, X_n, U)$ where:
\begin{itemize}
\item $A$ is a finite set of \emph{actions} (alternatives)
\item $X_1, \ldots, X_n$ are finite \emph{coordinate spaces}
\item $S = X_1 \times \cdots \times X_n$ is the \emph{state space}
\item $U : A \times S \to \mathbb{Q}$ is the \emph{utility function}
\end{itemize}
\end{definition}

\begin{definition}[Projection]\label{def:projection}
For state $s = (s_1, \ldots, s_n) \in S$ and coordinate set $I \subseteq \{1, \ldots, n\}$:
\[
s_I := (s_i)_{i \in I}
\]
is the \emph{projection} of $s$ onto coordinates in $I$.
\end{definition}

\begin{definition}[Optimizer Map]\label{def:optimizer}
For state $s \in S$, the \emph{optimal action set} is:
\[
\Opt(s) := \arg\max_{a \in A} U(a, s) = \{a \in A : U(a,s) = \max_{a' \in A} U(a', s)\}
\]
\end{definition}

\subsection{Sufficiency and Relevance}

\begin{definition}[Sufficient Coordinate Set]\label{def:sufficient}
A coordinate set $I \subseteq \{1, \ldots, n\}$ is \emph{sufficient} for decision problem $\mathcal{D}$ if:
\[
\forall s, s' \in S: \quad s_I = s'_I \implies \Opt(s) = \Opt(s')
\]
Equivalently, the optimal action depends only on coordinates in $I$.
In this paper, this set-valued invariance of the full optimal-action correspondence is the primary decision-relevance target.
\end{definition}

\begin{definition}[Deterministic Selector]\label{def:selector}
A \emph{deterministic selector} is a map $\sigma : 2^A \to A$ that returns one action from an optimal-action set.
\end{definition}

\begin{definition}[Selector-Level Sufficiency]\label{def:selector-sufficient}
For fixed selector $\sigma$, a coordinate set $I$ is \emph{selector-sufficient} if
\[
\forall s,s' \in S:\quad s_I=s'_I \implies \sigma(\Opt(s))=\sigma(\Opt(s')).
\]
\end{definition}

\begin{proposition}[Set-Level Target Dominates Selector Targets]\label{prop:set-to-selector}
If $I$ is sufficient in the set-valued sense (Definition~\ref{def:sufficient}), then $I$ is selector-sufficient for every deterministic selector $\sigma$ (Definition~\ref{def:selector-sufficient}).
\textit{(Lean: \nolinkurl{DecisionProblem.sufficient_implies_selectorSufficient})}
\end{proposition}

\begin{proof}
If $I$ is sufficient, then $s_I=s'_I$ implies $\Opt(s)=\Opt(s')$. Applying any deterministic selector $\sigma$ to equal optimal-action sets yields equal selected actions.
\end{proof}

\begin{definition}[$\varepsilon$-Optimal Set and $\varepsilon$-Sufficiency]\label{def:epsilon-sufficiency}
For $\varepsilon \ge 0$, define
\[
\Opt_\varepsilon(s)
:=
\{a\in A:\forall a'\in A,\ U(a',s)\le U(a,s)+\varepsilon\}.
\]
Coordinate set $I$ is \emph{$\varepsilon$-sufficient} if
\[
\forall s,s'\in S:\ s_I=s'_I \implies \Opt_\varepsilon(s)=\Opt_\varepsilon(s').
\]
\end{definition}

\begin{proposition}[Zero-$\varepsilon$ Reduction]\label{prop:zero-epsilon-reduction}
Set-valued sufficiency is exactly the $\varepsilon=0$ case:
\[
I\text{ sufficient } \iff I\text{ is }0\text{-sufficient}.
\]
\textit{(Lean: \nolinkurl{DecisionProblem.epsOpt_zero_eq_opt},
\nolinkurl{DecisionProblem.sufficient_iff_zeroEpsilonSufficient})}
\end{proposition}

\begin{proposition}[Selector-Level Separation Witness]\label{prop:selector-separation}
The converse of Proposition~\ref{prop:set-to-selector} fails in general: there exists a decision problem, selector, and coordinate set $I$ such that $I$ is selector-sufficient but not sufficient in the full set-valued sense.
\textit{(Lean witness: \nolinkurl{ClaimClosure.selectorSufficient_not_implies_setSufficient}.)}
\end{proposition}

\begin{definition}[Minimal Sufficient Set]\label{def:minimal-sufficient}
A sufficient set $I$ is \emph{minimal} if no proper subset $I' \subsetneq I$ is sufficient.
\end{definition}

\begin{definition}[Relevant Coordinate]\label{def:relevant}
Coordinate $i$ is \emph{relevant} if there exist states that differ only at coordinate $i$ and induce different optimal action sets:
\[
i \text{ is relevant}
\iff
\exists s,s' \in S:\; \Big(\forall j \neq i,\; s_j = s'_j\Big)\ \wedge\ \Opt(s)\neq\Opt(s').
\]
\end{definition}

\begin{proposition}[Minimal-Set/Relevance Equivalence]\label{prop:minimal-relevant-equiv}
For any minimal sufficient set $I$ and any coordinate $i$:
\[
i \in I \iff i \text{ is relevant}.
\]
Hence every minimal sufficient set is exactly the relevant-coordinate set.
\textit{(Lean product-space handles: \nolinkurl{DecisionProblem.minimalSufficient_iff_relevant},
\nolinkurl{DecisionProblem.relevantSet_is_minimal}.)}
\end{proposition}

\begin{proof}
The ``only if'' direction follows by minimality: if $i\in I$ were irrelevant, removing $i$ would preserve sufficiency, contradicting minimality. The ``if'' direction follows from sufficiency: every sufficient set must contain each relevant coordinate.
\end{proof}

\begin{definition}[Exact Relevance Identifiability]\label{def:exact-identifiability}
For a decision problem $\mathcal{D}$ and candidate coordinate set $I$, we say $I$ is \emph{exactly relevance-identifying} if
\[
\forall i \in \{1,\ldots,n\}:\quad i \in I \iff i \text{ is relevant for } \mathcal{D}.
\]
Equivalently, $I$ is exactly relevance-identifying iff $I$ equals the full relevant-coordinate set.
\end{definition}

\begin{example}[Weather Decision]
Consider deciding whether to carry an umbrella:
\begin{itemize}
\item Actions: $A = \{\text{carry}, \text{don't carry}\}$
\item Coordinates: $X_1 = \{\text{rain}, \text{no rain}\}$, $X_2 = \{\text{hot}, \text{cold}\}$, $X_3 = \{\text{Monday}, \ldots, \text{Sunday}\}$
\item Utility: $U(\text{carry}, s) = -1 + 3 \cdot \mathbf{1}[s_1 = \text{rain}]$, $U(\text{don't carry}, s) = -2 \cdot \mathbf{1}[s_1 = \text{rain}]$
\end{itemize}

The minimal sufficient set is $I = \{1\}$ (only rain forecast matters). Coordinates 2 and 3 (temperature, day of week) are irrelevant.
\end{example}

\subsection{The Decision Quotient}

\begin{definition}[Decision Equivalence]\label{def:decision-equiv}
For coordinate set $I$, states $s, s'$ are \emph{$I$-equivalent} (written $s \sim_I s'$) if $s_I = s'_I$.
\end{definition}

\begin{definition}[Decision Quotient]\label{def:decision-quotient}
The \emph{decision quotient} for state $s$ under coordinate set $I$ is:
\[
\text{DQ}_I(s) = \frac{|\{a \in A : a \in \Opt(s') \text{ for some } s' \sim_I s\}|}{|A|}
\]
This measures the fraction of actions that are optimal for at least one state consistent with $I$.
\end{definition}

\begin{proposition}[Sufficiency Characterization]\label{prop:sufficiency-char}
Coordinate set $I$ is sufficient if and only if $\text{DQ}_I(s) = |\Opt(s)|/|A|$ for all $s \in S$.
\textit{(Lean finite-model form: \nolinkurl{ClaimClosure.sufficiency_iff_dq_ratio},
\nolinkurl{ClaimClosure.sufficiency_iff_projectedOptCover_eq_opt})}
\end{proposition}

\begin{proof}
If $I$ is sufficient, then $s \sim_I s' \implies \Opt(s) = \Opt(s')$, so the set of actions optimal for some $s' \sim_I s$ is exactly $\Opt(s)$.

Conversely, if the condition holds, then for any $s \sim_I s'$, the optimal actions form the same set (since $\text{DQ}_I(s) = \text{DQ}_I(s')$ and both equal the relative size of the common optimal set).
\end{proof}

\subsection{Computational Model and Input Encoding}\label{sec:encoding}

We fix the computational model used by the complexity claims.

\paragraph{Succinct encoding (primary for hardness).}
This succinct circuit encoding is the standard representation for decision problems in complexity theory; hardness is stated with respect to the input length of the circuit description \cite{arora2009computational}.
An instance is encoded as:
\begin{itemize}
\item a finite action set $A$ given explicitly,
\item coordinate domains $X_1,\ldots,X_n$ given by their sizes in binary,
\item a Boolean or arithmetic circuit $C_U$ that on input $(a,s)$ outputs $U(a,s)$.
\end{itemize}
The input length is $L = |A| + \sum_i \log |X_i| + |C_U|$. Polynomial time and all complexity classes (\coNP, $\Sigma_2^P$, ETH) are measured in $L$. All hardness results in Section~\ref{sec:hardness} use this encoding.

\paragraph{Explicit-state encoding (used for enumeration algorithms and experiments).}
The utility is given as a full table over $A \times S$. The input length is $L_{\text{exp}} = \Theta(|A||S|)$ (up to the bitlength of utilities). Polynomial time is measured in $L_{\text{exp}}$. Results stated in terms of $|S|$ use this encoding.

\paragraph{Query-access regime (intermediate black-box access).}
The solver is given oracle access to decision information at queried states (e.g., $\Opt(s)$, or $U(a,s)$ with $\Opt(s)$ reconstructed from finitely many value queries). Complexity is measured by oracle-query count (optionally paired with per-query evaluation cost). This separates representational access from full-table availability and from succinct-circuit input length.

Unless explicitly stated otherwise, ``polynomial time'' refers to the succinct encoding.

\subsection{Model Contract and Regime Tags}\label{sec:model-contract}

All theorem statements in this paper are typed by the following model contract:
\begin{itemize}
\item \textbf{C1 (finite actions):} $A$ is finite.
\item \textbf{C2 (finite coordinate domains):} each $X_i$ is finite, so $S=\prod_i X_i$ is finite.
\item \textbf{C3 (evaluable utility):} $U(a,s)$ is computable from the declared input encoding.
\item \textbf{C4 (fixed decision semantics):} optimality is defined by $\Opt(s)=\arg\max_a U(a,s)$.
\end{itemize}

We use short regime tags for applied corollaries:
\begin{itemize}
\item \textbf{[E]} explicit-state encoding,
\item \textbf{[Q]} query-access (oracle) regime,
\item \textbf{[S]} succinct encoding,
\item \textbf{[S+ETH]} succinct encoding with ETH,
\item \textbf{[Q\_bool]} mechanized Boolean query submodel,
\item \textbf{[S\_bool]} mechanized Boolean-coordinate submodel.
\end{itemize}

This tagging is a claim-typing convention: each strong statement is attached to the regime where it is proven.

\subsection{Adjacent Objective Regimes and Bridge}

\begin{definition}[Adjacent Sequential Objective Regime]\label{def:adjacent-sequential-regime}
An adjacent sequential objective instance consists of:
\begin{itemize}
\item finite action set $A$,
\item finite coordinate state space $S = X_1 \times \cdots \times X_n$,
\item horizon $T \in \mathbb{N}_{\ge 1}$ and history-dependent policy class,
\item reward process $r_t$ and objective functional $J(\pi)$ (e.g., cumulative reward or regret).
\end{itemize}
\end{definition}

\begin{proposition}[One-Step Deterministic Bridge]\label{prop:one-step-bridge}
Consider an instance of Definition~\ref{def:adjacent-sequential-regime} satisfying:
\begin{enumerate}
\item $T=1$,
\item deterministic rewards $r_1(a,s)=U(a,s)$ for some evaluable $U$,
\item objective $J(\pi)=U(\pi(s),s)$ (single-step maximization),
\item no post-decision state update relevant to the objective.
\end{enumerate}
Then the induced optimization problem is exactly the static decision problem of Definition~\ref{def:decision-problem}, and coordinate sufficiency in the sequential formulation is equivalent to Definition~\ref{def:sufficient}.
\textit{(Lean bridge core: \nolinkurl{ClaimClosure.one_step_bridge})}
\end{proposition}

\begin{proof}
Under (1)--(3), optimizing $J$ at state $s$ is identical to choosing an action in $\arg\max_{a\in A} U(a,s)=\Opt(s)$. Condition (4) removes any dependence on future transition effects. Therefore the optimal-policy relation in the adjacent formulation coincides pointwise with $\Opt$ from Definition~\ref{def:optimizer}, and the invariance condition ``same projection implies same optimal choice set'' is exactly Definition~\ref{def:sufficient}.
\end{proof}

\begin{proposition}[Bridge Transfer Rule]\label{prop:bridge-transfer-scope}
Under conditions (1)--(4), any sufficiency statement formulated over Definition~\ref{def:sufficient} is equivalent between the adjacent sequential formulation and the static model.
\textit{(Lean: \nolinkurl{ClaimClosure.one_step_bridge})}
\end{proposition}

\begin{proof}
By Proposition~\ref{prop:one-step-bridge}, the adjacent sequential objective induces exactly the same sufficiency predicate as Definition~\ref{def:sufficient} when (1)--(4) hold. Equivalence of any sufficiency statement then follows by substitution.
\end{proof}

If any bridge condition fails, direct transfer from this paper's static complexity theorems is not licensed by this rule.

\begin{remark}[Extension Boundary]
Beyond Proposition~\ref{prop:one-step-bridge} (multi-step horizon, stochastic transitions/rewards, or regret objectives), the governing complexity objects change. Those regimes are natural extensions, but they are distinct formal classes from the static sufficiency class analyzed in this paper.
\end{remark}

\section{Interpretive Foundations: Hardness and Solver Claims}\label{sec:interpretive-foundations}

The claims in later applied sections are theorem-indexed consequences of this section and Sections~\ref{sec:hardness}--\ref{sec:tractable}.

\subsection{Structural Complexity vs Representational Hardness}

\begin{definition}[Structural Complexity]\label{def:structural-complexity}
For a fixed formal decision relation (e.g., ``$I$ is sufficient for $\mathcal{D}$''), \emph{structural complexity} means its placement in standard complexity classes within the formal model (coNP, $\Sigma_2^P$, etc.), as established by class-membership arguments and reductions.
\end{definition}

\begin{definition}[Representational Hardness]\label{def:representational-hardness}
For a fixed decision relation and an encoding regime $E$ (Section~\ref{sec:encoding}), \emph{representational hardness} is the worst-case computational cost incurred by solvers whose input access is restricted to $E$.
\end{definition}

\begin{remark}[Interpretation Contract]
This paper keeps the decision relation fixed and varies the encoding regime explicitly. Thus, later separations are read as changes in representational hardness under fixed structural complexity, not as changes to the underlying sufficiency semantics.
\end{remark}

\subsection{Solver Integrity and Regime Competence}

To keep practical corollaries type-safe, we separate \emph{integrity} (what a solver is allowed to assert) from \emph{competence} (what it can cover under a declared regime), following the certifying-algorithms schema \cite{mcconnell2010certifying}.

\begin{definition}[Certifying Solver]\label{def:certifying-solver}
Fix a decision relation $\mathcal{R} \subseteq \mathcal{X}\times\mathcal{Y}$ and an encoding regime $E$ over $\mathcal{X}$. A \emph{certifying solver} is a pair $(Q,V)$ where:
\begin{itemize}
\item $Q$ maps each input $x\in\mathcal{X}$ to either $\mathsf{ABSTAIN}$ or a candidate pair $(y,w)$,
\item $V$ is a polynomial-time checker (in $|{\rm enc}_E(x)|$) with output in $\{0,1\}$.
\end{itemize}
\end{definition}

\begin{definition}[Solver Integrity]\label{def:solver-integrity}
A certifying solver $(Q,V)$ has \emph{integrity} for relation $\mathcal{R}$ if:
\begin{itemize}
\item (assertion soundness) $Q(x)=(y,w)\implies V(x,y,w)=1$,
\item (checker soundness) $V(x,y,w)=1\implies (x,y)\in\mathcal{R}$.
\end{itemize}
The output $\mathsf{ABSTAIN}$ (equivalently, $\mathsf{UNKNOWN}$) is first-class and carries no assertion about membership in $\mathcal{R}$.
\end{definition}

\begin{definition}[Competence Under a Regime]\label{def:competence-regime}
Fix a regime $\Gamma=(\mathcal{X}_\Gamma,E_\Gamma,\mathcal{C}_\Gamma)$ with instance family $\mathcal{X}_\Gamma\subseteq\mathcal{X}$, encoding assumptions $E_\Gamma$, and resource bound $\mathcal{C}_\Gamma$. A certifying solver $(Q,V)$ is \emph{competent} on $\Gamma$ for relation $\mathcal{R}$ if:
\begin{itemize}
\item it has integrity for $\mathcal{R}$ (Definition~\ref{def:solver-integrity}),
\item (coverage) $\forall x\in\mathcal{X}_\Gamma,\;Q(x)\neq\mathsf{ABSTAIN}$,
\item (resource bound) runtime$_Q(x)\le \mathcal{C}_\Gamma(|{\rm enc}_{E_\Gamma}(x)|)$ for all $x\in\mathcal{X}_\Gamma$.
\end{itemize}
\end{definition}

\begin{proposition}[Integrity--Competence Separation]\label{prop:integrity-competence-separation}
Integrity and competence are distinct predicates: integrity constrains asserted outputs, while competence adds non-abstaining coverage under resource bounds.
\end{proposition}

\begin{proof}
Take the always-abstain solver $Q_\bot(x)=\mathsf{ABSTAIN}$ with any polynomial-time checker $V$. Definition~\ref{def:solver-integrity} holds vacuously, so $(Q_\bot,V)$ is integrity-preserving, but it fails Definition~\ref{def:competence-regime} whenever $\mathcal{X}_\Gamma\neq\emptyset$ because coverage fails. Hence integrity does not imply competence. The converse is immediate because competence includes integrity as a conjunct.
\end{proof}

\begin{definition}[Attempted Competence Failure]\label{def:attempted-competence-failure}
Fix an exact objective under regime $\Gamma$. A solver state is an \emph{attempted competence failure} if:
\begin{itemize}
\item integrity holds (Definition~\ref{def:solver-integrity}),
\item exact competence was actually attempted for the active scope/objective,
\item competence on $\Gamma$ fails for that exact objective (Definition~\ref{def:competence-regime}).
\end{itemize}
\end{definition}

\begin{proposition}[Attempted-Competence Rationality Matrix]\label{prop:attempted-competence-matrix}
Let $I,A,C\in\{0,1\}$ denote integrity, attempted exact competence, and competence available in the active regime. Policy verdict for persistent over-specification is:
\begin{itemize}
\item if $I=0$: inadmissible,
\item if $I=1$ and $(A,C)=(1,0)$: conditionally rational,
\item if $I=1$ and $(A,C)\in\{(0,0),(0,1),(1,1)\}$: irrational for the same verified-cost objective.
\end{itemize}
Hence, in the integrity-preserving plane ($I=1$), exactly one cell is rational and three are irrational.
\textit{(Lean: \nolinkurl{IntegrityCompetence.overModelVerdict_rational_iff},
\nolinkurl{IntegrityCompetence.admissible_matrix_counts},
\nolinkurl{IntegrityCompetence.admissible_irrational_strictly_more_than_rational})}
\end{proposition}

This separation plus Proposition~\ref{prop:attempted-competence-matrix} is load-bearing for the regime-conditional trilemma used later: if exact competence is blocked by hardness in a declared regime after an attempted exact procedure, integrity forces one of three responses---abstain, weaken guarantees, or change regime assumptions.

\paragraph{Mechanized status.}
This separation is machine-checked in \texttt{DecisionQuotient/IntegrityCompetence.lean} via:
\texttt{competence\_implies\_integrity} and
\texttt{integrity\_not\_competent\_of\_nonempty\_scope}; the attempted-competence matrix is mechanized via
\texttt{overModelVerdict\_rational\_iff},
\texttt{admissible\_matrix\_counts}, and
\texttt{admissible\_irrational\_strictly\_more\_than\_rational}.


% Include the hardness proofs (already developed)
\input{hardness_proofs.tex}
