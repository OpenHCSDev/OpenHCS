\section{Lean 4 Proof Listings}\label{app:lean}

The complete Lean 4 formalization is available in the companion artifact (Zenodo DOI listed on the title page). The mechanization consists of approximately 5,000 lines across 33 files.

\subsection{What Is Machine-Checked}

The Lean formalization establishes:

\begin{enumerate}
\item \textbf{Correctness of the TAUTOLOGY reduction:} The theorem \texttt{tautology\_iff\_sufficient} proves that the mapping from Boolean formulas to decision problems preserves the decision structure (accept iff the formula is a tautology).

\item \textbf{Decision problem definitions:} Formal definitions of sufficiency, optimality, and the decision quotient.

\item \textbf{Economic theorems:} The Simplicity Tax conservation laws and hardness distribution results.
\end{enumerate}

\textbf{Complexity classifications} (coNP-completeness, $\Sigma_2^P$-completeness) follow from informal composition with standard results (TAUTOLOGY is coNP-complete, etc.). The Lean proofs verify the reduction constructions; the complexity class membership is derived by combining these with established theorems from complexity theory.

\subsection{Polynomial-Time Reduction Definition}

We use Mathlib's Turing machine framework to define polynomial-time computability:

\begin{verbatim}
/-- Polynomial-time computable function using Turing machines -/
def PolyTime {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β) 
    (f : α → β) : Prop :=
  Nonempty (Turing.TM2ComputableInPolyTime ea eb f)

/-- Polynomial-time many-one (Karp) reduction -/
def ManyOneReducesPoly {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β)
    (A : Set α) (B : Set β) : Prop :=
  ∃ f : α → β, PolyTime ea eb f ∧ ∀ x, x ∈ A ↔ f x ∈ B
\end{verbatim}

This uses the standard definition: a reduction is polynomial-time computable via Turing machines and preserves membership.

\subsection{The Main Reduction Theorem}

\begin{theorem}[TAUTOLOGY Reduction Correctness, Lean]
The reduction from TAUTOLOGY to SUFFICIENCY-CHECK is correct:
\end{theorem}

\begin{verbatim}
theorem tautology_iff_sufficient (φ : Formula n) :
    φ.isTautology ↔ (reductionProblem φ).isSufficient Finset.empty
\end{verbatim}

This theorem is proven by showing both directions:
\begin{itemize}
\item If $\varphi$ is a tautology, then the empty coordinate set is sufficient
\item If the empty coordinate set is sufficient, then $\varphi$ is a tautology
\end{itemize}

The proof verifies that the utility construction in \texttt{reductionProblem} creates the appropriate decision structure where:
\begin{itemize}
\item At reference states, \texttt{accept} is optimal with utility 1
\item At assignment states, \texttt{accept} is optimal iff $\varphi(a) = \text{true}$
\end{itemize}

\subsection{Economic Results}

The hardness distribution theorems (Section~\ref{sec:simplicity-tax}) are fully formalized:

\begin{verbatim}
theorem simplicityTax_conservation :
    simplicityTax P T + (P.requiredAxes inter T.nativeAxes).card
      = P.requiredAxes.card

theorem simplicity_preference_fallacy (T_simple T_complex : Tool)
    (h_simple_incomplete : isIncomplete P T_simple)
    (h_complex_complete : isComplete P T_complex)
    (n : Nat) (hn : n > 0) :
    totalExternalWork P T_complex n < totalExternalWork P T_simple n
\end{verbatim}

\subsection{Module Structure}

\begin{itemize}
\item \texttt{Basic.lean} -- Core definitions (DecisionProblem, sufficiency, optimality)
\item \texttt{Sufficiency.lean} -- Sufficiency checking algorithms and properties
\item \texttt{Reduction.lean} -- TAUTOLOGY reduction construction and correctness
\item \texttt{Complexity.lean} -- Polynomial-time reduction definitions using mathlib
\item \texttt{HardnessDistribution.lean} -- Simplicity Tax theorems
\item \texttt{Tractability/} -- Bounded actions, separable utilities, tree structure
\end{itemize}

\subsection{Verification}

The proofs compile with Lean 4 and contain no \texttt{sorry} placeholders. Run \texttt{lake build} in the proof directory to verify.
