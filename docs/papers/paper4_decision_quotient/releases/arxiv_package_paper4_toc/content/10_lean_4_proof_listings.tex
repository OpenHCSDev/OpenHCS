\section{Lean 4 Proof Listings}\label{app:lean}

The complete Lean 4 formalization is available in the companion artifact (Zenodo DOI listed on the title page). The mechanization consists of \LeanTotalLines\ lines across \LeanTotalFiles\ files, with \LeanTotalTheorems\ theorem/lemma statements.

\subsection{What Is Machine-Checked}

The Lean formalization establishes:

\begin{enumerate}
\item \textbf{Correctness of the TAUTOLOGY reduction:} The theorem \texttt{tautology\_iff\_sufficient} proves that the mapping from Boolean formulas to decision problems preserves the decision structure (accept iff the formula is a tautology).

\item \textbf{Decision problem definitions:} Formal definitions of sufficiency, optimality, and the decision quotient.

\item \textbf{Economic theorems:} Simplicity Tax redistribution identities and hardness distribution results.
\end{enumerate}

\textbf{Complexity classifications} (coNP-completeness, $\Sigma_2^P$-completeness) follow from informal composition with standard results (TAUTOLOGY is coNP-complete, etc.). The Lean proofs verify the reduction constructions; the complexity class membership is derived by combining these with established theorems from complexity theory.

\subsection{Polynomial-Time Reduction Definition}

We use Mathlib's Turing machine framework to define polynomial-time computability:

\begin{verbatim}
/-- Polynomial-time computable function using Turing machines -/
def PolyTime {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β) 
    (f : α → β) : Prop :=
  Nonempty (Turing.TM2ComputableInPolyTime ea eb f)

/-- Polynomial-time many-one (Karp) reduction -/
def ManyOneReducesPoly {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β)
    (A : Set α) (B : Set β) : Prop :=
  ∃ f : α → β, PolyTime ea eb f ∧ ∀ x, x ∈ A ↔ f x ∈ B
\end{verbatim}

This uses the standard definition: a reduction is polynomial-time computable via Turing machines and preserves membership.

\subsection{The Main Reduction Theorem}

\begin{theorem}[TAUTOLOGY Reduction Correctness, Lean]
The reduction from TAUTOLOGY to SUFFICIENCY-CHECK is correct:
\end{theorem}

\begin{verbatim}
theorem tautology_iff_sufficient (φ : Formula n) :
    φ.isTautology ↔ (reductionProblem φ).isSufficient Finset.empty
\end{verbatim}

This theorem is proven by showing both directions:
\begin{itemize}
\item If $\varphi$ is a tautology, then the empty coordinate set is sufficient
\item If the empty coordinate set is sufficient, then $\varphi$ is a tautology
\end{itemize}

The proof verifies that the utility construction in \texttt{reductionProblem} creates the appropriate decision structure where:
\begin{itemize}
\item At reference states, \texttt{accept} is optimal with utility 1
\item At assignment states, \texttt{accept} is optimal iff $\varphi(a) = \text{true}$
\end{itemize}

\subsection{Economic Results}

The hardness distribution theorems (Section~\ref{sec:simplicity-tax}) are fully formalized:

\begin{verbatim}
theorem simplicityTax_conservation (P : SpecificationProblem)
    (S : SolutionArchitecture P) :
    S.centralDOF + simplicityTax P S ≥ P.intrinsicDOF

theorem simplicityTax_grows (P : SpecificationProblem)
    (S : SolutionArchitecture P) (n₁ n₂ : ℕ)
    (hn : n₁ < n₂) (htax : simplicityTax P S > 0) :
    totalDOF S n₁ < totalDOF S n₂

theorem native_dominates_manual (P : SpecificationProblem) (n : Nat)
    (hn : n > P.intrinsicDOF) :
    totalDOF (nativeTypeSystem P) n < totalDOF (manualApproach P) n

theorem totalDOF_eventually_constant_iff_zero_distributed
    (S : SolutionArchitecture P) :
    IsEventuallyConstant (fun n => totalDOF S n) ↔ S.distributedDOF = 0

theorem no_positive_slope_linear_represents_saturating
    (c d K : ℕ) (hd : d > 0) :
    ¬ (∀ n, c + n * d = generalizedTotalDOF c (saturatingSiteCost K) n)
\end{verbatim}

\noindent\textbf{Identifier note.}
Lean identifiers retain internal naming (\texttt{intrinsicDOF}, \texttt{simplicityTax\_conservation}); in paper terminology these correspond to \emph{baseline hardness} and the \emph{redistribution lower-bound identity}, respectively.

\subsection{Engineering Corollary Mapping}

\begingroup
\scriptsize
\sloppy
\setlength{\tabcolsep}{4pt}
\begin{longtable}{@{}>{\raggedright\arraybackslash}p{0.17\linewidth}>{\raggedright\arraybackslash}p{0.58\linewidth}>{\raggedright\arraybackslash}p{0.21\linewidth}@{}}
\toprule
\textbf{Paper handle} & \textbf{Lean theorem} & \textbf{Lean file} \\
\midrule
\nolinkurl{cor:overmodel-diagnostic-implication} &
\nolinkurl{Sigma2PHardness.sufficient_iff_relevant_subset} &
\nolinkurl{DecisionQuotient/Hardness/Sigma2PHardness.lean} \\
\nolinkurl{cor:exact-identifiability} &
\nolinkurl{Sigma2PHardness.exactlyIdentifiesRelevant_iff_sufficient_and_subset_relevantFinset} &
\nolinkurl{DecisionQuotient/Hardness/Sigma2PHardness.lean} \\
\shortstack[l]{\texttt{thm:cost-}\\\texttt{asymmetry-eth}} &
\nolinkurl{HardnessDistribution.linear_lt_exponential_plus_constant_eventually} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\shortstack[l]{\texttt{prop:integrity-}\\\texttt{competence-forward}} &
\nolinkurl{IntegrityCompetence.competence_implies_integrity} &
\nolinkurl{DecisionQuotient/IntegrityCompetence.lean} \\
\shortstack[l]{\texttt{prop:integrity-}\\\texttt{competence-strict}} &
\nolinkurl{IntegrityCompetence.integrity_not_competent_of_nonempty_scope} &
\nolinkurl{DecisionQuotient/IntegrityCompetence.lean} \\
\nolinkurl{cor:practice-diagnostic} &
\nolinkurl{Sigma2PHardness.min_sufficient_set_iff_relevant_card} &
\nolinkurl{DecisionQuotient/Hardness/Sigma2PHardness.lean} \\
\nolinkurl{cor:practice-bounded} &
\nolinkurl{sufficiency_poly_bounded_actions} &
\nolinkurl{DecisionQuotient/Tractability/BoundedActions.lean} \\
\nolinkurl{cor:practice-structured} &
\nolinkurl{sufficiency_poly_separable} &
\nolinkurl{DecisionQuotient/Tractability/SeparableUtility.lean} \\
\nolinkurl{cor:practice-tree} &
\nolinkurl{sufficiency_poly_tree_structured} &
\nolinkurl{DecisionQuotient/Tractability/TreeStructure.lean} \\
\nolinkurl{cor:practice-unstructured} &
\nolinkurl{all_coords_relevant_of_not_tautology} &
\nolinkurl{DecisionQuotient/Reduction_AllCoords.lean} \\
\nolinkurl{prop:hardness-conservation} &
\nolinkurl{HardnessDistribution.totalDOF_ge_intrinsic} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\nolinkurl{prop:hardness-efficiency-interpretation} &
\nolinkurl{HardnessDistribution.hardnessEfficiency_eq_central_share} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\shortstack[l]{\texttt{thm:}\\\texttt{centralization-}\\\texttt{dom-1-2}} &
\nolinkurl{HardnessDistribution.centralization_dominance_bundle} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\shortstack[l]{\texttt{thm:}\\\texttt{centralization-}\\\texttt{dom-3}} &
\nolinkurl{HardnessDistribution.centralization_step_saves_n_minus_one} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\nolinkurl{cor:right-wrong-hardness} &
\nolinkurl{HardnessDistribution.right_dominates_wrong} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\nolinkurl{cor:type-system-threshold} &
\nolinkurl{HardnessDistribution.native_dominates_manual} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\nolinkurl{thm:tax-conservation} &
\nolinkurl{HardnessDistribution.gap_conservation_card} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\nolinkurl{thm:tax-grows} &
\nolinkurl{HardnessDistribution.totalExternalWork_eq_n_mul_gapCard} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\nolinkurl{thm:amortization} &
\nolinkurl{HardnessDistribution.complete_model_dominates_after_threshold} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\shortstack[l]{\texttt{cor:gap-}\\\texttt{externalization-id}} &
\nolinkurl{HardnessDistribution.totalExternalWork_eq_n_mul_gapCard} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\shortstack[l]{\texttt{cor:}\\\texttt{gap-}\\\texttt{externalization-}\\\texttt{grow}} &
\nolinkurl{HardnessDistribution.simplicityTax_grows} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\nolinkurl{cor:gap-minimization-hard} &
\nolinkurl{Sigma2PHardness.min_sufficient_set_iff_relevant_card} &
\nolinkurl{DecisionQuotient/Hardness/Sigma2PHardness.lean} \\
\nolinkurl{thm:linear-saturation-iff-zero} &
\nolinkurl{HardnessDistribution.totalDOF_eventually_constant_iff_zero_distributed} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\nolinkurl{thm:generalized-saturation-possible} &
\nolinkurl{HardnessDistribution.generalizedTotal_with_saturation_eventually_constant} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\nolinkurl{cor:linear-positive-no-saturation} &
\nolinkurl{HardnessDistribution.no_positive_slope_linear_represents_saturating} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\nolinkurl{thm:generalized-dominance} &
\nolinkurl{HardnessDistribution.generalized_right_dominates_wrong_of_bounded_vs_identity_lower} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\nolinkurl{cor:generalized-eventual-dominance} &
\nolinkurl{HardnessDistribution.generalized_right_eventually_dominates_wrong} &
\nolinkurl{DecisionQuotient/HardnessDistribution.lean} \\
\bottomrule
\end{longtable}
\endgroup

\subsection{Module Structure}

\begin{itemize}
\item \texttt{Basic.lean} -- Core definitions (DecisionProblem, sufficiency, optimality)
\item \texttt{Sufficiency.lean} -- Sufficiency checking algorithms and properties
\item \texttt{Reduction.lean} -- TAUTOLOGY reduction construction and correctness
\item \texttt{Complexity.lean} -- Polynomial-time reduction definitions using mathlib
\item \texttt{HardnessDistribution.lean} -- Simplicity Tax redistribution and amortization theorems
\item \texttt{IntegrityCompetence.lean} -- Solver integrity vs regime competence separation
\item \texttt{Tractability/} -- Bounded actions, separable utilities, tree structure
\end{itemize}

\subsection{Verification}

The proofs compile with Lean 4 and contain no \texttt{sorry} placeholders. Run \texttt{lake build} in the proof directory to verify.
