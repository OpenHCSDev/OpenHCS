\section{Encoding-Regime Separation}\label{sec:dichotomy}

The hardness results of Section~\ref{sec:hardness} apply to worst-case instances under the succinct encoding. This section states an encoding-regime separation: an explicit-state upper bound versus a succinct-encoding worst-case lower bound, and an intermediate query-access obstruction family.

\paragraph{Model note.} Theorem~\ref{thm:dichotomy} has Part~1 in [E] (time polynomial in $|S|$) and Part~2 in [S+ETH] (time exponential in $n$). Propositions~\ref{prop:query-regime-obstruction} and~\ref{prop:query-value-entry-lb} are [Q\_bool] (query-count lower bounds for two oracle interfaces). These regimes are defined in Section~\ref{sec:encoding} and are not directly comparable as functions of one numeric input-length parameter.

\begin{theorem}[Explicit--Succinct Regime Separation]\label{thm:dichotomy}
Let $\mathcal{D} = (A, X_1, \ldots, X_n, U)$ be a decision problem with $|S| = N$ states. Let $k^*$ be the size of the minimal sufficient set.

\begin{enumerate}
\item \textbf{[E] Explicit-state upper bound:} Under the explicit-state encoding, SUFFICIENCY-CHECK is solvable in time polynomial in $N$ (e.g. $O(N^2|A|)$).

\item \textbf{[S+ETH] Succinct lower bound (worst case):} Assuming ETH, there exists a family of succinctly encoded instances with $n$ coordinates and minimal sufficient set size $k^* = n$ such that SUFFICIENCY-CHECK requires time $2^{\Omega(n)}$.
\end{enumerate}
\textit{(Lean handles: \nolinkurl{ClaimClosure.dichotomy_conditional},
\nolinkurl{ClaimClosure.explicit_state_upper_core},
\nolinkurl{ClaimClosure.hard_family_all_coords_core}.)}
\end{theorem}

\begin{proof}
\textbf{Part 1 (Explicit-state upper bound):} Under the explicit-state encoding, SUFFICIENCY-CHECK is decidable in time polynomial in $N$ by direct enumeration: compute $\Opt(s)$ for all $s\in S$ and then check all pairs $(s,s')$ with $s_I=s'_I$.

Equivalently, for any fixed $I$, the projection map $s\mapsto s_I$ has image size $|S_I|\le |S|=N$, so any algorithm that iterates over projection classes (or over all state pairs) runs in polynomial time in $N$. Thus, in particular, when $k^*=O(\log N)$, SUFFICIENCY-CHECK is solvable in polynomial time under the explicit-state encoding.

\paragraph{Remark (bounded coordinate domains).} In the general model $S=\prod_i X_i$, for a fixed $I$ one always has $|S_I|\le \prod_{i\in I}|X_i|$ (and $|S_I|\le N$). If the coordinate domains are uniformly bounded, $|X_i|\le d$ for all $i$, then $|S_I|\le d^{|I|}$.

\textbf{Part 2 (Succinct ETH lower bound, worst case):} A strengthened version of the TAUTOLOGY reduction used in Theorem~\ref{thm:sufficiency-conp} produces a family of instances in which the minimal sufficient set has size $k^* = n$: given a Boolean formula $\varphi$ over $n$ variables, we construct a decision problem with $n$ coordinates such that if $\varphi$ is not a tautology then \emph{every} coordinate is decision-relevant (thus $k^*=n$). This strengthening is mechanized in Lean (see Appendix~\ref{app:lean}). Under the Exponential Time Hypothesis (ETH) \cite{impagliazzo2001complexity}, TAUTOLOGY requires time $2^{\Omega(n)}$ in the succinct encoding, so SUFFICIENCY-CHECK inherits a $2^{\Omega(n)}$ worst-case lower bound via this reduction.
\end{proof}

\begin{corollary}[Regime Separation (by Encoding)]
There is a clean separation between explicit-state tractability and succinct worst-case hardness (with respect to the encodings in Section~\ref{sec:encoding}):
\begin{itemize}
\item Under the explicit-state encoding, SUFFICIENCY-CHECK is polynomial in $N=|S|$.
\item Under ETH, there exist succinctly encoded instances with $k^* = \Omega(n)$ (indeed $k^*=n$) for which SUFFICIENCY-CHECK requires $2^{\Omega(n)}$ time.
\end{itemize}
For Boolean coordinate spaces ($N = 2^n$), the explicit-state bound is polynomial in $2^n$ (exponential in $n$), while under ETH the succinct lower bound yields $2^{\Omega(n)}$ time for the hard family in which $k^* = \Omega(n)$.
\end{corollary}

\begin{proposition}[Full Query-Access Lower Bound via Empty-Set Subproblem]\label{prop:query-regime-obstruction}
In the mechanized Boolean query regime [Q\_bool], fix $n>0$ and let $Q$ be any queried-state set with $|Q|<2^n$.
Then there exist two decision problems $\mathcal{D}_{\mathrm{yes}},\mathcal{D}_{\mathrm{no}}$ over the same state space such that:
\begin{itemize}
\item their oracle views on all states in $Q$ are identical,
\item $\emptyset$ is sufficient for $\mathcal{D}_{\mathrm{yes}}$,
\item $\emptyset$ is not sufficient for $\mathcal{D}_{\mathrm{no}}$.
\end{itemize}
Consequently, no deterministic query procedure using fewer than $2^n$ state queries can solve SUFFICIENCY-CHECK on all such instances; the worst-case query complexity is $\Omega(2^n)$.
\textit{(Lean: \nolinkurl{emptySufficiency_query_indistinguishable_pair},
\nolinkurl{constTrue_empty_sufficient},
\nolinkurl{spike_empty_not_sufficient}; obstruction-scale companion:
\nolinkurl{queryComplexityLowerBound},
\nolinkurl{exponential_query_complexity}.)}
\end{proposition}

\begin{proof}
The theorem \texttt{emptySufficiency\_query\_indistinguishable\_pair} provides, for any $|Q|<2^n$, two oracle-indistinguishable instances with opposite truth values for the $\emptyset$-sufficiency predicate. Since SUFFICIENCY-CHECK contains the $I=\emptyset$ case, any deterministic solver that queries fewer than $2^n$ states cannot be correct on both instances, yielding the $\Omega(2^n)$ worst-case query lower bound in this regime. The scale identities \texttt{queryComplexityLowerBound} and \texttt{exponential\_query\_complexity} remain as companion obstruction statements.
\end{proof}

\begin{proposition}[Value-Entry Query Lower Bound]\label{prop:query-value-entry-lb}
In the mechanized Boolean value-entry query submodel [Q\_bool], for any deterministic procedure using fewer than $2^n$ value-entry queries $(a,s)\mapsto U(a,s)$, there exist two queried-value-indistinguishable instances with opposite truth values for SUFFICIENCY-CHECK on the $I=\emptyset$ subproblem. Therefore worst-case value-entry query complexity is also $\Omega(2^n)$.
\textit{(Lean: \nolinkurl{emptySufficiency_valueEntry_indistinguishable_pair},
\nolinkurl{touchedStates_card_le_query_card}.)}
\end{proposition}

\begin{proof}
The theorem \texttt{emptySufficiency\_valueEntry\_indistinguishable\_pair} constructs, for any query set of cardinality $<2^n$, an unqueried hidden state $s_0$ and a yes/no instance pair that agree on all queried values but disagree on $\emptyset$-sufficiency. The auxiliary bound \texttt{touchedStates\_card\_le\_query\_card} ensures that fewer than $2^n$ value-entry queries cannot cover all states, so the indistinguishability argument applies in the worst case.
\end{proof}

\begin{remark}[Instantiation of Definitions~\ref{def:structural-complexity} and~\ref{def:representational-hardness}]
Theorem~\ref{thm:dichotomy} and Propositions~\ref{prop:query-regime-obstruction}--\ref{prop:query-value-entry-lb} keep the structural problem fixed (same sufficiency relation) and separate representational hardness by access regime: explicit-state access exposes the boundary $s \mapsto \Opt(s)$, query access yields $\Omega(2^n)$ lower bounds in mechanized Boolean submodels (for both `Opt` and value-entry interfaces), and succinct access can hide structure enough to force ETH-level worst-case cost on a hard family.
\end{remark}

This regime-typed landscape identifies tractability under [E], intermediate [Q\_bool] lower bounds for two oracle interfaces, and worst-case intractability under [S+ETH] for the same underlying decision relation.
