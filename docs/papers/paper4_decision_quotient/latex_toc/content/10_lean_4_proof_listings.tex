\section{Lean 4 Proof Listings}\label{app:lean}

The complete Lean 4 formalization is available in the companion artifact (Zenodo DOI listed on the title page). The mechanization consists of approximately 5,900 lines across 39 files, with 230+ theorem/lemma statements.

\subsection{What Is Machine-Checked}

The Lean formalization establishes:

\begin{enumerate}
\item \textbf{Correctness of the TAUTOLOGY reduction:} The theorem \texttt{tautology\_iff\_sufficient} proves that the mapping from Boolean formulas to decision problems preserves the decision structure (accept iff the formula is a tautology).

\item \textbf{Decision problem definitions:} Formal definitions of sufficiency, optimality, and the decision quotient.

\item \textbf{Economic theorems:} The Simplicity Tax conservation laws and hardness distribution results.
\end{enumerate}

\textbf{Complexity classifications} (coNP-completeness, $\Sigma_2^P$-completeness) follow from informal composition with standard results (TAUTOLOGY is coNP-complete, etc.). The Lean proofs verify the reduction constructions; the complexity class membership is derived by combining these with established theorems from complexity theory.

\subsection{Polynomial-Time Reduction Definition}

We use Mathlib's Turing machine framework to define polynomial-time computability:

\begin{verbatim}
/-- Polynomial-time computable function using Turing machines -/
def PolyTime {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β) 
    (f : α → β) : Prop :=
  Nonempty (Turing.TM2ComputableInPolyTime ea eb f)

/-- Polynomial-time many-one (Karp) reduction -/
def ManyOneReducesPoly {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β)
    (A : Set α) (B : Set β) : Prop :=
  ∃ f : α → β, PolyTime ea eb f ∧ ∀ x, x ∈ A ↔ f x ∈ B
\end{verbatim}

This uses the standard definition: a reduction is polynomial-time computable via Turing machines and preserves membership.

\subsection{The Main Reduction Theorem}

\begin{theorem}[TAUTOLOGY Reduction Correctness, Lean]
The reduction from TAUTOLOGY to SUFFICIENCY-CHECK is correct:
\end{theorem}

\begin{verbatim}
theorem tautology_iff_sufficient (φ : Formula n) :
    φ.isTautology ↔ (reductionProblem φ).isSufficient Finset.empty
\end{verbatim}

This theorem is proven by showing both directions:
\begin{itemize}
\item If $\varphi$ is a tautology, then the empty coordinate set is sufficient
\item If the empty coordinate set is sufficient, then $\varphi$ is a tautology
\end{itemize}

The proof verifies that the utility construction in \texttt{reductionProblem} creates the appropriate decision structure where:
\begin{itemize}
\item At reference states, \texttt{accept} is optimal with utility 1
\item At assignment states, \texttt{accept} is optimal iff $\varphi(a) = \text{true}$
\end{itemize}

\subsection{Economic Results}

The hardness distribution theorems (Section~\ref{sec:simplicity-tax}) are fully formalized:

\begin{verbatim}
theorem simplicityTax_conservation (P : SpecificationProblem)
    (S : SolutionArchitecture P) :
    S.centralDOF + simplicityTax P S ≥ P.intrinsicDOF

theorem simplicityTax_grows (P : SpecificationProblem)
    (S : SolutionArchitecture P) (n₁ n₂ : ℕ)
    (hn : n₁ < n₂) (htax : simplicityTax P S > 0) :
    totalDOF S n₁ < totalDOF S n₂

theorem native_dominates_manual (P : SpecificationProblem) (n : Nat)
    (hn : n > P.intrinsicDOF) :
    totalDOF (nativeTypeSystem P) n < totalDOF (manualApproach P) n

theorem totalDOF_eventually_constant_iff_zero_distributed
    (S : SolutionArchitecture P) :
    IsEventuallyConstant (fun n => totalDOF S n) ↔ S.distributedDOF = 0

theorem no_positive_slope_linear_represents_saturating
    (c d K : ℕ) (hd : d > 0) :
    ¬ (∀ n, c + n * d = generalizedTotalDOF c (saturatingSiteCost K) n)
\end{verbatim}

\subsection{Engineering Corollary Mapping}

\begin{center}
\small
\begin{tabular}{lll}
\toprule
\textbf{Paper handle} & \textbf{Lean theorem} & \textbf{Lean file} \\
\midrule
\texttt{cor:overmodel-diagnostic-implication} &
\texttt{DecisionQuotient.Sigma2PHardness.sufficient\_iff\_relevant\_subset} &
\texttt{DecisionQuotient/Hardness/Sigma2PHardness.lean} \\
\texttt{cor:practice-diagnostic} &
\texttt{DecisionQuotient.Sigma2PHardness.min\_sufficient\_set\_iff\_relevant\_card} &
\texttt{DecisionQuotient/Hardness/Sigma2PHardness.lean} \\
\texttt{cor:practice-bounded} &
\texttt{DecisionQuotient.sufficiency\_poly\_bounded\_actions} &
\texttt{DecisionQuotient/Tractability/BoundedActions.lean} \\
\texttt{cor:practice-structured} &
\texttt{DecisionQuotient.sufficiency\_poly\_separable} &
\texttt{DecisionQuotient/Tractability/SeparableUtility.lean} \\
\texttt{cor:practice-tree} &
\texttt{DecisionQuotient.sufficiency\_poly\_tree\_structured} &
\texttt{DecisionQuotient/Tractability/TreeStructure.lean} \\
\texttt{cor:practice-unstructured} &
\texttt{DecisionQuotient.all\_coords\_relevant\_of\_not\_tautology} &
\texttt{DecisionQuotient/Reduction\_AllCoords.lean} \\
\texttt{cor:right-wrong-hardness} &
\texttt{DecisionQuotient.HardnessDistribution.right\_dominates\_wrong} &
\texttt{DecisionQuotient/HardnessDistribution.lean} \\
\texttt{cor:type-system-threshold} &
\texttt{DecisionQuotient.HardnessDistribution.native\_dominates\_manual} &
\texttt{DecisionQuotient/HardnessDistribution.lean} \\
\texttt{cor:gap-externalization} &
\texttt{DecisionQuotient.HardnessDistribution.simplicityTax\_grows} &
\texttt{DecisionQuotient/HardnessDistribution.lean} \\
\texttt{cor:gap-minimization-hard} &
\texttt{DecisionQuotient.Sigma2PHardness.min\_sufficient\_set\_iff\_relevant\_card} &
\texttt{DecisionQuotient/Hardness/Sigma2PHardness.lean} \\
\texttt{thm:linear-saturation-iff-zero} &
\texttt{DecisionQuotient.HardnessDistribution.totalDOF\_eventually\_constant\_iff\_zero\_distributed} &
\texttt{DecisionQuotient/HardnessDistribution.lean} \\
\texttt{thm:generalized-saturation-possible} &
\texttt{DecisionQuotient.HardnessDistribution.generalizedTotal\_with\_saturation\_eventually\_constant} &
\texttt{DecisionQuotient/HardnessDistribution.lean} \\
\texttt{cor:linear-positive-no-saturation} &
\texttt{DecisionQuotient.HardnessDistribution.no\_positive\_slope\_linear\_represents\_saturating} &
\texttt{DecisionQuotient/HardnessDistribution.lean} \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Module Structure}

\begin{itemize}
\item \texttt{Basic.lean} -- Core definitions (DecisionProblem, sufficiency, optimality)
\item \texttt{Sufficiency.lean} -- Sufficiency checking algorithms and properties
\item \texttt{Reduction.lean} -- TAUTOLOGY reduction construction and correctness
\item \texttt{Complexity.lean} -- Polynomial-time reduction definitions using mathlib
\item \texttt{HardnessDistribution.lean} -- Simplicity Tax theorems
\item \texttt{Tractability/} -- Bounded actions, separable utilities, tree structure
\end{itemize}

\subsection{Verification}

The proofs compile with Lean 4 and contain no \texttt{sorry} placeholders. Run \texttt{lake build} in the proof directory to verify.
