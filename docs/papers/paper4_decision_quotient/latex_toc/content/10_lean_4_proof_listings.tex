\section{Lean 4 Proof Listings}\label{app:lean}

The complete Lean 4 formalization is available in the companion artifact (Zenodo DOI listed on the title page). The mechanization consists of \LeanTotalLines\ lines across \LeanTotalFiles\ files, with \LeanTotalTheorems\ theorem/lemma statements.

\subsection{What Is Machine-Checked}

The Lean formalization establishes:

\begin{enumerate}
\item \textbf{Correctness of the TAUTOLOGY reduction:} The theorem \texttt{tautology\_iff\_sufficient} proves that the mapping from Boolean formulas to decision problems preserves the decision structure (accept iff the formula is a tautology).

\item \textbf{Decision problem definitions:} Formal definitions of sufficiency, optimality, and the decision quotient.

\item \textbf{Economic theorems:} Simplicity Tax redistribution identities and hardness distribution results.

\item \textbf{Query-access obstruction family:} Formalized Boolean query-model constructions and exponential obstruction-scale identities (\texttt{queryComplexityLowerBound}, \texttt{exponential\_query\_complexity}).
\end{enumerate}

\textbf{Complexity classifications} (coNP-completeness, $\Sigma_2^P$-completeness) follow by conditional composition with standard results (e.g., TAUTOLOGY coNP-completeness and $\exists\forall$-SAT $\Sigma_2^P$-completeness), represented explicitly as hypotheses in the conditional transfer theorems listed below. The Lean proofs verify the reduction constructions and the transfer closures under those hypotheses.

\subsection{Polynomial-Time Reduction Definition}

We use Mathlib's Turing machine framework to define polynomial-time computability:

\begin{verbatim}
/-- Polynomial-time computable function using Turing machines -/
def PolyTime {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β) 
    (f : α → β) : Prop :=
  Nonempty (Turing.TM2ComputableInPolyTime ea eb f)

/-- Polynomial-time many-one (Karp) reduction -/
def ManyOneReducesPoly {α β : Type} (ea : FinEncoding α) (eb : FinEncoding β)
    (A : Set α) (B : Set β) : Prop :=
  ∃ f : α → β, PolyTime ea eb f ∧ ∀ x, x ∈ A ↔ f x ∈ B
\end{verbatim}

This uses the standard definition: a reduction is polynomial-time computable via Turing machines and preserves membership.

\subsection{The Main Reduction Theorem}

\begin{theorem}[TAUTOLOGY Reduction Correctness, Lean]
The reduction from TAUTOLOGY to SUFFICIENCY-CHECK is correct:
\end{theorem}

\begin{verbatim}
theorem tautology_iff_sufficient (φ : Formula n) :
    φ.isTautology ↔ (reductionProblem φ).isSufficient Finset.empty
\end{verbatim}

This theorem is proven by showing both directions:
\begin{itemize}
\item If $\varphi$ is a tautology, then the empty coordinate set is sufficient
\item If the empty coordinate set is sufficient, then $\varphi$ is a tautology
\end{itemize}

The proof verifies that the utility construction in \texttt{reductionProblem} creates the appropriate decision structure where:
\begin{itemize}
\item At reference states, \texttt{accept} is optimal with utility 1
\item At assignment states, \texttt{accept} is optimal iff $\varphi(a) = \text{true}$
\end{itemize}

\subsection{Economic Results}

The hardness distribution theorems (Section~\ref{sec:simplicity-tax}) are fully formalized:

\begin{verbatim}
theorem simplicityTax_conservation (P : SpecificationProblem)
    (S : SolutionArchitecture P) :
    S.centralDOF + simplicityTax P S ≥ P.intrinsicDOF

theorem simplicityTax_grows (P : SpecificationProblem)
    (S : SolutionArchitecture P) (n₁ n₂ : ℕ)
    (hn : n₁ < n₂) (htax : simplicityTax P S > 0) :
    totalDOF S n₁ < totalDOF S n₂

theorem native_dominates_manual (P : SpecificationProblem) (n : Nat)
    (hn : n > P.intrinsicDOF) :
    totalDOF (nativeTypeSystem P) n < totalDOF (manualApproach P) n

theorem totalDOF_eventually_constant_iff_zero_distributed
    (S : SolutionArchitecture P) :
    IsEventuallyConstant (fun n => totalDOF S n) ↔ S.distributedDOF = 0

theorem no_positive_slope_linear_represents_saturating
    (c d K : ℕ) (hd : d > 0) :
    ¬ (∀ n, c + n * d = generalizedTotalDOF c (saturatingSiteCost K) n)
\end{verbatim}

\noindent\textbf{Identifier note.}
Lean identifiers retain internal naming (\texttt{intrinsicDOF}, \texttt{simplicityTax\_conservation}); in paper terminology these correspond to \emph{baseline hardness} and the \emph{redistribution lower-bound identity}, respectively.

\subsection{Complete Claim Coverage Matrix}

\begingroup
\scriptsize
\sloppy
\setlength{\tabcolsep}{4pt}
\begin{longtable}{@{}>{\raggedright\arraybackslash}p{0.20\linewidth}>{\raggedright\arraybackslash}p{0.11\linewidth}>{\raggedright\arraybackslash}p{0.42\linewidth}>{\raggedright\arraybackslash}p{0.23\linewidth}@{}}
\toprule
\textbf{Paper handle} & \textbf{Status} & \textbf{Lean support} & \textbf{Notes} \\
\midrule
\nolinkurl{cor:exact-identifiability} & Full &
\nolinkurl{Sigma2PHardness.exactlyIdentifiesRelevant_iff_sufficient_and_subset_relevantFinset} & Direct theorem mapping. \\
\nolinkurl{cor:gap-externalization} & Full &
\nolinkurl{HardnessDistribution.totalExternalWork_eq_n_mul_gapCard}, \nolinkurl{HardnessDistribution.simplicityTax_grows} & Composite from two mechanized theorems. \\
\nolinkurl{cor:gap-minimization-hard} & Full &
\nolinkurl{Sigma2PHardness.min_sufficient_set_iff_relevant_card} & Direct theorem mapping. \\
\nolinkurl{cor:generalized-eventual-dominance} & Full &
\nolinkurl{HardnessDistribution.generalized_right_eventually_dominates_wrong} & Direct theorem mapping. \\
\nolinkurl{cor:linear-positive-no-saturation} & Full &
\nolinkurl{HardnessDistribution.no_positive_slope_linear_represents_saturating} & Direct theorem mapping. \\
\nolinkurl{cor:no-auto-minimize} & Full (conditional) &
\nolinkurl{ClaimClosure.no_auto_minimize_of_p_neq_conp} &
Mechanized conditional closure: non-collapse plus collapse-implication yields impossibility. \\
\nolinkurl{cor:overmodel-diagnostic-implication} & Full &
\nolinkurl{Sigma2PHardness.sufficient_iff_relevant_subset} & Contrapositive of mechanized theorem. \\
\nolinkurl{cor:practice-bounded} & Full &
\nolinkurl{sufficiency_poly_bounded_actions} & Direct theorem mapping. \\
\nolinkurl{cor:practice-diagnostic} & Full &
\nolinkurl{Sigma2PHardness.min_sufficient_set_iff_relevant_card} & Direct theorem mapping. \\
\nolinkurl{cor:practice-structured} & Full &
\nolinkurl{sufficiency_poly_separable} & Direct theorem mapping. \\
\nolinkurl{cor:practice-tree} & Full &
\nolinkurl{sufficiency_poly_tree_structured} & Direct theorem mapping. \\
\nolinkurl{cor:practice-unstructured} & Full &
\nolinkurl{all_coords_relevant_of_not_tautology} & Direct theorem mapping. \\
\nolinkurl{cor:right-wrong-hardness} & Full &
\nolinkurl{HardnessDistribution.right_dominates_wrong} & Direct theorem mapping. \\
\nolinkurl{cor:type-system-threshold} & Full &
\nolinkurl{HardnessDistribution.native_dominates_manual} & Direct theorem mapping. \\
\nolinkurl{prop:adq-ordering} & Full &
\nolinkurl{ClaimClosure.adq_ordering} &
Strict ordering theorem for shared nonempty behavior denominator. \\
\nolinkurl{prop:dominance-modes} & Full &
\nolinkurl{HardnessDistribution.right_dominates_wrong}, \nolinkurl{HardnessDistribution.centralized_higher_leverage}, \nolinkurl{HardnessDistribution.generalized_right_dominates_wrong_of_bounded_vs_identity_lower}, \nolinkurl{HardnessDistribution.generalized_dominance_can_fail_without_wrong_growth}, \nolinkurl{HardnessDistribution.generalized_dominance_can_fail_without_right_boundedness} & Compositional index proposition. \\
\nolinkurl{prop:generalized-assumption-boundary} & Full &
\nolinkurl{HardnessDistribution.generalized_dominance_can_fail_without_wrong_growth}, \nolinkurl{HardnessDistribution.generalized_dominance_can_fail_without_right_boundedness} & Direct pair mapping. \\
\nolinkurl{prop:hardness-conservation} & Full &
\nolinkurl{HardnessDistribution.totalDOF_ge_intrinsic} & Direct structural core theorem. \\
\nolinkurl{prop:hardness-efficiency-interpretation} & Full &
\nolinkurl{HardnessDistribution.hardnessEfficiency_eq_central_share} & Direct definitional equivalence. \\
\nolinkurl{prop:integrity-competence-separation} & Full &
\nolinkurl{IntegrityCompetence.competence_implies_integrity}, \nolinkurl{IntegrityCompetence.integrity_not_competent_of_nonempty_scope} & Direct pair mapping. \\
\nolinkurl{prop:minimal-relevant-equiv} & Full &
\nolinkurl{DecisionProblem.minimalSufficient_iff_relevant}, \nolinkurl{DecisionProblem.relevantSet_is_minimal} &
Product-space bridge: minimal sufficient sets coincide with the witness-defined relevance set. \\
\nolinkurl{prop:query-regime-obstruction} & Full &
\nolinkurl{queryComplexityLowerBound}, \nolinkurl{exponential_query_complexity}, \nolinkurl{exists_distinct_patterns} &
Mechanized Boolean query-regime obstruction family and exponential scale identity in $|I|$. \\
\nolinkurl{prop:set-to-selector} & Full &
\nolinkurl{DecisionProblem.sufficient_implies_selectorSufficient} &
Set-valued sufficiency implies selector-level sufficiency for any deterministic selector. \\
\nolinkurl{prop:attempted-competence-matrix} & Full &
\nolinkurl{IntegrityCompetence.overModelVerdict_rational_iff}, \nolinkurl{IntegrityCompetence.admissible_matrix_counts}, \nolinkurl{IntegrityCompetence.admissible_irrational_strictly_more_than_rational} &
Integrity-preserving matrix is mechanized: one rational admissible cell and three irrational admissible cells. \\
\nolinkurl{prop:bridge-transfer-scope} & Full &
\nolinkurl{ClaimClosure.one_step_bridge} &
Transfer rule follows from the one-step deterministic bridge equivalence. \\
\nolinkurl{prop:one-step-bridge} & Full &
\nolinkurl{ClaimClosure.one_step_bridge} &
One-step deterministic bridge is mechanized as an equivalence of sufficiency predicates. \\
\nolinkurl{prop:sufficiency-char} & Full &
\nolinkurl{ClaimClosure.sufficiency_iff_dq_ratio}, \nolinkurl{ClaimClosure.sufficiency_iff_projectedOptCover_eq_opt} &
Finite-model quotient characterization mechanized in both ratio form and projected-cover form. \\
\nolinkurl{thm:amortization} & Full &
\nolinkurl{HardnessDistribution.complete_model_dominates_after_threshold} & Direct theorem mapping. \\
\nolinkurl{thm:anchor-sigma2p} & Full (conditional) &
\nolinkurl{ClaimClosure.anchor_sigma2p_reduction_core}, \nolinkurl{ClaimClosure.anchor_sigma2p_complete_conditional}, \nolinkurl{anchor_sufficiency_sigma2p} &
Reduction core is mechanized; completeness lift is mechanized as a conditional transfer on standard source-class facts. \\
\nolinkurl{thm:centralization-dominance} & Full &
\nolinkurl{HardnessDistribution.centralization_dominance_bundle}, \nolinkurl{HardnessDistribution.centralization_step_saves_n_minus_one} & Direct pair mapping. \\
\nolinkurl{thm:config-reduction} & Full &
\nolinkurl{ConfigReduction.config_sufficiency_iff_behavior_preserving} & Direct theorem mapping. \\
\nolinkurl{thm:cost-asymmetry-eth} & Full (conditional) &
\nolinkurl{ClaimClosure.cost_asymmetry_eth_conditional}, \nolinkurl{HardnessDistribution.linear_lt_exponential_plus_constant_eventually} &
Asymptotic dominance and ETH-conditioned lift are both mechanized. \\
\nolinkurl{thm:dichotomy} & Full (conditional) &
\nolinkurl{ClaimClosure.dichotomy_conditional}, \nolinkurl{ClaimClosure.hard_family_all_coords_core}, \nolinkurl{ClaimClosure.explicit_state_upper_core} &
Upper-branch core and hard-family core are mechanized; ETH lower branch is mechanized as conditional transfer. \\
\nolinkurl{thm:generalized-dominance} & Full &
\nolinkurl{HardnessDistribution.generalized_right_dominates_wrong_of_bounded_vs_identity_lower} & Direct theorem mapping. \\
\nolinkurl{thm:generalized-saturation-possible} & Full &
\nolinkurl{HardnessDistribution.saturatingSiteCost_eventually_constant}, \nolinkurl{HardnessDistribution.generalizedTotal_with_saturation_eventually_constant} & Direct construction mapping. \\
\nolinkurl{thm:linear-saturation-iff-zero} & Full &
\nolinkurl{HardnessDistribution.totalDOF_eventually_constant_iff_zero_distributed} & Direct theorem mapping. \\
\nolinkurl{thm:minsuff-collapse} & Full (conditional) &
\nolinkurl{ClaimClosure.minsuff_collapse_core}, \nolinkurl{ClaimClosure.minsuff_collapse_to_conp_conditional}, \nolinkurl{Sigma2PHardness.min_sufficient_set_iff_relevant_card} &
Quantifier collapse core and coNP-reading lift are mechanized. \\
\nolinkurl{thm:minsuff-conp} & Full (conditional) &
\nolinkurl{ClaimClosure.minsuff_collapse_core}, \nolinkurl{ClaimClosure.minsuff_conp_complete_conditional} &
coNP-completeness transfer is mechanized conditionally from the collapse core. \\
\nolinkurl{thm:overmodel-diagnostic} & Full &
\nolinkurl{ClaimClosure.no_exact_identifier_implies_not_boundary_characterized}, \nolinkurl{ClaimClosure.boundaryCharacterized_iff_exists_sufficient_subset}, \nolinkurl{ConfigReduction.config_sufficiency_iff_behavior_preserving} &
Contrapositive diagnostic step mechanized under explicit boundary-characterization definition. \\
\nolinkurl{thm:sufficiency-conp} & Full (conditional) &
\nolinkurl{ClaimClosure.sufficiency_conp_reduction_core}, \nolinkurl{ClaimClosure.sufficiency_conp_complete_conditional}, \nolinkurl{tautology_iff_sufficient} &
Reduction core and coNP-completeness transfer are mechanized conditionally. \\
\nolinkurl{thm:tax-conservation} & Full &
\nolinkurl{HardnessDistribution.gap_conservation_card} & Direct theorem mapping. \\
\nolinkurl{thm:tax-grows} & Full &
\nolinkurl{HardnessDistribution.totalExternalWork_eq_n_mul_gapCard} & Direct theorem mapping. \\
\nolinkurl{thm:tractable} & Full (conditional) &
\nolinkurl{ClaimClosure.tractable_bounded_core}, \nolinkurl{ClaimClosure.tractable_separable_core}, \nolinkurl{ClaimClosure.tractable_tree_core}, \nolinkurl{ClaimClosure.tractable_subcases_conditional} &
All three tractable branch cores and assembly closure are mechanized. \\
\bottomrule
\end{longtable}
\endgroup

\subsection{Claims Not Fully Mechanized}

\textbf{Status:} all theorem/proposition/corollary handles in this paper now have Lean backing.
Entries marked \textbf{Full (conditional)} are explicitly mechanized transfer theorems that depend on standard external complexity facts (e.g., source-class completeness or ETH assumptions), with those dependencies represented as hypotheses in Lean.

\subsection{Module Structure}

\begin{itemize}
\item \texttt{Basic.lean} -- Core definitions (DecisionProblem, sufficiency, optimality)
\item \texttt{Sufficiency.lean} -- Sufficiency checking algorithms and properties
\item \texttt{Reduction.lean} -- TAUTOLOGY reduction construction and correctness
\item \texttt{Hardness/ConfigReduction.lean} -- Sentinel-action configuration reduction theorem
\item \texttt{Complexity.lean} -- Polynomial-time reduction definitions using mathlib
\item \texttt{HardnessDistribution.lean} -- Simplicity Tax redistribution and amortization theorems
\item \texttt{IntegrityCompetence.lean} -- Solver integrity vs regime competence separation
\item \texttt{ClaimClosure.lean} -- Mechanized closure of paper-level bridge and diagnostic claims
\item \texttt{Tractability/} -- Bounded actions, separable utilities, tree structure
\end{itemize}

\subsection{Verification}

The proofs compile with Lean 4 and contain no \texttt{sorry} placeholders. Run \texttt{lake build} in the proof directory to verify.
