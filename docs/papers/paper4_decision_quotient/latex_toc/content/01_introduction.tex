\section{Introduction}\label{sec:introduction}

Consider a decision problem with actions $A$ and states $S = X_1 \times \cdots \times X_n$. A coordinate set $I \subseteq \{1, \ldots, n\}$ is \emph{sufficient} if knowing only coordinates in $I$ determines the optimal action:
\[
s_I = s'_I \implies \Opt(s) = \Opt(s')
\]

This paper characterizes the efficient cases of coordinate sufficiency within the formal model:

Section~\ref{sec:encoding} fixes the computational model and input encodings used for all complexity claims.

\begin{center}
\begin{tabularx}{\linewidth}{@{}llX@{}}
\toprule
\textbf{Problem} & \textbf{Complexity} & \textbf{When Tractable} \\
\midrule
SUFFICIENCY-CHECK & \coNP-complete & Bounded actions (explicit-state), separable utility, tree-structured utility \\
MINIMUM-SUFFICIENT-SET & \coNP-complete & Same conditions \\
ANCHOR-SUFFICIENCY & $\SigmaP{2}$-complete & Open \\
\bottomrule
\end{tabularx}
\end{center}

The tractable cases are stated with explicit encoding assumptions (Section~\ref{sec:encoding}). Outside those regimes, the succinct model yields hardness.

\subsection{Landscape Summary}

\textbf{When is sufficiency checking tractable?} We identify three sufficient conditions:

\begin{enumerate}
\item \textbf{Bounded actions} ($|A| \leq k$) under explicit-state encoding: with constantly many actions, we enumerate action pairs over the explicit utility table.

\item \textbf{Separable utility} ($u(a,s) = f(a) + g(s)$): The optimal action depends only on $f$, making all coordinates irrelevant to the decision.

\item \textbf{Tree-structured utility}: With explicit local factors over a tree, dynamic programming yields polynomial algorithms in the input length.
\end{enumerate}

Each condition is stated with its encoding assumption. Outside these regimes, the general problem remains \coNP-hard (Theorem~\ref{thm:sufficiency-conp}).

\textbf{When is it intractable?} The general problem is \coNP-complete (Theorem~\ref{thm:sufficiency-conp}), with a separation between explicit-state tractability and succinct worst-case hardness:
\begin{itemize}
\item In the explicit-state model: SUFFICIENCY-CHECK is solvable in polynomial time in $|S|$ by explicitly computing $\Opt(s)$ for all $s\in S$ and checking all pairs $(s,s')$ with equal $I$-projection. In particular, instances with $k^* = O(\log |S|)$ are tractable in this model.
\item In the succinct model: under ETH there exist worst-case instances produced by our strengthened gadget in which the minimal sufficient set has size $\Omega(n)$ (indeed $n$) and SUFFICIENCY-CHECK requires $2^{\Omega(n)}$ time.
\end{itemize}

The lower-bound statement does not address intermediate regimes.

\subsection{Main Theorems}

\begin{enumerate}
\item \textbf{Theorem~\ref{thm:sufficiency-conp}:} SUFFICIENCY-CHECK is \coNP-complete via reduction from TAUTOLOGY.

\item \textbf{Theorem~\ref{thm:minsuff-conp}:} MINIMUM-SUFFICIENT-SET is \coNP-complete (the $\SigmaP{2}$ structure collapses).

\item \textbf{Theorem~\ref{thm:anchor-sigma2p}:} ANCHOR-SUFFICIENCY is $\SigmaP{2}$-complete via reduction from $\exists\forall$-SAT.

\item \textbf{Theorem~\ref{thm:dichotomy}:} Encoding-regime separation: explicit-state polynomial-time (polynomial in $|S|$), and under ETH a succinct worst-case lower bound witnessed by a hard family with $k^* = n$.
 
% NOTE: Theorem \ref{thm:dichotomy} is an encoding-regime separation; the succinct-side statement is worst-case (there exists a hard family with $k^*=n$).

\item \textbf{Theorem~\ref{thm:tractable}:} Polynomial algorithms for bounded actions, separable utility, tree structure.
\end{enumerate}

\subsection{Machine-Checked Proofs}

The reduction constructions and key equivalence theorems are machine-checked in Lean 4 \cite{moura2021lean4} ($\sim$5,000 lines, 200+ theorems). The formalization verifies that the TAUTOLOGY reduction correctly maps tautologies to sufficient coordinate sets. Complexity class membership (coNP-completeness, $\Sigma_2^P$-completeness) follows by composition with standard complexity-theoretic results.

\paragraph{What is new.}
We contribute (i) formal definitions of decision-theoretic sufficiency in Lean; (ii) machine-checked proofs of reduction correctness for the TAUTOLOGY and $\exists\forall$-SAT reductions; and (iii) a complete complexity landscape for coordinate sufficiency with explicit encoding assumptions. Prior work establishes hardness informally; we formalize the constructions.

\subsection{Paper Structure}

The primary contribution is theoretical: a formalized reduction framework and a complete characterization of the core decision-relevant problems in the formal model (coNP/\(\Sigma_2^P\) completeness and tractable cases stated under explicit encoding assumptions). Sections~\ref{sec:hardness}--\ref{sec:tractable} contain the core theorems.

Section~\ref{sec:foundations}: foundations. Section~\ref{sec:hardness}: hardness proofs. Section~\ref{sec:dichotomy}: dichotomy. Section~\ref{sec:tractable}: tractable cases. Sections~\ref{sec:implications} and~\ref{sec:simplicity-tax}: corollaries and implications for practice. Section~\ref{sec:related}: related work. Appendix~\ref{app:lean}: Lean listings.
