\section{Introduction}\label{sec:introduction}

Consider a decision problem with actions $A$ and states $S = X_1 \times \cdots \times X_n$. A coordinate set $I \subseteq \{1, \ldots, n\}$ is \emph{sufficient} if knowing only coordinates in $I$ determines the optimal action:
\[
s_I = s'_I \implies \Opt(s) = \Opt(s')
\]

This paper characterizes the efficient cases of coordinate sufficiency within the formal model:

Section~\ref{sec:encoding} fixes the computational model and input encodings used for all complexity claims.
Section~\ref{sec:model-contract} gives the model contract and regime tags used to type every strong claim.

\begin{center}
\begin{tabularx}{\linewidth}{@{}llX@{}}
\toprule
\textbf{Problem} & \textbf{Complexity} & \textbf{When Tractable} \\
\midrule
SUFFICIENCY-CHECK & \coNP-complete & Bounded actions (explicit-state), separable utility, tree-structured utility \\
MINIMUM-SUFFICIENT-SET & \coNP-complete & Same conditions \\
ANCHOR-SUFFICIENCY & $\SigmaP{2}$-complete & Open \\
\bottomrule
\end{tabularx}
\end{center}

The tractable cases are stated with explicit encoding assumptions (Section~\ref{sec:encoding}). Outside those regimes, the succinct model yields hardness.

\subsection{Hardness--Recovery Reading Map}

Theorems in this paper are intended to be read as hardness/recovery pairs for the same fixed decision relation:
\begin{enumerate}
\item \textbf{Sufficiency checking:} [S] coNP-complete in the general succinct regime (Theorem~\ref{thm:sufficiency-conp}), paired with polynomial-time recovery under explicit-state and structured-access regimes (Theorem~\ref{thm:tractable}).
\item \textbf{Minimal sufficient sets:} [S] coNP-complete in general (Theorem~\ref{thm:minsuff-conp}), paired with the collapse criterion and relevance-computation recovery route (Theorems~\ref{thm:minsuff-collapse}, \ref{thm:tractable}).
\item \textbf{Anchor sufficiency:} $\SigmaP{2}$-complete in the general anchored formulation (Theorem~\ref{thm:anchor-sigma2p}); no general polynomial-time recovery condition is established in this model.
\end{enumerate}
\textit{(Lean anchors for this map: \nolinkurl{ClaimClosure.sufficiency_conp_complete_conditional},
\nolinkurl{ClaimClosure.minsuff_conp_complete_conditional},
\nolinkurl{ClaimClosure.minsuff_collapse_core},
\nolinkurl{ClaimClosure.anchor_sigma2p_complete_conditional},
\nolinkurl{ClaimClosure.tractable_subcases_conditional},
\nolinkurl{Sigma2PHardness.min_sufficient_set_iff_relevant_card}.)}

An operational criterion follows later from the same chain: once decision-site count exceeds the amortization threshold \(n^*\), avoiding structural identification is more expensive than paying the one-time centralization cost (Theorem~\ref{thm:amortization}).
\textit{(Lean: \nolinkurl{HardnessDistribution.complete_model_dominates_after_threshold},
\nolinkurl{HardnessDistribution.totalExternalWork_eq_n_mul_gapCard}.)}

\subsection{Landscape Summary}

\textbf{When is sufficiency checking tractable?} We identify three sufficient conditions:

\begin{enumerate}
\item \textbf{Bounded actions} ($|A| \leq k$) under explicit-state encoding: with constantly many actions, we enumerate action pairs over the explicit utility table.

\item \textbf{Separable utility} ($U(a,s) = f(a) + g(s)$): The optimal action depends only on $f$, making all coordinates irrelevant to the decision.

\item \textbf{Tree-structured utility}: With explicit local factors over a tree, dynamic programming yields polynomial algorithms in the input length.
\end{enumerate}

Each condition is stated with its encoding assumption. Outside these regimes, the general problem remains \coNP-hard (Theorem~\ref{thm:sufficiency-conp}).

\textbf{When is it intractable?} The general problem is \coNP-complete (Theorem~\ref{thm:sufficiency-conp}), with a separation between explicit-state tractability and succinct worst-case hardness:
\begin{itemize}
\item In the explicit-state model: SUFFICIENCY-CHECK is solvable in polynomial time in $|S|$ by explicitly computing $\Opt(s)$ for all $s\in S$ and checking all pairs $(s,s')$ with equal $I$-projection. In particular, instances with $k^* = O(\log |S|)$ are tractable in this model.
\item In the intermediate query-access model: the mechanized Boolean submodels yield full worst-case lower bounds $\Omega(2^n)$ for SUFFICIENCY-CHECK for both the `Opt`-oracle interface and the value-entry interface $(a,s)\mapsto U(a,s)$ (Propositions~\ref{prop:query-regime-obstruction}, \ref{prop:query-value-entry-lb}).
\item In the succinct model: under ETH there exist worst-case instances produced by our strengthened gadget in which the minimal sufficient set has size $\Omega(n)$ (indeed $n$) and SUFFICIENCY-CHECK requires $2^{\Omega(n)}$ time.
\end{itemize}

The explicit ETH lower bound is still a succinct worst-case statement; Propositions~\ref{prop:query-regime-obstruction} and~\ref{prop:query-value-entry-lb} strengthen the intermediate-regime treatment with theorem-level query lower bounds in mechanized Boolean oracle models.

\subsection{Main Theorems}

\begin{enumerate}
\item \textbf{Theorem~\ref{thm:sufficiency-conp}:} SUFFICIENCY-CHECK is \coNP-complete via reduction from TAUTOLOGY.

\item \textbf{Theorem~\ref{thm:minsuff-conp}:} MINIMUM-SUFFICIENT-SET is \coNP-complete (the $\SigmaP{2}$ structure collapses).

\item \textbf{Theorem~\ref{thm:anchor-sigma2p}:} ANCHOR-SUFFICIENCY is $\SigmaP{2}$-complete via reduction from $\exists\forall$-SAT.

\item \textbf{Theorem~\ref{thm:dichotomy}:} Encoding-regime separation: explicit-state polynomial-time (polynomial in $|S|$), and under ETH a succinct worst-case lower bound witnessed by a hard family with $k^* = n$.
 
% NOTE: Theorem \ref{thm:dichotomy} is an encoding-regime separation; the succinct-side statement is worst-case (there exists a hard family with $k^*=n$).

\item \textbf{Theorem~\ref{thm:tractable}:} Polynomial algorithms for bounded actions, separable utility, tree structure.
\end{enumerate}

\subsection{Machine-Checked Proofs}

The reduction constructions and key equivalence theorems are machine-checked in Lean 4 \cite{moura2021lean4} (\LeanTotalLines\ lines, \LeanTotalTheorems\ theorem/lemma statements). The formalization verifies that the TAUTOLOGY reduction correctly maps tautologies to sufficient coordinate sets. Complexity class membership (coNP-completeness, $\Sigma_2^P$-completeness) follows by composition with standard complexity-theoretic results.

\paragraph{What is new.}
We contribute (i) formal definitions of decision-theoretic sufficiency in Lean; (ii) machine-checked proofs of reduction correctness for the TAUTOLOGY and $\exists\forall$-SAT reductions; (iii) a complete complexity landscape for coordinate sufficiency with explicit encoding assumptions; and (iv) a formal separation between structural complexity and representational hardness used to derive theorem-indexed engineering corollaries. Prior work establishes hardness informally; we formalize the constructions and their regime-typed consequences.

\subsection{Paper Structure}

The primary contribution is theoretical: a formalized reduction framework and a complete characterization of the core decision-relevant problems in the formal model (coNP/\(\Sigma_2^P\) completeness and tractable cases stated under explicit encoding assumptions). A second contribution is formal claim typing: Section~\ref{sec:interpretive-foundations} introduces the structural/representational and integrity/competence splits that type-check the applied corollaries.

Section~\ref{sec:foundations}: decision-problem foundations and encoding model. Section~\ref{sec:interpretive-foundations}: structural vs representational hardness; integrity vs competence. Section~\ref{sec:hardness}: hardness proofs. Section~\ref{sec:dichotomy}: regime separation. Section~\ref{sec:tractable}: tractable cases. Section~\ref{sec:engineering-justification}: engineering corollaries by regime. Section~\ref{sec:implications}: software architecture corollaries. Section~\ref{sec:simplicity-tax}: complexity redistribution corollary. Section~\ref{sec:related}: related work. Appendix~\ref{app:lean}: Lean listings.
