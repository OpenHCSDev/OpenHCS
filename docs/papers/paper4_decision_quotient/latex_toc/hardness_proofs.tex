\section{Computational Complexity of Decision-Relevant Uncertainty}
\label{sec:hardness}

This section establishes the computational complexity of determining which state coordinates are decision-relevant. We prove three main results:

\begin{enumerate}
    \item \textbf{SUFFICIENCY-CHECK} is coNP-complete
    \item \textbf{MINIMUM-SUFFICIENT-SET} is coNP-complete (the $\Sigma_2^P$ structure collapses)
    \item \textbf{ANCHOR-SUFFICIENCY} (fixed coordinates) is $\Sigma_2^P$-complete
\end{enumerate}

Under the model contract of Section~\ref{sec:model-contract} and the succinct encoding of Section~\ref{sec:encoding}, these results place exact relevance identification beyond NP-completeness: in the worst case, finding (or certifying) minimal decision-relevant sets is computationally intractable.

\paragraph{Reading convention for this section.}
Each hardness theorem below is paired with a recovery boundary for the same decision relation: when structural-access assumptions in Theorem~\ref{thm:tractable} hold, polynomial-time exact procedures are recovered; when they fail in [S], the stated hardness applies.
\textit{(Lean map handles: \nolinkurl{ClaimClosure.sufficiency_conp_complete_conditional},
\nolinkurl{ClaimClosure.minsuff_conp_complete_conditional},
\nolinkurl{ClaimClosure.anchor_sigma2p_complete_conditional},
\nolinkurl{ClaimClosure.tractable_subcases_conditional}.)}

\subsection{Problem Definitions}

\begin{definition}[Decision Problem Encoding]
A \emph{decision problem instance} is a tuple $(A, X_1, \ldots, X_n, U)$ where:
\begin{itemize}
    \item $A$ is a finite set of alternatives
    \item $X_1, \ldots, X_n$ are the coordinate domains, with state space $S = X_1 \times \cdots \times X_n$
    \item $U: A \times S \to \mathbb{Q}$ is the utility function (in the succinct encoding, $U$ is given as a Boolean circuit)
\end{itemize}
\end{definition}

\begin{definition}[Optimizer Map]
For state $s \in S$, define:
\[
\text{Opt}(s) := \arg\max_{a \in A} U(a, s)
\]
\end{definition}

\begin{definition}[Sufficient Coordinate Set]
A coordinate set $I \subseteq \{1, \ldots, n\}$ is \emph{sufficient} if:
\[
\forall s, s' \in S: \quad s_I = s'_I \implies \text{Opt}(s) = \text{Opt}(s')
\]
where $s_I$ denotes the projection of $s$ onto coordinates in $I$.
\end{definition}

\begin{problem}[SUFFICIENCY-CHECK]
\textbf{Input:} Decision problem $(A, X_1, \ldots, X_n, U)$ and coordinate set $I \subseteq \{1,\ldots,n\}$ \\
\textbf{Question:} Is $I$ sufficient?
\end{problem}

\begin{problem}[MINIMUM-SUFFICIENT-SET]
\textbf{Input:} Decision problem $(A, X_1, \ldots, X_n, U)$ and integer $k$ \\
\textbf{Question:} Does there exist a sufficient set $I$ with $|I| \leq k$?
\end{problem}

\subsection{Hardness of SUFFICIENCY-CHECK}

\begin{theorem}[coNP-completeness of SUFFICIENCY-CHECK]
\label{thm:sufficiency-conp}
SUFFICIENCY-CHECK is coNP-complete \cite{cook1971complexity, karp1972reducibility}.
\textit{(Lean handles: \nolinkurl{ClaimClosure.sufficiency_conp_reduction_core},
\nolinkurl{ClaimClosure.sufficiency_conp_complete_conditional},
\nolinkurl{tautology_iff_sufficient}.)}
\end{theorem}

\begin{center}
\begin{tabular}{lll}
\toprule
Source & Target & Key property preserved \\
\midrule
TAUTOLOGY & SUFFICIENCY-CHECK & Tautology iff $\emptyset$ sufficient \\
$\exists\forall$-SAT & ANCHOR-SUFFICIENCY & Witness anchors iff formula true \\
\bottomrule
\end{tabular}
\end{center}

\begin{proof}
\textbf{Membership in coNP:} The complementary problem INSUFFICIENCY is in NP. Given a decision problem $(A, X_1, \ldots, X_n, U)$ and coordinate set $I$, a witness for insufficiency is a pair $(s, s')$ such that:
\begin{enumerate}
    \item $s_I = s'_I$ (verifiable in polynomial time)
    \item $\text{Opt}(s) \neq \text{Opt}(s')$ (verifiable by evaluating $U$ on all alternatives)
\end{enumerate}

\textbf{coNP-hardness:} We reduce from TAUTOLOGY.

Given Boolean formula $\varphi(x_1, \ldots, x_n)$, construct a decision problem with:
\begin{itemize}
    \item Alternatives: $A = \{\text{accept}, \text{reject}\}$
    \item State space: $S = \{\text{reference}\} \cup \{0,1\}^n$ (equivalently, encode this as a product space with one extra coordinate $r \in \{0,1\}$ indicating whether the state is the reference state)
    \item Utility:
    \begin{align*}
        U(\text{accept}, \text{reference}) &= 1 \\
        U(\text{reject}, \text{reference}) &= 0 \\
        U(\text{accept}, a) &= \varphi(a) \\
        U(\text{reject}, a) &= 0 \quad \text{for assignments } a \in \{0,1\}^n
    \end{align*}
    \item Query set: $I = \emptyset$
\end{itemize}

\textbf{Claim:} $I = \emptyset$ is sufficient $\iff$ $\varphi$ is a tautology.

($\Rightarrow$) Suppose $I$ is sufficient. Then $\text{Opt}(s)$ is constant over all states. Since $U(\text{accept}, a) = \varphi(a)$ and $U(\text{reject}, a) = 0$:
\begin{itemize}
    \item $\text{Opt}(a) = \text{accept}$ when $\varphi(a) = 1$
    \item $\text{Opt}(a) = \{\text{accept}, \text{reject}\}$ when $\varphi(a) = 0$
\end{itemize}
For $\text{Opt}$ to be constant, $\varphi(a)$ must be true for all assignments $a$; hence $\varphi$ is a tautology.

($\Leftarrow$) If $\varphi$ is a tautology, then $U(\text{accept}, a) = 1 > 0 = U(\text{reject}, a)$ for all assignments $a$. Thus $\text{Opt}(s) = \{\text{accept}\}$ for all states $s$, making $I = \emptyset$ sufficient.
\end{proof}

\paragraph{Immediate recovery boundary (SUFFICIENCY-CHECK).}
Theorem~\ref{thm:sufficiency-conp} is the [S] general-case hardness statement. For the same sufficiency relation, Theorem~\ref{thm:tractable} gives polynomial-time recovery under explicit-state, separable, and tree-structured regimes.
\textit{(Lean bridge handles: \nolinkurl{ClaimClosure.sufficiency_conp_complete_conditional},
\nolinkurl{ClaimClosure.tractable_subcases_conditional},
\nolinkurl{ClaimClosure.tractable_bounded_core},
\nolinkurl{ClaimClosure.tractable_separable_core},
\nolinkurl{ClaimClosure.tractable_tree_core}.)}

\paragraph{Mechanized strengthening (all coordinates relevant).}
The reduction above establishes coNP-hardness using a single witness set $I=\emptyset$. For the ETH-based lower bound in Theorem~\ref{thm:dichotomy}, we additionally need worst-case instances where the minimal sufficient set has \emph{linear} size.

We formalized a strengthened reduction in Lean 4: given a Boolean formula $\varphi$ over $n$ variables, construct a decision problem with $n$ coordinates such that if $\varphi$ is not a tautology then \emph{every} coordinate is decision-relevant (so $k^* = n$). Intuitively, the construction places a copy of the base gadget at each coordinate and makes the global ``accept'' condition hold only when every coordinate's local test succeeds; a single falsifying assignment at one coordinate therefore changes the global optimal set, witnessing that coordinate's relevance. This strengthening is mechanized in Lean; see Appendix~\ref{app:lean}.

\subsection{Complexity of MINIMUM-SUFFICIENT-SET}

\begin{theorem}[MINIMUM-SUFFICIENT-SET is coNP-complete]
\label{thm:minsuff-conp}
MINIMUM-SUFFICIENT-SET is coNP-complete.
\textit{(Lean handles: \nolinkurl{ClaimClosure.minsuff_collapse_core},
\nolinkurl{ClaimClosure.minsuff_conp_complete_conditional}.)}
\end{theorem}

\begin{proof}
\textbf{Structural observation:} The $\exists\forall$ quantifier pattern suggests $\Sigma_2^P$:
\[
\exists I \, (|I| \leq k) \; \forall s, s' \in S: \quad s_I = s'_I \implies \text{Opt}(s) = \text{Opt}(s')
\]
However, this collapses because sufficiency has a simple characterization.

\textbf{Key lemma:} In the Boolean-coordinate collapse model, a coordinate set $I$ is sufficient if and only if $I$ contains all relevant coordinates (proven formally as \texttt{sufficient\_iff\_relevant\_subset} / \texttt{sufficient\_iff\_relevantFinset\_subset} in Lean):
\[
\text{sufficient}(I) \iff \text{Relevant} \subseteq I
\]
where $\text{Relevant} = \{i : \exists s, s'.\; s \text{ differs from } s' \text{ only at } i \text{ and } \text{Opt}(s) \neq \text{Opt}(s')\}$.
This is the same relevance object as Definition~\ref{def:relevant}; Proposition~\ref{prop:minimal-relevant-equiv} gives the minimal-set equivalence in the product-space semantics used by the collapse.

\textbf{Consequence:} The minimum sufficient set is exactly the relevant-coordinate set. Thus MINIMUM-SUFFICIENT-SET asks: ``Is the number of relevant coordinates at most $k$?''

\textbf{coNP membership:} A witness that the answer is NO is a set of $k+1$ coordinates, each proven relevant (by exhibiting $s, s'$ pairs). Verification is polynomial.

\textbf{coNP-hardness:} The $k=0$ case asks whether no coordinates are relevant, i.e., whether $\emptyset$ is sufficient. This is exactly SUFFICIENCY-CHECK, which is coNP-complete by Theorem~\ref{thm:sufficiency-conp}.
\end{proof}

\paragraph{Immediate recovery boundary (MINIMUM-SUFFICIENT-SET).}
Theorem~\ref{thm:minsuff-conp} pairs with Theorem~\ref{thm:minsuff-collapse}: exact minimization complexity is governed by relevance-cardinality once the collapse is applied. Recovery then depends on computing relevance efficiently, with structured-access assumptions from Theorem~\ref{thm:tractable} giving the corresponding route for the underlying sufficiency computations.
\textit{(Lean bridge handles: \nolinkurl{ClaimClosure.minsuff_conp_complete_conditional},
\nolinkurl{ClaimClosure.minsuff_collapse_core},
\nolinkurl{ClaimClosure.minsuff_collapse_to_conp_conditional},
\nolinkurl{Sigma2PHardness.min_sufficient_set_iff_relevant_card},
\nolinkurl{ClaimClosure.tractable_subcases_conditional}.)}

\subsection{Anchor Sufficiency (Fixed Coordinates)}

We also formalize a strengthened variant that fixes the coordinate set and asks whether
there exists an \emph{assignment} to those coordinates that makes the optimal action
constant on the induced subcube.

\begin{problem}[ANCHOR-SUFFICIENCY]
\textbf{Input:} Decision problem $(A, X_1, \ldots, X_n, U)$ and fixed coordinate set $I \subseteq \{1,\ldots,n\}$ \\
\textbf{Question:} Does there exist an assignment $\alpha$ to $I$ such that
$\text{Opt}(s)$ is constant for all states $s$ with $s_I = \alpha$?
\end{problem}

\begin{theorem}[ANCHOR-SUFFICIENCY is $\Sigma_2^P$-complete]
\label{thm:anchor-sigma2p}
ANCHOR-SUFFICIENCY is $\Sigma_2^P$-complete \cite{stockmeyer1976polynomial} (already for Boolean coordinate spaces).
\textit{(Lean handles: \nolinkurl{ClaimClosure.anchor_sigma2p_reduction_core},
\nolinkurl{ClaimClosure.anchor_sigma2p_complete_conditional},
\nolinkurl{anchor_sufficiency_sigma2p}.)}
\end{theorem}

\begin{proof}
\textbf{Membership in $\Sigma_2^P$:} The problem has the form
\[
\exists \alpha \;\forall s \in S: \; (s_I = \alpha) \implies \text{Opt}(s) = \text{Opt}(s_\alpha),
\]
which is an $\exists\forall$ pattern.

\textbf{$\Sigma_2^P$-hardness:} Reduce from $\exists\forall$-SAT. Given
$\exists x \, \forall y \, \varphi(x,y)$ with $x \in \{0,1\}^k$ and $y \in \{0,1\}^m$,
if $m=0$ we first pad with a dummy universal variable (satisfiability is preserved),
construct a decision problem with:
\begin{itemize}
  \item Actions $A = \{\text{YES}, \text{NO}\}$
  \item State space $S = \{0,1\}^{k+m}$ representing $(x,y)$
  \item Utility
  \[
    U(\text{YES}, (x,y)) =
      \begin{cases}
        2 & \text{if } \varphi(x,y)=1 \\
        0 & \text{otherwise}
      \end{cases}
    \quad
    U(\text{NO}, (x,y)) =
      \begin{cases}
        1 & \text{if } y = 0^m \\
        0 & \text{otherwise}
      \end{cases}
  \]
  \item Fixed coordinate set $I$ = the $x$-coordinates.
\end{itemize}

If $\exists x^\star \, \forall y \, \varphi(x^\star,y)=1$, then for any $y$ we have
$U(\text{YES})=2$ and $U(\text{NO})\le 1$, so $\text{Opt}(x^\star,y)=\{\text{YES}\}$ is constant.
Conversely, fix $x$ and suppose $\exists y_f$ with $\varphi(x,y_f)=0$.
\begin{itemize}
\item If $\varphi(x,0^m)=1$, then $\text{Opt}(x,0^m)=\{\text{YES}\}$. The falsifying assignment must satisfy $y_f\neq 0^m$, where $U(\text{YES})=U(\text{NO})=0$, so $\text{Opt}(x,y_f)=\{\text{YES},\text{NO}\}$.
\item If $\varphi(x,0^m)=0$, then $\text{Opt}(x,0^m)=\{\text{NO}\}$. After padding we have $m>0$, so choose any $y'\neq 0^m$: either $\varphi(x,y')=1$ (then $\text{Opt}(x,y')=\{\text{YES}\}$) or $\varphi(x,y')=0$ (then $\text{Opt}(x,y')=\{\text{YES},\text{NO}\}$). In both subcases the optimal set differs from $\{\text{NO}\}$.
\end{itemize}
Hence the subcube for this $x$ is not constant. Thus an anchor assignment exists iff the $\exists\forall$-SAT instance is true.
\end{proof}

\paragraph{Immediate boundary statement (ANCHOR-SUFFICIENCY).}
Theorem~\ref{thm:anchor-sigma2p} remains a second-level hardness statement in the anchored formulation; unlike MINIMUM-SUFFICIENT-SET, no general collapse to relevance counting is established here, so the corresponding tractability status remains open in this model.
\textit{(Lean anchor handles: \nolinkurl{ClaimClosure.anchor_sigma2p_reduction_core},
\nolinkurl{ClaimClosure.anchor_sigma2p_complete_conditional},
\nolinkurl{anchor_sufficiency_sigma2p}.)}

\subsection{Tractable Subcases}

Despite the general hardness, several natural subcases admit efficient algorithms:

\begin{proposition}[Small State Space]
When $|S|$ is polynomial in the input size (i.e., explicitly enumerable), MINIMUM-SUFFICIENT-SET is solvable in polynomial time.
\end{proposition}

\begin{proof}
Compute $\text{Opt}(s)$ for all $s \in S$. The minimum sufficient set is exactly the set of coordinates that ``matter'' for the resulting function, computable by standard techniques.
\end{proof}

\begin{proposition}[Linear Utility]
When $U(a, s) = w_a \cdot s$ for weight vectors $w_a \in \mathbb{Q}^n$, MINIMUM-SUFFICIENT-SET reduces to identifying coordinates where weight vectors differ.
\end{proposition}

\subsection{Implications}

\begin{corollary}[Computational Bottleneck for Exact Minimization]
Under the succinct encoding, exact minimization of sufficient coordinate sets is coNP-hard via the $k=0$ case, and fixed-anchor minimization is $\Sigma_2^P$-complete.
\textit{(Lean handles: \nolinkurl{ClaimClosure.minsuff_conp_complete_conditional},
\nolinkurl{ClaimClosure.anchor_sigma2p_complete_conditional})}
\end{corollary}

\begin{proof}
The $k=0$ case of MINIMUM-SUFFICIENT-SET is SUFFICIENCY-CHECK (Theorem~\ref{thm:sufficiency-conp}), giving coNP-hardness for exact minimization. The fixed-anchor variant is exactly Theorem~\ref{thm:anchor-sigma2p}.
\end{proof}

The modeling budget for deciding what to model is therefore a computationally constrained resource under this encoding.

\subsection{Quantifier Collapse for MINIMUM-SUFFICIENT-SET}

\begin{theorem}[Collapse of the Apparent $\exists\forall$ Structure]
\label{thm:minsuff-collapse}
The apparent second-level predicate
\[
\exists I \, (|I| \leq k) \; \forall s,s' \in S:\; s_I = s'_I \implies \Opt(s)=\Opt(s')
\]
is equivalent to the coNP predicate $|\text{Relevant}| \le k$, where
\[
\text{Relevant} = \{i : \exists s,s'.\; s \text{ differs from } s' \text{ only at } i \text{ and } \Opt(s)\neq\Opt(s')\}.
\]
Consequently, MINIMUM-SUFFICIENT-SET is governed by coNP certificates rather than a genuine $\Sigma_2^P$ alternation.
\textit{(Lean handles: \nolinkurl{ClaimClosure.minsuff_collapse_core},
\nolinkurl{ClaimClosure.minsuff_collapse_to_conp_conditional},
\nolinkurl{Sigma2PHardness.min_sufficient_set_iff_relevant_card}.)}
\end{theorem}

\begin{proof}
By the formal equivalence \texttt{sufficient\_iff\_relevant\_subset} (finite-set form \texttt{sufficient\_iff\_relevantFinset\_subset}), a coordinate set $I$ is sufficient iff $\text{Relevant}\subseteq I$. Therefore:
\[
\exists I \; (|I|\le k \wedge \text{sufficient}(I))
\iff
\exists I \; (|I|\le k \wedge \text{Relevant}\subseteq I)
\iff
|\text{Relevant}| \le k.
\]
So the existential-over-universal presentation collapses to counting the relevant coordinates.

A NO certificate for $|\text{Relevant}| \le k$ is a list of $k+1$ distinct relevant coordinates, each witnessed by two states that differ only on that coordinate and yield different optimal sets; this is polynomially verifiable. Hence the resulting predicate is in coNP, matching Theorem~\ref{thm:minsuff-conp}.

This also clarifies why ANCHOR-SUFFICIENCY remains $\Sigma_2^P$-complete: once an anchor assignment is existentially chosen, the universal quantifier over the residual subcube does not collapse to a coordinate-counting predicate.
\end{proof}
