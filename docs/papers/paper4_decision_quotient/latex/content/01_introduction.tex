\section{Introduction}\label{sec:introduction}

Engineers routinely include irrelevant information in their models. Climate scientists model atmospheric chemistry when predicting regional temperatures. Financial analysts track hundreds of indicators when making portfolio decisions. Software architects specify dozens of configuration parameters when only a handful affect outcomes.

The conventional view holds that this \emph{over-modeling} reflects poor discipline---that skilled practitioners should identify the \emph{essential} variables and model only those. This paper proves the opposite: over-modeling is computationally rational because identifying the minimal set of decision-relevant variables is intractable.

\subsection{The Core Problem}

Consider a decision problem with actions $A$ and states $S = X_1 \times \cdots \times X_n$ (a product of $n$ coordinate spaces). For each state $s \in S$, some subset $\Opt(s) \subseteq A$ of actions are optimal. The fundamental question is:

\begin{quote}
\textbf{Which coordinates are sufficient to determine the optimal action?}
\end{quote}

A coordinate set $I \subseteq \{1, \ldots, n\}$ is \emph{sufficient} if knowing only the coordinates in $I$ determines the optimal action set:
\[
s_I = s'_I \implies \Opt(s) = \Opt(s')
\]
where $s_I$ denotes the projection of state $s$ onto coordinates in $I$.

\subsection{Main Results}

This paper proves four main theorems:

\begin{enumerate}
\item \textbf{Theorem~\ref{thm:sufficiency-conp} (Sufficiency Checking is \coNP-complete):} Given a decision problem and coordinate set $I$, determining whether $I$ is sufficient is \coNP-complete \cite{cook1971complexity, karp1972reducibility}.

\item \textbf{Theorem~\ref{thm:minsuff-conp} (Minimum Sufficiency is \coNP-complete):} Finding the minimum sufficient coordinate set is \coNP-complete. (The problem is trivially in $\SigmaP{2}$ by structure, but collapses to \coNP{} because sufficiency equals ``superset of relevant coordinates.'')

\item \textbf{Theorem~\ref{thm:dichotomy} (Complexity Dichotomy):} Sufficiency checking exhibits a dichotomy:
\begin{itemize}
\item If the minimal sufficient set has size $O(\log |S|)$, checking is polynomial
\item If the minimal sufficient set has size $\Omega(n)$, checking requires exponential time \cite{impagliazzo2001complexity}.
\end{itemize}

\item \textbf{Theorem~\ref{thm:tractable} (Tractable Subcases):} Sufficiency checking is polynomial-time for:
\begin{itemize}
\item Bounded action sets ($|A| \leq k$ for constant $k$)
\item Separable utility functions ($u(a,s) = f(a) + g(s)$)
\item Tree-structured coordinate dependencies
\end{itemize}
\end{enumerate}

\subsection{What This Paper Does NOT Claim}

To prevent misreading, we state explicit non-claims:

\begin{enumerate}
\item \textbf{NOT ``always model everything.''} Over-modeling has costs (computation, data collection). We claim the \emph{alternative} (minimal modeling) is computationally hard to identify.

\item \textbf{NOT ``complexity results apply to all domains.''} Structured problems admit tractable algorithms (Section~\ref{sec:tractable}). The hardness applies to general unstructured problems.

\item \textbf{NOT ``information theory is wrong.''} Value of information remains well-defined. We show \emph{computing} which information matters is hard.

\item \textbf{NOT ``this obsoletes existing approaches.''} Domain-specific heuristics remain valuable. We provide formal justification for their necessity.
\end{enumerate}

\subsection{Connection to Prior Papers}

This paper completes the theoretical foundation established in Papers 1--3:

\begin{itemize}
\item \textbf{Paper 1 (Typing):} Showed nominal typing dominates structural typing
\item \textbf{Paper 2 (SSOT):} Showed single source of truth minimizes modification complexity
\item \textbf{Paper 3 (Leverage):} Unified both as leverage maximization
\end{itemize}

\textbf{Paper 4's contribution:} Proves that \emph{identifying} which architectural decisions matter is itself computationally hard. This explains why leverage maximization (Paper 3) uses heuristics rather than optimal algorithms.

\subsection{Paper Structure}

Section~\ref{sec:foundations} establishes formal foundations: decision problems, coordinate spaces, sufficiency. Section~\ref{sec:hardness} proves hardness results with complete reductions. Section~\ref{sec:dichotomy} develops the complexity dichotomy. Section~\ref{sec:tractable} presents tractable special cases. Section~\ref{sec:implications} discusses implications for software architecture and modeling. Section~\ref{sec:related} surveys related work. Appendix~\ref{app:lean} contains Lean proof listings.


