\section{Tractable Special Cases}\label{sec:tractable}

Despite the general hardness, several natural problem classes admit polynomial-time algorithms.

\begin{theorem}[Tractable Subcases]\label{thm:tractable}
SUFFICIENCY-CHECK is polynomial-time solvable for:
\begin{enumerate}
\item \textbf{Bounded actions:} $|A| \leq k$ for constant $k$
\item \textbf{Separable utility:} $U(a, s) = f(a) + g(s)$
\item \textbf{Tree-structured dependencies:} Coordinates form a tree where each coordinate depends only on its ancestors
\end{enumerate}
\end{theorem}

\subsection{Bounded Actions}

\begin{proof}[Proof of Part 1]
With $|A| = k$ constant, the optimizer map $\Opt : S \to 2^A$ has at most $2^k$ distinct values. For each pair of distinct optimizer values, we can identify the coordinates that distinguish them. The union of these distinguishing coordinates forms a sufficient set.

The algorithm:
\begin{enumerate}
\item Sample states to identify distinct optimizer values (polynomial samples suffice with high probability)
\item For each pair of optimizer values, find distinguishing coordinates
\item Return the union of distinguishing coordinates
\end{enumerate}

This runs in time $O(|S| \cdot k^2)$ which is polynomial when $k$ is constant.
\end{proof}

\subsection{Separable Utility}

\begin{proof}[Proof of Part 2]
If $U(a, s) = f(a) + g(s)$, then:
\[
\Opt(s) = \arg\max_{a \in A} [f(a) + g(s)] = \arg\max_{a \in A} f(a)
\]
The optimal action is independent of the state! Thus $I = \emptyset$ is always sufficient.
\end{proof}

\subsection{Tree-Structured Dependencies}

\begin{proof}[Proof of Part 3]
When coordinates form a tree, we can use dynamic programming. For each node $i$, compute the set of optimizer values achievable in the subtree rooted at $i$. A coordinate is relevant if and only if different values at that coordinate lead to different optimizer values in its subtree. This approach is analogous to inference in probabilistic graphical models \cite{pearl1988probabilistic, koller2009probabilistic}.

The algorithm runs in time $O(n \cdot |A|^2)$ by processing the tree bottom-up.
\end{proof}

\subsection{Practical Implications}

These tractable cases correspond to common modeling scenarios:

\begin{itemize}
\item \textbf{Bounded actions:} Most real decisions have few alternatives (buy/sell/hold, approve/reject, etc.)
\item \textbf{Separable utility:} Additive cost models, linear utility functions
\item \textbf{Tree structure:} Hierarchical decision processes, causal models with tree structure
\end{itemize}

When a problem falls outside these cases, the hardness results apply, justifying heuristic approaches.


