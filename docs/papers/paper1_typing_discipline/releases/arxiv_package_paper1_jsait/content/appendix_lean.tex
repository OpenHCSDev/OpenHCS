\subsection{Formalization and Verification}\label{formalization-and-verification}

The core claims in this paper are machine-checked in Lean 4. We keep the appendix concise for JSAIT and move full operational listings and implementation-level proof scripts to the supplementary artifact.

\begin{table*}[t]
\centering
\caption{Lean 4 Formalization Modules}
\label{tab:lean-modules}
\small
\begin{tabular}{@{}llll@{}}
\toprule
Module & Lines & Theorems & Purpose \\
\midrule
\texttt{abstract\_class\_system.lean} & \LeanLinesAbstractClassSystem & \LeanTheoremsAbstractClassSystem & Two-axis instantiation, barrier, dominance \\
\texttt{axis\_framework.lean} & \LeanLinesAxisFramework & \LeanTheoremsAxisFramework & Query families, closure, matroid bridge \\
\texttt{nominal\_resolution.lean} & \LeanLinesNominalResolution & \LeanTheoremsNominalResolution & Nominal identification and witness procedures \\
\texttt{discipline\_migration.lean} & \LeanLinesDisciplineMigration & \LeanTheoremsDisciplineMigration & Discipline vs. migration consequences \\
\texttt{context\_formalization.lean} & \LeanLinesContextFormalization & \LeanTheoremsContextFormalization & Greenfield/retrofit context model \\
\texttt{python\_instantiation.lean} & \LeanLinesPythonInstantiation & \LeanTheoremsPythonInstantiation & Python instantiation \\
\texttt{typescript\_instantiation.lean} & \LeanLinesTypescriptInstantiation & \LeanTheoremsTypescriptInstantiation & TypeScript instantiation \\
\texttt{java\_instantiation.lean} & \LeanLinesJavaInstantiation & \LeanTheoremsJavaInstantiation & Java instantiation \\
\texttt{rust\_instantiation.lean} & \LeanLinesRustInstantiation & \LeanTheoremsRustInstantiation & Rust instantiation \\
\texttt{lwd\_converse.lean} & \LeanLinesLwdConverse & \LeanTheoremsLwdConverse & Zero-error converse chain on collision blocks \\
\midrule
\textbf{Core modules subtotal} & \textbf{\number\numexpr\LeanLinesAbstractClassSystem+\LeanLinesAxisFramework+\LeanLinesNominalResolution+\LeanLinesDisciplineMigration+\LeanLinesContextFormalization+\LeanLinesPythonInstantiation+\LeanLinesTypescriptInstantiation+\LeanLinesJavaInstantiation+\LeanLinesRustInstantiation+\LeanLinesLwdConverse\relax} & \textbf{\number\numexpr\LeanTheoremsAbstractClassSystem+\LeanTheoremsAxisFramework+\LeanTheoremsNominalResolution+\LeanTheoremsDisciplineMigration+\LeanTheoremsContextFormalization+\LeanTheoremsPythonInstantiation+\LeanTheoremsTypescriptInstantiation+\LeanTheoremsJavaInstantiation+\LeanTheoremsRustInstantiation+\LeanTheoremsLwdConverse\relax} & \textbf{10 representative modules shown} \\
\bottomrule
\end{tabular}
\end{table*}

\paragraph{What is in scope in the mechanization.}
The formalization covers the abstract observer model, the information barrier, constant-witness vs. query lower-bound separation, matroid structure of minimal distinguishing query sets, and the $(L,W,D)$ zero-error frontier claims stated in the main text. For matroid statements, closure axioms are mechanized in \texttt{AxisClosure} (\texttt{abstract\_class\_system.lean}); exchange/equicardinality lemmas are mechanized in \texttt{axis\_framework.lean}; and the closure-to-matroid composition is formalized there via \texttt{closureInducedAxisMatroid} and \texttt{closureInducedBasisEquicardinality} (with induced nodup/subset/exchange hypotheses explicit). For the converse in particular, \texttt{lwd\_converse.lean} formalizes: \texttt{collision\_block\_requires\_outcomes}, \texttt{collision\_block\_requires\_bits}, \texttt{maximal\_barrier\_requires\_bits}, and \texttt{impossible\_when\_bits\_too\_small}.

\paragraph{What is moved to supplementary artifact.}
Implementation-specific operational details and extended code listings are included in supplementary material and are not required to follow the IT contribution in the main paper.

\paragraph{Artifact totals.}
The complete artifact contains \LeanTotalFiles\ Lean files totaling \LeanTotalLines\ lines and \LeanTotalTheorems\ theorem/lemma statements; the table above highlights the core modules directly used by the main-text derivations. The remaining utility files (\texttt{Paper1.lean}, \texttt{PrintAxioms.lean}, \texttt{check\_axioms.lean}, \texttt{lakefile.lean}) contribute \number\numexpr\LeanTotalLines-\LeanLinesAbstractClassSystem-\LeanLinesAxisFramework-\LeanLinesNominalResolution-\LeanLinesDisciplineMigration-\LeanLinesContextFormalization-\LeanLinesPythonInstantiation-\LeanLinesTypescriptInstantiation-\LeanLinesJavaInstantiation-\LeanLinesRustInstantiation-\LeanLinesLwdConverse\relax\ lines and \number\numexpr\LeanTotalTheorems-\LeanTheoremsAbstractClassSystem-\LeanTheoremsAxisFramework-\LeanTheoremsNominalResolution-\LeanTheoremsDisciplineMigration-\LeanTheoremsContextFormalization-\LeanTheoremsPythonInstantiation-\LeanTheoremsTypescriptInstantiation-\LeanTheoremsJavaInstantiation-\LeanTheoremsRustInstantiation-\LeanTheoremsLwdConverse\relax\ theorem/lemma statements.

\subsection{Attribute-Only Formalization}\label{interface-only-formalization}

Attribute-only observation is formalized by an equivalence relation on values induced by observable query responses.

\begin{lstlisting}[style=lean]
structure InterfaceValue where
  fields : List (String * Nat)
deriving DecidableEq

def getField (obj : InterfaceValue) (name : String) : Option Nat :=
  match obj.fields.find? (fun p => p.1 == name) with
  | some p => some p.2 | none => none

def interfaceEquivalent (a b : InterfaceValue) : Prop :=
  forall name, getField a name = getField b name

def InterfaceRespecting (f : InterfaceValue -> a) : Prop :=
  forall a b, interfaceEquivalent a b -> f a = f b
\end{lstlisting}

\subsection{Corollary 6.3: Provenance Impossibility}\label{corollary-6.3-interface-only-cannot-provide-provenance}

Under attribute-only observation, provenance is constant on attribute-equivalence classes; therefore provenance cannot be recovered when distinct classes collide under the observable profile.

\begin{lstlisting}[style=lean]
theorem interface_provenance_indistinguishable
    (getProvenance : InterfaceValue -> Option DuckProvenance)
    (h_interface : InterfaceRespecting getProvenance)
    (obj1 obj2 : InterfaceValue)
    (h_equiv : interfaceEquivalent obj1 obj2) :
    getProvenance obj1 = getProvenance obj2 :=
  h_interface obj1 obj2 h_equiv
\end{lstlisting}

This is the mechanized form of the main-text impossibility statement: if an observer factors through attribute profile alone, it cannot separate equal-profile values by source/provenance.

\subsection{Abstract Model Lean Formalization}\label{abstract-model-lean-formalization}

The abstract model is formalized directly at the axis level and then connected to concrete instantiations.

\begin{lstlisting}[style=lean]
-- Axis-indexed representation
abbrev Typ (A : Finset Axis) := (a : Axis) -> a \in A -> axisType a

-- Two-axis setting used in the paper
abbrev Typ2 := Typ ({Axis.Bases, Axis.Shape} : Finset Axis)

-- Projectors
abbrev projBases (t : Typ2) := t Axis.Bases (by simp)
abbrev projShape (t : Typ2) := t Axis.Shape (by simp)
\end{lstlisting}

The corresponding isomorphism theorem establishes that the two-axis representation is complete for in-scope observables in the formal model.

\subsection{Reproducibility}

The full Lean development is provided in supplementary material. To verify locally:
\begin{enumerate}
\item Install Lean 4 and Lake (\url{https://leanprover.github.io/}).
\item From the release package root, run:
\begin{lstlisting}[style=lean]
cd proofs
lake build
\end{lstlisting}
\item Confirm successful build with no \texttt{sorry} placeholders.
\end{enumerate}
