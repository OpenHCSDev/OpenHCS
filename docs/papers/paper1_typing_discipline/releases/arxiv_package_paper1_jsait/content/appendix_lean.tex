\subsection{Formalization and Verification}\label{formalization-and-verification}

The core claims in this paper are machine-checked in Lean 4. We keep the appendix concise for JSAIT and move full operational listings and implementation-level proof scripts to the supplementary artifact.

\begin{table*}[t]
\centering
\caption{Lean 4 Formalization Modules}
\label{tab:lean-modules}
\small
\begin{tabular}{@{}llll@{}}
\toprule
Module & Lines & Theorems & Purpose \\
\midrule
\texttt{abstract\_class\_system.lean} & 3278 & 155 & Two-axis instantiation, barrier, dominance \\
\texttt{axis\_framework.lean} & 1721 & 63 & Query families, closure, matroid structure \\
\texttt{nominal\_resolution.lean} & 609 & 27 & Nominal identification and witness procedures \\
\texttt{discipline\_migration.lean} & 142 & 11 & Discipline vs. migration consequences \\
\texttt{context\_formalization.lean} & 215 & 7 & Greenfield/retrofit context model \\
\texttt{python\_instantiation.lean} & 249 & 17 & Python instantiation \\
\texttt{typescript\_instantiation.lean} & 65 & 4 & TypeScript instantiation \\
\texttt{java\_instantiation.lean} & 63 & 4 & Java instantiation \\
\texttt{rust\_instantiation.lean} & 64 & 4 & Rust instantiation \\
\texttt{lwd\_converse.lean} & 41 & 4 & Ambiguity converse counting lemmas \\
\midrule
\textbf{Core modules subtotal} & \textbf{6447} & \textbf{296} & \textbf{10 representative modules shown} \\
\bottomrule
\end{tabular}
\end{table*}

\paragraph{What is in scope in the mechanization.}
The formalization covers the abstract observer model, the information barrier, constant-witness vs. query lower-bound separation, matroid structure of minimal distinguishing query sets, and the $(L,W,D)$ zero-error frontier claims stated in the main text.

\paragraph{What is moved to supplementary artifact.}
Implementation-specific operational details and extended code listings are included in supplementary material and are not required to follow the IT contribution in the main paper.

\paragraph{Artifact totals.}
The complete artifact contains 14 Lean files totaling 6589 lines and 296 theorem/lemma statements; the table above highlights the core modules directly used by the main-text derivations.

\subsection{Attribute-Only Formalization}\label{interface-only-formalization}

Attribute-only observation is formalized by an equivalence relation on values induced by observable query responses.

\begin{lstlisting}[style=lean]
structure InterfaceValue where
  fields : List (String * Nat)
deriving DecidableEq

def getField (obj : InterfaceValue) (name : String) : Option Nat :=
  match obj.fields.find? (fun p => p.1 == name) with
  | some p => some p.2 | none => none

def interfaceEquivalent (a b : InterfaceValue) : Prop :=
  forall name, getField a name = getField b name

def InterfaceRespecting (f : InterfaceValue -> a) : Prop :=
  forall a b, interfaceEquivalent a b -> f a = f b
\end{lstlisting}

\subsection{Corollary 6.3: Provenance Impossibility}\label{corollary-6.3-interface-only-cannot-provide-provenance}

Under attribute-only observation, provenance is constant on attribute-equivalence classes; therefore provenance cannot be recovered when distinct classes collide under the observable profile.

\begin{lstlisting}[style=lean]
theorem interface_provenance_indistinguishable
    (getProvenance : InterfaceValue -> Option DuckProvenance)
    (h_interface : InterfaceRespecting getProvenance)
    (obj1 obj2 : InterfaceValue)
    (h_equiv : interfaceEquivalent obj1 obj2) :
    getProvenance obj1 = getProvenance obj2 :=
  h_interface obj1 obj2 h_equiv
\end{lstlisting}

This is the mechanized form of the main-text impossibility statement: if an observer factors through attribute profile alone, it cannot separate equal-profile values by source/provenance.

\subsection{Abstract Model Lean Formalization}\label{abstract-model-lean-formalization}

The abstract model is formalized directly at the axis level and then connected to concrete instantiations.

\begin{lstlisting}[style=lean]
-- Axis-indexed representation
abbrev Typ (A : Finset Axis) := (a : Axis) -> a \in A -> axisType a

-- Two-axis setting used in the paper
abbrev Typ2 := Typ ({Axis.Bases, Axis.Shape} : Finset Axis)

-- Projectors
abbrev projBases (t : Typ2) := t Axis.Bases (by simp)
abbrev projShape (t : Typ2) := t Axis.Shape (by simp)
\end{lstlisting}

The corresponding isomorphism theorem establishes that the two-axis representation is complete for in-scope observables in the formal model.

\subsection{Reproducibility}

The full Lean development is provided in supplementary material. To verify locally:
\begin{enumerate}
\item Install Lean 4 and Lake (\url{https://leanprover.github.io/}).
\item From the release package root, run:
\begin{lstlisting}[style=lean]
cd proofs
lake build
\end{lstlisting}
\item Confirm successful build with no \texttt{sorry} placeholders.
\end{enumerate}
