\section{Core Theorems}\label{core-theorems}

\subsection{The Error Localization
Theorem}\label{the-error-localization-theorem}

\textbf{Definition 4.1 (Error Location).} Let E(T) be the number of
source locations that must be inspected to find all potential violations
of a type constraint under discipline T.

\textbf{Theorem 4.1 (Nominal Complexity).} E(nominal) = O(1).

\emph{Proof.} Under nominal typing, constraint ``x must be an A'' is
satisfied iff type(x) inherits from A. This property is determined at
class definition time, at exactly one location: the class definition of
type(x). If the class does not list A in its bases (transitively), the
constraint fails. One location. \(\blacksquare\)

\textbf{Theorem 4.2 (Structural Complexity).} E(structural) = O(k) where
k = number of classes.

\emph{Proof.} Under structural typing, constraint ``x must satisfy
interface A'' requires checking that type(x) implements all methods in
signature(A). This check occurs at each class definition. For k classes,
O(k) locations. \(\blacksquare\)

\textbf{Theorem 4.3 (Duck Typing Complexity).} E(duck) = $\Omega(n)$
where n = number of call sites.

\emph{Proof.} Under duck typing, constraint ``x must have method m'' is
encoded as \texttt{hasattr(x,\ "m")} at each call site. There is no
central declaration. For n call sites, each must be inspected. Lower
bound is $\Omega(n)$. \(\blacksquare\)

\textbf{Corollary 4.4 (Strict Dominance).} Nominal typing strictly
dominates duck typing: E(nominal) = O(1) \textless{} $\Omega(n)$ =
E(duck) for all n \textgreater{} 1.

\subsection{The Information Scattering
Theorem}\label{the-information-scattering-theorem}

\textbf{Definition 4.2 (Constraint Encoding Locations).} Let I(T, c) be
the set of source locations where constraint c is encoded under
discipline T.

\textbf{Theorem 4.5 (Duck Typing Scatters).} For duck typing,
\textbar I(duck, c)\textbar{} = O(n) where n = call sites using
constraint c.

\emph{Proof.} Each \texttt{hasattr(x,\ "method")} call independently
encodes the constraint. No shared reference. Constraints scale with call
sites. \(\blacksquare\)

\textbf{Theorem 4.6 (Nominal Typing Centralizes).} For nominal typing,
\textbar I(nominal, c)\textbar{} = O(1).

\emph{Proof.} Constraint c = ``must inherit from A'' is encoded once: in
the ABC/Protocol definition of A. All \texttt{isinstance(x,\ A)} checks
reference this single definition. \(\blacksquare\)

\textbf{Corollary 4.7 (Maintenance Entropy).} Duck typing maximizes
maintenance entropy; nominal typing minimizes it.

\subsection{Empirical
Demonstration}\label{empirical-demonstration}

The theoretical complexity bounds in Theorems 4.1-4.3 are demonstrated
empirically in Section 5, Case Study 1 (WellFilterConfig hierarchy). Two
classes with identical structure but different nominal identities
require O(1) disambiguation under nominal typing but \(\Omega\)(n)
call-site inspection under duck typing. Case Study 5 illustrates this:
migrating from duck to nominal typing replaced scattered
\texttt{hasattr()} checks across 47 call sites with centralized ABC
contract validation at a single definition point.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}
