\section{Introduction}\label{introduction}

\subsection{The Classification Problem}\label{the-classification-problem}

Every formal system that classifies entities faces a fundamental architectural decision: which dimensions (axes) of classification to employ. Type systems choose between nominal and structural axes. Ontologies choose between taxonomic and mereological axes. Database schemas choose between relational and hierarchical axes.

This paper proves that this choice has unavoidable mathematical consequences. Specifically:

\begin{enumerate}
\item \textbf{Fixed axis sets guarantee incompleteness.} For any axis set $A$, there exist domains requiring axes outside $A$. No implementation within $A$ can answer these domains' queries; the information does not exist.
\item \textbf{Parameterized axis sets achieve universality.} A classification system that parameterizes over axes can serve any domain by instantiating the required axes.
\item \textbf{The asymmetry is absolute.} Fixed systems fail for some domain (guaranteed). Parameterized systems succeed for all domains (guaranteed). This is not a tradeoff; it is strict dominance.
\end{enumerate}

\subsection{Scope: From Type Theory to Classification Theory}\label{scope-from-type-theory}

This work establishes a general framework for classification systems, proving that axis sets are derivable from domain requirements. The type system application ("nominal vs structural typing") is one instantiation among many.

The framework rests on three core concepts:
\begin{itemize}
\item Domains as sets of queries requiring specific information
\item Axes as orthogonal dimensions of classification
\item Completeness as the ability to answer all queries in a domain
\end{itemize}

These concepts apply to any classification scheme (type systems, ontologies, taxonomies, schemas). We present results at two levels:
\begin{enumerate}
\item \textbf{The universal claim} (Section 3): Classification systems with fixed axes are incomplete for some domain. Axis sets are computable from domain requirements.
\item \textbf{The type system instantiation} (Sections 4--5): For programming languages with inheritance, $(B, S)$ is the unique minimal complete axis set. Traditional typing discipline names ("nominal," "structural") denote specific axis configurations.
\end{enumerate}

The impossibility theorems are universal; the type system debates are a consequence of wrongly framing axis derivation as preference.

\subsection{Metatheoretic Foundations}\label{metatheoretic-foundations}

This work follows the tradition of Liskov \& Wing~\cite{liskov1994behavioral}, who formalized correctness criteria for subtyping. Where Liskov \& Wing asked ``what makes subtyping \emph{correct}?'', we ask a more fundamental question: ``what makes \emph{any classification scheme} complete for its domain?''

Our contribution is not recommending specific classification axes, but proving that the choice is \emph{determined} by domain requirements. We develop a framework where:
\begin{itemize}
\item The required axes are \emph{computable} from domain queries
\item Missing axes cause \emph{impossibility}, not difficulty
\item All minimal complete axis sets have \emph{equal cardinality} (dimension is well-defined)
\end{itemize}

\subsection{Overview}\label{overview}

All results are machine-checked in Lean 4 (6300+ lines, 190+ theorems, 0 \texttt{sorry} placeholders).

We develop a metatheory applicable to any classification system. The core insight: every such system is characterized by which axes it employs. For type systems, these are $(B, S)$ (Bases and Namespace); for hierarchical configuration, $(B, S, H)$ adds a Scope axis. These axes form a lattice: $\emptyset < S < (B,S) < (B,S,H)$, where each increment strictly dominates the previous.

\textbf{The pay-as-you-go principle:} Each axis increment adds capabilities without cognitive load increase until those capabilities are invoked. Duck typing uses $\emptyset$; structural uses $S$; nominal uses $(B,S)$ with the same API; scoped resolution uses $(B,S,H)$ with one optional parameter.

The model formalizes what programmers intuitively understand but rarely make explicit:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Axis inclusion requirements} (Theorem 3.4): For languages with explicit
  inheritance (bases axis $B \neq \emptyset$), systems including $\{B, S\}$ Pareto-dominate
  systems using only $\{S\}$ (provides strictly more
  capabilities with zero tradeoffs). Systems excluding $B$ lose nothing only
  when $B = \emptyset$ by design (e.g., Go); otherwise
  it is a capability sacrifice, not an alternative. The axis set is \textbf{derived} from
  domain requirements, not preference. In type system terminology: "nominal typing" = $\{B,S\}$; "structural typing" = $\{S\}$.
\item
  \textbf{Complexity separation} (Theorem 4.3): Systems using $\{B, S\}$ achieve
  O(1) error localization; systems using only $\{S\}$ incoherently (duck typing) require $\Omega(n)$ call-site
  inspection.
\item
  \textbf{Provenance impossibility} (Corollary 6.3): Systems using only the $\{S\}$ axis cannot
  answer ``which type provided this value?'' because structurally
  equivalent objects are indistinguishable by definition. The $B$ axis is required.
  Machine-checked in Lean 4.
\end{enumerate}

These theorems yield four measurable code quality metrics:

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2162}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4865}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2973}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Metric
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
What it measures
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Indicates
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Duck typing density & \texttt{hasattr()} per KLOC & Discipline
violations (duck typing is incoherent per Theorem 2.10d; other
\texttt{getattr()} / \texttt{AttributeError} patterns may be valid
metaprogramming) \\
Nominal typing ratio & \texttt{isinstance()} + ABC registrations per
KLOC & Explicit type contracts \\
Provenance capability & Presence of ``which type provided this'' queries
& System requires nominal typing \\
Resolution determinism & MRO-based dispatch vs runtime probing & O(1) vs
$\Omega(n)$ error localization \\
\end{longtable}

The methodology is validated through case studies from OpenHCS~\cite{openhcs2025}, a
production bioimage analysis platform. The system's architecture exposed
the formal necessity of nominal typing through patterns ranging from
metaclass auto-registration to bidirectional type registries. A
migration from duck typing to nominal contracts (PR \#44~\cite{openhcsPR44}) eliminated 47
scattered \texttt{hasattr()} checks and consolidated dispatch logic into
explicit ABC contracts.

\subsection{Contributions}\label{contributions}

This paper makes five contributions, ordered from most general to most specific:

\textbf{1. Impossibility Theorems for Fixed Classification (Section 3):}
\begin{itemize}
\item \textbf{Fixed Axis Incompleteness:} Any classification system with fixed axes is incomplete for some domain. This is information-theoretic: the data required to answer the domain's queries does not exist in the fixed axis set.
\item \textbf{Uniqueness of Minimal Complete Sets:} All minimal complete axis sets for a domain have equal cardinality. Dimension is well-defined for classification problems.
\item \textbf{Minimality $\Rightarrow$ Orthogonality:} Every minimal complete axis set is orthogonal. Redundant (non-orthogonal) systems are never minimal. This is a \emph{theorem}, not an assumption.
\item \textbf{Matroid Structure (Theorem 2.32):} Orthogonal axis sets satisfy the matroid exchange property. This gives basis equicardinality and makes dimension well-defined.
\item \textbf{Semantic Non-Embeddability (Theorem 3.13a):} Disciplines with fewer axes cannot embed disciplines with more axes. Structural typing cannot simulate nominal typing---the information is simply absent.
\item \textbf{Axis-Parametric Dominance:} Systems that derive axes from requirements strictly dominate fixed-axis systems. The gap is not a tradeoff; it is absolute.
\end{itemize}
These theorems apply to \emph{any} classification system: type systems, ontologies, taxonomies, schemas.

\textbf{2. Type System Instantiation (Sections 4--5):}
\begin{itemize}
\item \textbf{Theorem 3.32 (Model Completeness):} $(B, S)$ captures all runtime-available type information for class-based systems.
\item \textbf{Theorem 3.13 (Provenance Impossibility):} No system excluding $B$ can compute provenance. This is information-theoretic impossibility.
\item \textbf{Theorem 3.13a (Non-Embeddability):} Nominal typing cannot be embedded into structural typing. The information gap is absolute, not a matter of encoding.
\item \textbf{Theorem 3.24 (Complexity Lower Bound):} Systems using only $\{S\}$ incoherently require $\Omega(n)$ error localization. Systems using $\{B, S\}$ achieve $O(1)$. The gap is unbounded.
\item \textbf{Theorem 3.5:} Systems including $\{B, S\}$ strictly dominate systems using only $\{S\}$ when $B \neq \emptyset$. (In type system terminology: nominal typing dominates structural typing.)
\end{itemize}

\textbf{3. Axis-Parametric Extension:}
\begin{itemize}
\item \textbf{Theorem 3.82 (Axis Capability Monotonicity):} Adding an independent axis strictly increases capabilities.
\item \textbf{Theorem 3.85 (Completeness Uniqueness):} For any domain, the minimal complete axis set is unique.
\item \textbf{Theorem 3.86 (Axis Derivation Algorithm):} The minimal axis set is computable from domain requirements.
\item \textbf{OpenHCS instantiation:} For hierarchical configuration (scope chains), a third axis $H$ is derived. The result $(B, S, H)$ enables click-to-provenance across windows.
\end{itemize}

\textbf{4. Metatheoretic Foundations (Section 2):}
\begin{itemize}
\item The axis lattice framework for capability analysis
\item Theorem 2.15 (Axis Lattice Dominance): capability monotonicity under axis subset ordering
\item The pay-as-you-go principle: axes add capability without cost until invoked
\end{itemize}

\textbf{5. Machine-checked Verification (Section 6):}
\begin{itemize}
\item 6300+ lines of Lean 4 proofs across eleven modules
\item 190+ theorems/lemmas with \textbf{zero \texttt{sorry} placeholders}
\item Formalized $O(1)$ vs $\Omega(n)$ complexity separation with adversary-based lower bound
\item Universal extension to 8 languages (Java, C\#, Rust, TypeScript, Kotlin, Swift, Scala, C++)
\end{itemize}

\textbf{6. Empirical Validation (Section 5):}
\begin{itemize}
\item 13 case studies from OpenHCS (45K LoC production Python codebase)
\item Demonstrates theoretical predictions align with real-world architectural decisions
\item Four derivable code quality metrics (DTD, NTR, PC, RD)
\end{itemize}

\subsubsection{Empirical Context:
OpenHCS}\label{empirical-context-openhcs}

\textbf{What it does:} OpenHCS is a bioimage analysis platform.
Pipelines are compiled before execution. Errors surface at definition
time, not after processing starts. The GUI and Python code are
interconvertible: design in GUI, export to code, edit, re-import.
Changes to parent config propagate automatically to all child windows.

\textbf{Why it matters for this paper:} The system requires knowing
\emph{which type} provided a value, not just \emph{what} the value is.
Dual-axis resolution walks both the context hierarchy (global
\(\rightarrow\) plate \(\rightarrow\) step) and the class hierarchy
(MRO) simultaneously. Every resolved value carries provenance: (value,
source\_scope, source\_type). This is only possible with nominal
typing. Duck typing cannot answer ``which type provided this?''

\textbf{Key architectural patterns (detailed in Section 5):}
\begin{itemize}
\item \texttt{@auto\_create\_decorator} $\rightarrow$ \texttt{@global\_pipeline\_config} cascade: one decorator spawns a 5-stage type transformation (Case Study 7)
\item Dual-axis resolver: MRO \emph{is} the priority system. No custom priority function exists (Case Study 8)
\item Bidirectional type registries: single source of truth with \texttt{type()} identity as key (Case Study 13)
\end{itemize}

\subsubsection{Decision Procedure, Not
Preference}\label{decision-procedure-not-preference}

The contribution of this paper is not the theorems alone, but their
consequence: axis set determination becomes a decision procedure (Theorem 2.26).
Given requirements, the axes are derived.

\textbf{Implications:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Pedagogy.} Architecture courses should not teach ``pick the
  style that feels Pythonic.'' They should teach how to derive the
  required axes from domain queries. This is engineering, not taste.
\item
  \textbf{AI code generation.} LLMs can apply the decision procedure.
  ``Given requirements R, apply Algorithm 2.26, emit code with the derived
  axis set'' is an objective correctness criterion. The model either
  applies the procedure correctly or it does not.
\item
  \textbf{Language design.} Future languages could enforce axis inclusion
  based on declared requirements. A \texttt{@requires\_provenance}
  annotation could mandate $B$ inclusion at compile time.
\item
  \textbf{Formal constraints.} When requirements include provenance,
  the mathematics constrains the choice: systems excluding $B$ cannot
  provide this capability (Theorem 3.13, information-theoretic
  impossibility). The procedure derives the axis set from requirements.
\end{enumerate}

\subsubsection{Scope and Limitations}\label{scope-limitations}

This paper makes absolute claims. We do not argue that including all axes is
``preferred'' or ``more elegant.'' We prove:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Systems excluding $B$ cannot provide provenance.} Disciplines using only
  $\{S\}$ check type \emph{shape}: attributes, method
  signatures. Provenance requires type \emph{identity} from the inheritance graph. Systems
  excluding $B$ cannot provide what they do not track.
\item
  \textbf{When B $\neq$ $\emptyset$, $\{B, S\}$ systems dominate among fixed-axis systems.} Including both axes
  provides strictly more capabilities. Adapters eliminate the retrofit exception (Theorem
  2.10j). When inheritance exists, $\{B, S\}$ inclusion is the capability-maximizing choice \emph{within the fixed-axis model}.
\item
  \textbf{Excluding required axes is a capability sacrifice.} Systems using
  only $\{S\}$ (Protocol, structural typing) discard the Bases axis. This eliminates four capabilities
  (provenance, identity, enumeration, conflict resolution) without
  providing any compensating capability (a dominated choice when \(B \neq \emptyset\)).
\end{enumerate}

\textbf{Fixed-axis vs.\ axis-parametric correctness.} The above results establish dominance \emph{within} fixed-axis type systems. However, any fixed-axis system is fundamentally incomplete (Theorem 3.77, Fixed Axis Incompleteness): there exist domains requiring axes outside the fixed set. The truly \emph{correct} approach is axis-parametric, deriving the minimal axis set from domain requirements (Section~\ref{axis-parametric-theory}). Fixed-axis maximization (choosing $\{B,S\}$ over $\{S\}$ when $B \neq \emptyset$) is coherent only when the axis-parametric option is unavailable. Put simply: axis-parametric is correct; fixed-axis $\{B,S\}$ is less wrong than fixed-axis $\{S\}$; but both fixed options remain incomplete.

\textbf{Boundary scope} (pulled forward for clarity): when \(B = \emptyset\)
(no user-declared inheritance), e.g., pure JSON/FFI payloads or
languages intentionally designed without inheritance, $\{S\}$-only systems (structural typing) are
the coherent choice. Whenever \(B \neq \emptyset\) and inheritance metadata is accessible, including $B$ in the axis set strictly dominates excluding it. Systems where \(B = \emptyset\) are not exceptions---they simply do not require the B axis, and thus $\{S\}$-only systems lose nothing (but gain nothing either).

The requirements determine the axes; the axes determine the capabilities. Systems requiring provenance cannot exclude $B$. This is not a design recommendation but a mathematical constraint.

\subsection{Roadmap}\label{roadmap}

\textbf{Section 2: Metatheoretic foundations} --- The two-axis model
(B, S) with names as sugar, abstract class system formalization, and the
Axis Lattice Metatheorem (Theorem 2.15)

\textbf{Section 3: Universal dominance} --- Strict dominance (Theorem
3.5), information-theoretic completeness (Theorem 3.19), retrofit
exception eliminated (Theorem 2.10j)

\textbf{Section 4: Decision procedure} --- Deriving typing discipline
from system properties

\textbf{Section 5: Empirical validation} --- 13 OpenHCS case studies
validating theoretical predictions

\textbf{Section 6: Machine-checked proofs} --- Lean 4 formalization
(6300+ lines)

\textbf{Section 7: Related work} --- Positioning within PL theory
literature

\textbf{Section 8: Extensions} --- Mixins vs composition (Theorem 8.1),
TypeScript coherence analysis (Theorem 8.7), gradual typing connection,
Zen alignment

\textbf{Section 9: Conclusion} --- Implications for PL theory and
practice

\subsection{Anticipated Objections}\label{sec:objection-summary}

Before proceeding, we address objections readers are likely forming. Each is refuted in detail in Appendix~\ref{appendix:robustness}; here we summarize the key points.

\paragraph{``The (B, S) model doesn't capture real type systems.''}
The model is complete by construction. In Python, \texttt{type(name, bases, namespace)} is the universal type constructor---a type \emph{is} (B, S), not merely has it. The syntactic name (\texttt{\_\_name\_\_}) is metadata stored in the namespace (S axis), not a separate axis. Properties like \texttt{\_\_mro\_\_} and \texttt{\_\_module\_\_} are \emph{derived from} (B, S), not independent axes. This is definitional closure: no third axis can exist (Theorem~\ref{thm:model-completeness}, Appendix~\ref{appendix:detailed-concerns}).

\paragraph{``Duck typing is more flexible than nominal typing.''}
No. Nominal typing provides a strict superset of duck typing capabilities. Duck typing's ``acceptance'' of structurally-equivalent types is not a capability---it is the \emph{absence} of the capability to distinguish them. ``Flexibility'' is the absence of discrimination, not the presence of power (Theorems 3.34--3.36, Appendix~\ref{appendix:detailed-concerns}).

\paragraph{``The axiom that shape-based typing can't distinguish same-shape types is circular.''}
The axiom is \emph{definitional}, not assumptive. Shape-based typing is \emph{defined} as the discipline that treats types identically when their shapes match. This is what ``shape-based'' means. The theorems follow from the definition (Lemma~\ref{lem:shape-axiom-definitional}, Appendix~\ref{appendix:detailed-concerns}).

\paragraph{``A clever extension could recover provenance for duck typing.''}
No. Theorem~\ref{thm:extension-impossibility} proves that any computable extension over $\{S\}$ (even with type names) cannot recover provenance. The common response ``just check \texttt{type(x)}'' proves the point: inspecting \texttt{type(x)} consults the B axis. Once you use B, you have adopted nominal typing (Appendix~\ref{appendix:detailed-concerns}).

\paragraph{``You only tested on one codebase (OpenHCS).''}
This conflates existential witnesses with premises. The dominance theorems are proven from the \emph{definition} of shape-based typing---no codebase is referenced in the proofs. OpenHCS demonstrates that the four capabilities (provenance, identity, enumeration, conflict resolution) are \emph{achievable}, not that the theorems are true. Analogy: proving $\Omega(n \log n)$ for comparison sorts doesn't require testing multiple arrays (Appendix~\ref{appendix:detailed-concerns}).

\paragraph{``Dominance implies you should migrate all legacy codebases.''}
No. Theorem~\ref{thm:dominance-not-migration} formally proves that Pareto dominance does NOT imply beneficial migration. Dominance is codebase-independent; migration cost is codebase-dependent. The theorem characterizes \emph{capabilities}, not \emph{recommendations} (Appendix~\ref{appendix:detailed-concerns}).

\paragraph{``You just need code review and discipline, not language features.''}
Discipline \emph{is} the external oracle. When DOF $> 1$, consistency requires an oracle to resolve disagreements. ``Code review'' is exactly that oracle---human-maintained, fallible, bypassable. Language enforcement cannot be forgotten; human discipline can (Appendix~\ref{appendix:detailed-concerns}).

\paragraph{``The proofs are trivial---just \texttt{rfl}.''}
When modeling is correct, theorems become definitional. This is a feature. Not all proofs are \texttt{rfl}: \texttt{provenance\_impossibility} requires 40+ lines of actual reasoning (assumption → lemma application → contradiction). The contribution is making the right definitions so that consequences follow structurally (Appendix~\ref{appendix:detailed-concerns}).

\paragraph{``This is just subtyping.''}
No. Subtyping asks: ``Can I use type $A$ where type $B$ is expected?'' This is a \emph{relationship} between types. Our claim is about type \emph{construction}: extending \texttt{type(name, bases, namespace)} to \texttt{type(name, bases, namespace, **axes)}. These are orthogonal concerns. Subtyping operates on types that already exist; axis-parametric construction determines type \emph{identity} at creation time. Whether $T(\text{scope}=X) <: T(\text{scope}=Y)$ is a question that comes \emph{after} our proposal---and we make no claims about it (Appendix~\ref{appendix:detailed-concerns}).

\medskip
\noindent\textbf{If you have an objection not listed above,} check Appendix~\ref{appendix:robustness} (17 concerns addressed) before concluding it has not been considered.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}
