\section{Preliminaries}\label{preliminaries}

\subsection{Definitions}\label{definitions}

\textbf{Definition 2.1 (Class).} A class C is a triple (name, bases,
namespace) where: - name \(\in\) String --- the identity of the class -
bases \(\in\) List{[}Class{]} --- explicit inheritance declarations -
namespace \(\in\) Dict{[}String, Any{]} --- attributes and methods

\textbf{Definition 2.2 (Typing Discipline).} A typing discipline T is a
method for determining whether an object x satisfies a type constraint
A.

\textbf{Definition 2.3 (Nominal Typing).} x satisfies A iff A \(\in\)
MRO(type(x)). The constraint is checked via explicit inheritance.

\textbf{Definition 2.4 (Structural Typing).} x satisfies A iff
namespace(x) \(\supseteq\) signature(A). The constraint is checked via
method/attribute matching. In Python, \texttt{typing.Protocol}
implements structural typing: a class satisfies a Protocol if it has
matching method signatures, regardless of inheritance.

\textbf{Definition 2.5 (Duck Typing).} x satisfies A iff hasattr(x, m)
returns True for each m in some implicit set M. The constraint is
checked via runtime string-based probing.

\textbf{Observation 2.1 (Shape-Based Typing).} Structural typing and
duck typing are both \emph{shape-based}: they check what methods or
attributes an object has, not what type it is. Nominal typing is
\emph{identity-based}: it checks the inheritance chain. This distinction
is fundamental. Python's \texttt{Protocol}, TypeScript's interfaces, and
Go's implicit interface satisfaction are all shape-based. ABCs with
explicit inheritance are identity-based. The theorems in this paper
prove shape-based typing cannot provide provenance---regardless of
whether the shape-checking happens at compile time (structural) or
runtime (duck).

\textbf{Complexity distinction:} While structural typing and duck typing
are both shape-based, they differ critically in \emph{when} the
shape-checking occurs:

\begin{itemize}
\tightlist
\item
  \textbf{Structural typing} (Protocol): Shape-checking at \emph{static
  analysis time} or \emph{type definition time}. Complexity: O(k) where
  k = number of classes implementing the protocol.
\item
  \textbf{Duck typing} (hasattr/getattr): Shape-checking at
  \emph{runtime, per call site}. Complexity: \(\Omega\)(n) where n =
  number of call sites.
\end{itemize}

This explains why structural typing (TypeScript interfaces, Go
interfaces, Python Protocols) is considered superior to duck typing in
practice: both are shape-based, but structural typing performs the
checking once at compile/definition time, while duck typing repeats the
checking at every usage site.

\textbf{Critical insight:} Even though structural typing has better
complexity than duck typing (O(k) vs \(\Omega\)(n)), \emph{both} are
strictly dominated by nominal typing's O(1) error localization (Theorem
4.1). Nominal typing checks inheritance at the single class definition
point---not once per implementing class (structural) or once per call
site (duck).

\subsection{The type() Theorem}\label{the-type-theorem}

\textbf{Theorem 2.1 (Completeness).} For any valid triple (name, bases,
namespace), \texttt{type(name,\ bases,\ namespace)} produces a class C
with exactly those properties.

\emph{Proof.} By construction:

\begin{verbatim}
C = type(name, bases, namespace)
assert C.__name__ == name
assert C.__bases__ == bases
assert all(namespace[k] == getattr(C, k) for k in namespace)
\end{verbatim}

The \texttt{class} statement is syntactic sugar for \texttt{type()}. Any
class expressible via syntax is expressible via \texttt{type()}.
\(\blacksquare\)

\textbf{Theorem 2.2 (Semantic Minimality).} The semantically minimal
class constructor has arity 2: \texttt{type(bases,\ namespace)}.

\emph{Proof.} - \texttt{bases} determines inheritance hierarchy and MRO
- \texttt{namespace} determines attributes and methods - \texttt{name}
is metadata; object identity distinguishes types at runtime - Each call
to \texttt{type(bases,\ namespace)} produces a distinct object -
Therefore name is not necessary for type semantics. \(\blacksquare\)

\textbf{Theorem 2.3 (Practical Minimality).} The practically minimal
class constructor has arity 3: \texttt{type(name,\ bases,\ namespace)}.

\emph{Proof.} The name string is required for: 1. \textbf{Debugging}:
\texttt{repr(C)} \(\rightarrow\)
\texttt{\textless{}class\ \textquotesingle{}\_\_main\_\_.Foo\textquotesingle{}\textgreater{}}
vs
\texttt{\textless{}class\ \textquotesingle{}\_\_main\_\_.???\textquotesingle{}\textgreater{}}
2. \textbf{Serialization}: Pickling uses \texttt{\_\_name\_\_} to
reconstruct classes 3. \textbf{Error messages}: ``Expected Foo, got
Bar'' requires names 4. \textbf{Metaclass protocols}:
\texttt{\_\_init\_subclass\_\_}, registries key on \texttt{\_\_name\_\_}

Without name, the system is semantically complete but practically
unusable. \(\blacksquare\)

\textbf{Definition 2.6 (The Two-Axis Semantic Core).} The semantic core
of Python's class system is: - \textbf{bases}: inheritance relationships
(\(\rightarrow\) MRO, nominal typing) - \textbf{namespace}: attributes
and methods (\(\rightarrow\) behavior, structural typing)

The \texttt{name} axis is orthogonal to both and carries no semantic
weight.

\textbf{Theorem 2.4 (Orthogonality of Semantic Axes).} The
\texttt{bases} and \texttt{namespace} axes are orthogonal.

\emph{Proof.} Independence: - Changing bases does not change namespace
content (only resolution order for inherited methods) - Changing
namespace does not change bases or MRO

The factorization (bases, namespace) is unique. \(\blacksquare\)

\textbf{Corollary 2.5.} The semantic content of a class is fully
determined by (bases, namespace). Two classes with identical bases and
namespace are semantically equivalent, differing only in object
identity.

\subsection{C3 Linearization (Prior
Work)}\label{c3-linearization-prior-work}

\textbf{Theorem 2.6 (C3 Optimality).} C3 linearization is the unique
algorithm satisfying: 1. \textbf{Monotonicity:} If A precedes B in
linearization of C, and C' extends C, then A precedes B in linearization
of C' 2. \textbf{Local precedence:} A class precedes its parents in its
own linearization 3. \textbf{Consistency:} Linearization respects all
local precedence orderings

\emph{Proof.} See Barrett et al.~(1996), ``A Monotonic Superclass
Linearization for Dylan.'' \(\blacksquare\)

\textbf{Corollary 2.7.} Given bases, MRO is deterministically derived.
There is no configuration; there is only computation.

\subsection{Abstract Class System
Model}\label{abstract-class-system-model}

We formalize class systems independently of any specific language. This
establishes that our theorems apply to \textbf{any} language with
explicit inheritance, not just Python.

\paragraph{2.4.1 Axes}\label{the-two-axis-model}

\textbf{Definition 2.7 (Abstract Class System).} A class system is a
tuple \((B, S)\) where: - \(B\): Bases --- the set of explicitly
declared parent types (inheritance) - \(S\): Namespace --- the set of
(attribute, value) pairs defining the type's interface.

\textbf{Remark (Syntactic Names Are Not an Axis).} Language-level type names (\texttt{\_\_name\_\_} in Python, \texttt{getName()} in Java) are \emph{not} part of the semantic model. They are metadata assigned at definition time for debugging, serialization, and error messages. The semantic identity of a type---what determines its capabilities and compatibility---is fully captured by $(B, S)$. Two types with identical $(B, S)$ but different syntactic names are semantically equivalent: they support the same operations, have the same inheritance relationships, and are indistinguishable to any typing discipline. We do not include N as an axis because it adds no typing capability.

\textbf{Definition 2.8 (Class Constructor).} A class constructor is a
function: \[\text{class}: N \times \mathcal{P}(T) \times S \to T\] where
\(T\) is the universe of types, taking a name, a set of base types, and
a namespace, returning a new type.

\textbf{Language instantiations:}

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1887}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1132}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1321}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2075}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.3585}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Language
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Name
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Bases
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Namespace
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Constructor Syntax
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Python & \texttt{str} & \texttt{tuple{[}type{]}} &
\texttt{dict{[}str,\ Any{]}} &
\texttt{type(name,\ bases,\ namespace)} \\
Java & \texttt{String} & \texttt{Class\textless{}?\textgreater{}} &
method/field declarations &
\texttt{class\ Name\ extends\ Base\ \{\ ...\ \}} \\
C\# & \texttt{string} & \texttt{Type} & member declarations &
\texttt{class\ Name\ :\ Base\ \{\ ...\ \}} \\
Ruby & \texttt{Symbol} & \texttt{Class} & method definitions &
\texttt{class\ Name\ \textless{}\ Base;\ end} \\
TypeScript & \texttt{string} & \texttt{Function} & property declarations
& \texttt{class\ Name\ extends\ Base\ \{\ ...\ \}} \\
\end{longtable}

\textbf{Definition 2.9 (Reduced Class System).} A class system is
\emph{reduced} if \(B = \emptyset\) for all types (no inheritance).
Examples: Go (structs only), C (no classes), JavaScript ES5
(prototype-based, no \texttt{class} keyword).

\textbf{Remark (Implicit Root Classes).} In Python, every class
implicitly inherits from \texttt{object}: \texttt{class\ X:\ pass} has
\texttt{X.\_\_bases\_\_\ ==\ (object,)}. Definition 2.9's
``\(B = \emptyset\)'' refers to the abstract model where inheritance
from a universal root (Python's \texttt{object}, Java's \texttt{Object})
is elided. Equivalently, \(B = \emptyset\) means ``no user-declared
inheritance beyond the implicit root.'' The theorems apply when
\(B \neq \emptyset\) in this sense---i.e., when the programmer
explicitly declares inheritance relationships.

\textbf{Remark (Go Embedding $\neq$ Inheritance).} Go's struct embedding
provides method forwarding but is not inheritance: (1) embedded methods
cannot be overridden---calling \texttt{outer.Method()} always invokes
the embedded type's implementation, (2) there is no MRO---Go has no
linearization algorithm, (3) there is no \texttt{super()} equivalent.
Embedding is composition with syntactic sugar, not polymorphic
inheritance. Therefore Go has \(B = \emptyset\).

\paragraph{2.4.2 Typing Disciplines as Axis
Projections}\label{typing-disciplines-as-axis-projections}

\textbf{Definition 2.10 (Shape-Based Typing).} A typing discipline is
\emph{shape-based} if type compatibility is determined solely by \(S\)
(namespace):
\[\text{compatible}_{\text{shape}}(x, T) \iff S(\text{type}(x)) \supseteq S(T)\]

Shape-based typing projects out the \(B\) axis entirely. It cannot
distinguish types with identical namespaces.

\textbf{Remark (Operational Characterization).} In Python, shape-based
compatibility reduces to capability probing via \texttt{hasattr}:
\texttt{all(hasattr(x,\ a)\ for\ a\ in\ S(T))}. We use \texttt{hasattr}
(not \texttt{getattr}) because shape-based typing is about
\emph{capability detection}, not attribute retrieval. \texttt{getattr}
involves metaprogramming machinery (\texttt{\_\_getattr\_\_},
\texttt{\_\_getattribute\_\_}, descriptors) orthogonal to type
discipline.

\textbf{Remark (Partial vs Full Structural Compatibility).} Definition
2.10 uses partial compatibility (\(\supseteq\)): \(x\) has \emph{at
least} \(T\)'s interface. Full compatibility (\(=\)) requires exact
match. Both are \(\{S\}\)-only disciplines; the capability gap (Theorem
2.17) applies to both. The distinction is a refinement \emph{within} the
S axis, not a fourth axis.

\textbf{Definition 2.10a (Typing Discipline Completeness).} A typing
discipline is \emph{complete} if it provides a well-defined,
deterministic answer to ``when is \(x\) compatible with \(T\)?'' for all
\(x\) and declared \(T\). Formally: there exists a predicate
\(\text{compatible}(x, T)\) that is well-defined for all \((x, T)\)
pairs where \(T\) is a declared type constraint.

\textbf{Remark (Completeness vs Coherence).} Definition 2.10a defines
\emph{completeness}: whether the discipline answers the compatibility
question. Definition 8.3 later defines \emph{coherence}: whether the
discipline's answers align with runtime semantics. These are distinct
properties. A discipline can be complete but incoherent (TypeScript's
structural typing with \texttt{class}), or incomplete and thus trivially
incoherent (duck typing).

\textbf{Definition 2.10b (Structural Typing).} Structural typing with
declared interfaces (e.g., \texttt{typing.Protocol}
\cite{pep544,pep484}) is coherent: \(T\) is declared as a Protocol with
interface \(S(T)\), and compatibility is
\(S(\text{type}(x)) \supseteq S(T)\). The discipline commits to a
position: ``structure determines compatibility.''

\textbf{Definition 2.10c (Duck Typing).} Duck typing is ad-hoc
capability probing: \texttt{hasattr(x,\ attr)}
\cite{pythonBuiltinsHasattr} for individual attributes without
declaring \(T\). No interface is specified; the ``required interface''
is implicit in whichever attributes the code path happens to access.

\textbf{Theorem 2.10d (Duck Typing Incoherence).} Duck typing is not a
coherent typing discipline.

\emph{Proof.} A coherent discipline requires a well-defined
\(\text{compatible}(x, T)\) for declared \(T\). Duck typing:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Does not declare \(T\).} There is no Protocol, no interface,
  no specification of required capabilities. The ``interface'' is
  implicit in the code.
\item
  \textbf{Provides different answers based on code path.} If module
  \(A\) probes
  \texttt{hasattr(x,\ \textquotesingle{}foo\textquotesingle{})} and
  module \(B\) probes
  \texttt{hasattr(x,\ \textquotesingle{}bar\textquotesingle{})}, the
  same object \(x\) is ``compatible'' with \(A\)'s requirements iff it
  has \texttt{foo}, and ``compatible'' with \(B\)'s requirements iff it
  has \texttt{bar}. There is no unified \(T\) to check against.
\item
  \textbf{Commits to neither position on structure-semantics
  relationship:}

  \begin{itemize}
  \tightlist
  \item
    ``Structure = semantics'' would require checking \emph{full}
    structural compatibility against a declared interface
  \item
    ``Structure $\neq$ semantics'' would require nominal identity via
    inheritance
  \item
    Duck typing checks \emph{partial} structure \emph{ad-hoc} without
    declaration---neither position
  \end{itemize}
\end{enumerate}

A discipline that gives different compatibility answers depending on
which code path executes, with no declared \(T\) to verify against, is
not a discipline. It is the absence of one. \(\blacksquare\)

\textbf{Related work (duck typing formalization).} Refinement-based
analyses and logics for dynamic languages approximate duck-typed
behaviour statically (e.g., \cite{chugh2012nested,systemDArxiv}) and
empirical interface extraction for dynamic checks has been explored
\cite{lamaison2012duck}. These systems aim to prove safety for specific
programs, not to define a globally coherent predicate
\(\text{compatible}(x,T)\) for undeclared \(T\) that is stable across
code paths. Our incoherence result concerns that global typing-discipline
property (Definition 8.3); it does not deny the usefulness of such
analyses for individual programs.

\textbf{Definition 2.10b (Coherence).} A typing discipline is \emph{coherent} iff type compatibility is determined by a declared interface or type, not by ad-hoc call-site probing. Formally: coherence requires a stable compatibility predicate that exists independently of any particular call site.

\textbf{Corollary 2.10e (Duck Typing vs Structural Typing).} Duck typing
(\(\{S\}\), incoherent) is strictly weaker than structural typing with
Protocols (\(\{S\}\), coherent). Both use the same axis; the distinction is coherence.

\emph{Proof.} Protocols declare \(T\), enabling static verification,
documentation, and composition guarantees. Duck typing declares nothing.
A Protocol-based discipline is coherent (Definition 2.10b); duck typing
is not (Theorem 2.10d). \(\blacksquare\)

\textbf{Corollary 2.10f (No Valid Context for Duck Typing).} There
exists no production context where duck typing is the correct choice.

\emph{Proof.} In systems with inheritance (\(B \neq \emptyset\)):
nominal typing (\(\{B, S\}\), coherent) strictly dominates any system with fewer axes (Remark 3.82a). In systems without
inheritance (\(B = \emptyset\)): structural typing with Protocols
(\(\{S\}\), coherent) strictly dominates incoherent duck
typing (\(\{S\}\), incoherent). The only ``advantage'' of duck typing---avoiding interface
declaration---is not a capability but deferred work with negative value
(lost verification, documentation, composition guarantees).

\textbf{Note:} This establishes dominance \emph{within fixed-axis systems}. The ultimately correct choice is axis-parametric (Remark 3.82b): supporting $N$ axes costs nothing when only $k < N$ are used, but enables extension when requirements grow.
\(\blacksquare\)

\textbf{Theorem 2.10g (Structural Typing Eliminability).} In systems
with inheritance (\(B \neq \emptyset\)), structural typing is eliminable
via boundary adaptation.

\emph{Proof.} Let \(S\) be a system using Protocol \(P\) to accept
third-party type \(T\) that cannot be modified.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Adapter construction.} Define adapter class:
  \texttt{class\ TAdapter(T,\ P\_as\_ABC):\ pass}
\item
  \textbf{Boundary wrapping.} At ingestion, wrap:
  \texttt{adapted\ =\ TAdapter(instance)} (for instances) or simply use
  \texttt{TAdapter} as the internal type (for classes)
\item
  \textbf{Internal nominal typing.} All internal code uses
  \texttt{isinstance(x,\ P\_as\_ABC)} with nominal semantics
\item
  \textbf{Equivalence.} The adapted system \(S'\) accepts exactly the
  same inputs as \(S\) but uses nominal typing internally
\end{enumerate}

The systems are equivalent in capability. Structural typing provides no
capability that nominal typing with adapters lacks. \(\blacksquare\)

\textbf{Corollary 2.10h (Structural Typing as Convenience).} When
\(B \neq \emptyset\), structural typing (Protocol) is not a typing
necessity but a convenience---it avoids writing the 2-line adapter
class. Convenience is not a typing capability.

\textbf{Corollary 2.10i (Typing Discipline Hierarchy).} The typing
disciplines form a strict hierarchy. Note: N (names) is not an axis---it is syntactic sugar (Theorem 2.2). The axes are B (bases) and S (namespace).

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Duck typing} (\(\{S\}\), incoherent): No declared interface (Theorem 2.10d).
  Never valid.
\item
  \textbf{Structural typing} (\(\{S\}\), coherent): Declared interface (Protocol).
  Eliminable when \(B \neq \emptyset\) (Theorem 2.10g). Valid only when
  \(B = \emptyset\).
\item
  \textbf{Nominal typing} (\(\{B, S\}\), coherent): Declared hierarchy (ABC).
  The only non-eliminable discipline for systems with inheritance.
\end{enumerate}

\textbf{Theorem 2.10j (Protocol Is Strictly Dominated When B $\neq$ $\emptyset$).}\label{thm:protocol-strictly-dominated} In
systems with inheritance, Protocol is strictly dominated by explicit
adapters.

\emph{Proof.} Compare the two approaches for accepting third-party type
\(T\):

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2632}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2632}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4737}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Property
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Protocol
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Explicit Adapter
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Accepts same inputs & Yes & Yes \\
Documents adaptation boundary & No (implicit) & Yes (class
definition) \\
Failure mode & Runtime (\texttt{isinstance} returns False, or missing
method during execution) & Class definition time (if \(T\) lacks
required methods) \\
Provenance & No (\(T\) not in your hierarchy) & Yes (adapter is in your
hierarchy) \\
Explicit & No & Yes \\
\end{longtable}

The adapter provides strictly more: same inputs, plus explicit
documentation, plus fail-loud at definition time, plus provenance.
Protocol provides strictly less.

Protocol's only ``advantage'' is avoiding the 2-line adapter class. But
avoiding explicitness is not an advantage---it is negative value.
``Explicit is better than implicit'' (Zen of Python, line 2).
\(\blacksquare\)

\textbf{Corollary 2.10k (Protocol's Value Proposition Is Negative).}
When \(B \neq \emptyset\), Protocol trades explicitness, fail-loud
behavior, and provenance for 2 fewer lines of code. Protocol's value
proposition is negative.

\textbf{Corollary 2.10k' (Protocol Is a Concession, Not an Alternative).}
When \(B \neq \emptyset\), choosing Protocol is a \emph{concession}---accepting
reduced capabilities to defer adapter work. It is not an \emph{alternative}
because:
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item Protocol provides no capability that ABCs with adapters lack (Theorem 2.10j)
\item ABCs with adapters provide four capabilities Protocol lacks (provenance, identity, enumeration, conflict resolution)
\item The only ``benefit'' of Protocol is avoiding 2 lines of adapter code
\item Avoiding work is not a capability
\end{enumerate}
An \emph{alternative} implies comparable standing; a \emph{concession} implies
acknowledged inferiority for pragmatic expedience. Protocol is the latter.
For Python systems where \(B \neq \emptyset\), ABCs with adapters is the single
non-concession choice.

\textbf{Corollary 2.10l (Complete Typing Discipline Validity).} The
complete validity table:

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2034}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4237}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3729}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Discipline
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
When \(B \neq \emptyset\)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
When \(B = \emptyset\)
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Duck typing & Never (incoherent) & Never (incoherent) \\
Protocol & Never (dominated by adapters) & Valid (only coherent
option) \\
Nominal/Adapters & Always & N/A (requires \(B\)) \\
\end{longtable}

\paragraph{2.4.2a The Metaprogramming Capability
Gap}\label{a-the-metaprogramming-capability-gap}

Beyond typing discipline, nominal and structural typing differ in a
second, independent dimension: \textbf{metaprogramming capability}. This
gap is not an implementation accident---it is mathematically necessary.

\textbf{Definition 2.10m (Declaration-Time Event).} A
\emph{declaration-time event} occurs when a type is defined, before any
instance exists. Examples: class definition, inheritance declaration,
trait implementation.

\textbf{Definition 2.10n (Query-Time Check).} A \emph{query-time check}
occurs when type compatibility is evaluated during program execution.
Examples: \texttt{isinstance()}, Protocol conformance check, structural
matching.

\textbf{Definition 2.10o (Metaprogramming Hook).} A
\emph{metaprogramming hook} is a user-defined function that executes in
response to a declaration-time event. Examples:
\texttt{\_\_init\_subclass\_\_()}, metaclass \texttt{\_\_new\_\_()},
Rust's \texttt{\#{[}derive{]}}.

\textbf{Theorem 2.10p (Hooks Require Declarations).} Metaprogramming
hooks require declaration-time events. Structural typing provides no
declaration-time events for conformance. Therefore, structural typing
cannot provide conformance-based metaprogramming hooks.

\emph{Proof.} 1. A hook is a function that fires when an event occurs.
2. In nominal typing, \texttt{class\ C(Base)} is a declaration-time
event. The act of writing the inheritance declaration fires hooks:
Python's \texttt{\_\_init\_subclass\_\_()}, metaclass
\texttt{\_\_new\_\_()}, Java's annotation processors, Rust's derive
macros. 3. In structural typing, ``Does \(X\) conform to interface
\(I\)?'' is evaluated at query time. There is no syntax declaring
``\(X\) implements \(I\)''---conformance is inferred from structure. 4.
No declaration $\rightarrow$ no event. No event $\rightarrow$ no hook point. 5. Therefore,
structural typing cannot provide hooks that fire when a type ``becomes''
conformant to an interface. \(\blacksquare\)

\textbf{Theorem 2.10q (Enumeration Requires Registration).} To enumerate
all types conforming to interface \(I\), a registry mapping types to
interfaces is required. Nominal typing provides this registry implicitly
via inheritance declarations. Structural typing does not.

\emph{Proof.} 1. Enumeration requires a finite data structure containing
conforming types. 2. In nominal typing, each declaration
\texttt{class\ C(Base)} registers \(C\) as a subtype of \(\text{Base}\).
The transitive closure of declarations forms the registry.
\texttt{\_\_subclasses\_\_()} queries this registry in \(O(k)\) where
\(k = |\text{subtypes}(T)|\). 3. In structural typing, no registration
occurs. Conformance is computed at query time by checking structural
compatibility. 4. To enumerate conforming types under structural typing,
one must iterate over all types in the universe and check conformance
for each. In an open system (where new types can be added at any time),
\(|\text{universe}|\) is unbounded. 5. Therefore, enumeration under
structural typing is \(O(|\text{universe}|)\), which is infeasible for
open systems. \(\blacksquare\)

\textbf{Corollary 2.10r (Metaprogramming Capability Gap Is Necessary).}
The gap between nominal and structural typing in metaprogramming
capability is not an implementation choice---it is a logical consequence
of declaration vs.~query.

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2308}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3077}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3654}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.0962}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Capability
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Nominal Typing
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Structural Typing
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Why
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Definition-time hooks & Yes (\texttt{\_\_init\_subclass\_\_}, metaclass)
& No & Requires declaration event \\
Enumerate implementers & Yes (\texttt{\_\_subclasses\_\_()}, O(k)) & No
(O($\infty$) in open systems) & Requires registration \\
Auto-registration & Yes (metaclass \texttt{\_\_new\_\_}) & No & Requires
hook \\
Derive/generate code & Yes (Rust \texttt{\#{[}derive{]}}, Python
descriptors) & No & Requires declaration context \\
\end{longtable}

\textbf{Corollary 2.10s (Universal Applicability).} This gap applies to
all languages:

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1515}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1212}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3636}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3636}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Language
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Typing
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Enumerate implementers?
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Definition-time hooks?
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Go & Structural & No & No \\
TypeScript & Structural & No & No (decorators are nominal---require
\texttt{class}) \\
Python Protocol & Structural & No & No \\
Python ABC & Nominal & Yes (\texttt{\_\_subclasses\_\_()}) & Yes
(\texttt{\_\_init\_subclass\_\_}, metaclass) \\
Java & Nominal & Yes (reflection) & Yes (annotation processors) \\
C\# & Nominal & Yes (reflection) & Yes (attributes, source
generators) \\
Rust traits & Nominal (\texttt{impl}) & Yes & Yes
(\texttt{\#{[}derive{]}}, proc macros) \\
Haskell typeclasses & Nominal (\texttt{instance}) & Yes & Yes (deriving,
TH) \\
\end{longtable}

\textbf{Remark (TypeScript Decorators).} TypeScript decorators appear to
be metaprogramming hooks, but they attach to \emph{class declarations},
not structural conformance. A decorator fires when \texttt{class\ C} is
defined---this is a nominal event (the class is named and declared).
Decorators cannot fire when ``some object happens to match interface
I''---that is a query, not a declaration.

\textbf{Remark (The Two Axes of Dominance).} Nominal typing strictly
dominates structural typing on two independent axes: 1. \textbf{Typing
capability} (Theorems 2.10j, 2.18): Provenance, identity, enumeration,
conflict resolution 2. \textbf{Metaprogramming capability} (Theorems
2.10p, 2.10q): Hooks, registration, code generation

Neither axis is an implementation accident. Both follow from the
structure of declaration vs.~query. Protocol is dominated on both axes.

\textbf{Remark.} Languages without inheritance (Go) have
\(B = \emptyset\) by design. For these languages, structural typing with
declared interfaces is the correct choice---not because structural
typing is superior, but because nominal typing requires \(B\) and Go
provides none. Go's interfaces are coherent (\(\{S\}\), declared). Go does not
use duck typing.

\textbf{Remark (Historical Context).} Duck typing became established in
Python practice without formal capability analysis. This paper provides
the first machine-verified comparison of typing discipline capabilities.
See Appendix~\ref{appendix:historical} for additional historical context.

\textbf{Definition 2.11 (Nominal Typing).} A typing discipline is
\emph{nominal} if type compatibility requires identity in the
inheritance hierarchy:
\[\text{compatible}_{\text{nominal}}(x, T) \iff T \in \text{ancestors}(\text{type}(x))\]

where
\(\text{ancestors}(C) = \{C\} \cup \bigcup_{P \in B(C)} \text{ancestors}(P)\)
(transitive closure over \(B\)).

\paragraph{2.4.3 Provenance as MRO Query}\label{provenance-as-mro-query}

\textbf{Definition 2.12 (Provenance Query).} A provenance query asks:
``Given object \(x\) and attribute \(a\), which type
\(T \in \text{MRO}(\text{type}(x))\) provided the value of \(a\)?''

\textbf{Theorem 2.13 (Provenance Requires MRO).} Provenance queries
require access to MRO, which requires access to \(B\).

\emph{Proof.} MRO is defined as a linearization over ancestors, which is
the transitive closure over \(B\). Without \(B\), MRO is undefined.
Without MRO, provenance queries cannot be answered. \(\blacksquare\)

\textbf{Corollary 2.14 (Shape-Based Typing Cannot Provide Provenance).}
Shape-based typing cannot answer provenance queries.

\emph{Proof.} By Definition 2.10, shape-based typing uses only \(S\). By
Theorem 2.13, provenance requires \(B\). Shape-based typing has no
access to \(B\). Therefore shape-based typing cannot provide provenance.
\(\blacksquare\)

\paragraph{2.4.3a Representational Cost}\label{representational-cost}

\textbf{Definition 2.14a (Query Interface).} For a domain $D$, let $Q_D$ be the set of queries the domain will ever ask of the type system. A query $q \in Q_D$ is a function from types to answers: $q : \text{Type} \to \text{Answer}$.

\textbf{Definition 2.14b (Adequacy).} A representation $R$ is \emph{adequate} for $Q_D$ if every query $q \in Q_D$ factors through $R$. That is, for each $q$, there exists $f$ such that $q = f \circ R$.

\textbf{Definition 2.14c (Representational Cost).} The \emph{representational cost} of representation $R$ for query set $Q_D$ is:
\[\text{cost}(R, Q_D) := \min\{\text{bits required by any adequate representation}\}\]

This is an information-theoretic measure: the minimal state/bits needed to answer the declared queries. Human factors (cognitive load, learning curves) are explicitly out of scope.

\textbf{Theorem 2.14d (No Unnecessary Cost).} If an axis $X$ is never used by any query in $Q_D$, then adding $X$ as a constant field adds zero semantic cost.

\emph{Proof.} A constant carries zero bits of information. If no query in $Q_D$ inspects $X$, then the representation with $X := \star$ (constant) answers exactly the same queries as the representation without $X$. The minimal adequate information is unchanged. \(\blacksquare\)

\textbf{Theorem 2.14e (Necessity of Axes).} If there exist types $t_1, t_2$ such that:
\begin{enumerate}
\item $t_1$ and $t_2$ are equal under any projection that drops axis $X$, but
\item some query $q \in Q_D$ returns different answers: $q(t_1) \neq q(t_2)$,
\end{enumerate}
then any adequate representation for $Q_D$ must carry at least one bit distinguishing $t_1$ from $t_2$---i.e., the cost is forced by the query set.

\emph{Proof.} Suppose $R$ is adequate for $Q_D$ and drops $X$. Then $R(t_1) = R(t_2)$ by hypothesis (1). But adequacy requires $q = f \circ R$, so $q(t_1) = f(R(t_1)) = f(R(t_2)) = q(t_2)$. This contradicts hypothesis (2). Therefore no representation dropping $X$ is adequate. \(\blacksquare\)

\textbf{Corollary 2.14f (Necessity of B).} For any domain $D$ that asks provenance queries, the Bases axis $B$ is necessary. The cost of including $B$ is forced by the query set, not a design choice.

\emph{Proof.} Immediate from Theorem 2.14e with $X = B$: Theorem 2.13 shows provenance requires MRO, which requires $B$. Types with identical $S$ but different $B$ can have different provenance. \(\blacksquare\)

\paragraph{2.4.4 Cross-Language Instantiation}\label{cross-language-instantiation}

\begin{table}[h]
\caption{Cross-language instantiation of the (B, S) model}
\label{tab:nbs-cross}
\footnotesize
\setlength{\tabcolsep}{4pt}
\begin{tabular}{@{}p{1.1cm}p{2.6cm}p{3.2cm}p{3.2cm}p{1.2cm}@{}}
\toprule
Lang. & N (Name) & B (Bases) & S (Namespace) & Type \\
\midrule
Python & \texttt{type(x).} \texttt{\_\_name\_\_} & \texttt{\_\_bases\_\_}; \texttt{\_\_mro\_\_} & \texttt{\_\_dict\_\_}; \texttt{dir()} & Nominal \\
Java   & \texttt{getClass()} \texttt{.getName()} & \texttt{getSuperclass()}, \texttt{getInterfaces()} & \texttt{getDecl\-ared\-Methods()} & Nominal \\
Ruby   & \texttt{obj.class} \texttt{.name} & \texttt{ancestors} (ordered) & \texttt{methods}, \texttt{instance\_variables} & Nominal \\
C\#    & \texttt{GetType()} \texttt{.Name} & \texttt{BaseType}, \texttt{GetInterfaces()} & \texttt{GetProperties()}, \texttt{GetMethods()} & Nominal \\
\bottomrule
\end{tabular}
\end{table}

All four languages provide \textbf{runtime access to both axes}.

\textbf{Clarification (Syntactic Names vs.\ Semantic Identity).} In our model, the semantic identity of a type is determined by $(B, S)$. The syntactic name (\texttt{\_\_name\_\_} in Python, \texttt{getName()} in Java) is \emph{not} computable from $(B, S)$---it is metadata assigned at definition time. When we say ``N is not an axis,'' we mean: the semantic content that determines type compatibility and capabilities is fully captured by $(B, S)$. Two types with identical $(B, S)$ are semantically equivalent for all typing purposes, even if they have different \texttt{\_\_name\_\_} strings. The syntactic name is useful for debugging and serialization but contributes no typing capability beyond what $(B, S)$ provides.

The critical difference lies in which axes the \textbf{type system} inspects.

\textbf{Table 2.2: Generic Types Across Languages --- Extended $(B, S)$,
Not a Third Axis}

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2083}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2083}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2083}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3750}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Language
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Generics
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Encoding
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Runtime Behavior
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Java & \texttt{List\textless{}T\textgreater{}} & Parameterized N:
\texttt{(List,\ {[}T{]})} & Erased to \texttt{List} \\
C\# & \texttt{List\textless{}T\textgreater{}} & Parameterized N:
\texttt{(List,\ {[}T{]})} & Fully reified \\
TypeScript & \texttt{Array\textless{}T\textgreater{}} & Parameterized N:
\texttt{(Array,\ {[}T{]})} & Compile-time only \\
Rust & \texttt{Vec\textless{}T\textgreater{}} & Parameterized N:
\texttt{(Vec,\ {[}T{]})} & Monomorphized \\
Kotlin & \texttt{List\textless{}T\textgreater{}} & Parameterized N:
\texttt{(List,\ {[}T{]})} & Erased (reified via \texttt{inline}) \\
Swift & \texttt{Array\textless{}T\textgreater{}} & Parameterized N:
\texttt{(Array,\ {[}T{]})} & Specialized at compile-time \\
Scala & \texttt{List{[}T{]}} & Parameterized N:
\texttt{(List,\ {[}T{]})} & Erased \\
C++ & \texttt{vector\textless{}T\textgreater{}} & Parameterized N:
\texttt{(vector,\ {[}T{]})} & Template instantiation \\
\end{longtable}

\textbf{Key observation:} No major language invented a fourth axis for
generics. Generic type parameters extend the $(B, S)$ axes: type arguments become part of the namespace $S$ (determining available operations) and may influence $B$ (inheritance from parameterized parents). The $(B, S)$ model is \textbf{universal} across generic type systems.

\subsection{The Axis Lattice
Metatheorem}\label{the-axis-lattice-metatheorem}

The two-axis model \((B, S)\) induces a lattice of typing
disciplines. Each discipline is characterized by which axes it inspects:

\textbf{Clarification: N is not an axis.} Syntactic names are metadata, not semantic content (see Definition 2.7 remark). The semantic axes are B (bases) and S (namespace). What distinguishes disciplines using the same axes is \emph{coherence}: whether compatibility is determined by a declared contract.

\small
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Discipline & Axes & Coherent? & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Untyped & \(\emptyset\) & N/A & Accept all \\
Duck typing & \(\{S\}\) & No & \texttt{hasattr} probing \\
Structural (declared) & \(\{S\}\) & Yes & OCaml row types, \texttt{Protocol} \\
Nominal & \(\{B, S\}\) & Yes & ABCs, \texttt{isinstance} \\
\end{longtable}

\textbf{Critical distinction within \(\{S\}\):} Duck typing and structural typing (Protocol, OCaml) use the same axis set. The difference is coherence (Definition 2.10b):

\small
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Discipline & Axes & Interface Declared? & Coherent? \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Duck typing & \(\{S\}\) & No (ad-hoc \texttt{hasattr}) & No (Thm 2.10d) \\
OCaml structural & \(\{S\}\) & Yes (inline type) & Yes \\
Protocol & \(\{S\}\) & Yes (named interface) & Yes \\
Nominal & \(\{B, S\}\) & Yes (class hierarchy) & Yes \\
\end{longtable}

Duck typing and OCaml structural typing both use \(\{S\}\), but duck
typing has \textbf{no declared interface}---conformance is checked
ad-hoc at runtime via \texttt{hasattr}. OCaml declares the interface
inline:
\texttt{\textless{}\ get\ :\ int;\ set\ :\ int\ -\textgreater{}\ unit\ \textgreater{}}
is a complete type specification, statically verified.

\textbf{Protocol also uses \(\{S\}\).} The Protocol \emph{name} is not an axis---it is a label for a declared shape. The difference from duck typing is that Protocol declares the shape upfront (coherent), while duck typing probes ad-hoc (incoherent).

\textbf{Theorem 2.10d (Incoherence) applies to duck typing, not to
Protocol or OCaml.} The incoherence arises from the lack of a declared interface,
not from using axis subset \(\{S\}\).

\textbf{Theorems 2.10p-q (Metaprogramming Gap) apply to structural typing.}
Structural disciplines (Protocol, OCaml) cannot enumerate conforming types
or provide definition-time hooks, because conformance is checked at use sites, not at a declaration event. This is independent of coherence.

Note: \texttt{hasattr(obj,\ \textquotesingle{}foo\textquotesingle{})}
checks namespace membership via the S axis.
Our provenance impossibility theorems apply to all \(\{S\}\)-only disciplines.

\textbf{Theorem 2.15 (Axis Lattice Dominance).} For any axis subsets
\(A \subseteq A' \subseteq \{B, S\}\), the capabilities of discipline
using \(A\) are a subset of capabilities of discipline using \(A'\):
\[\text{capabilities}(A) \subseteq \text{capabilities}(A')\]

\emph{Proof.} Each axis enables specific capabilities:
\begin{itemize}
\tightlist
\item \(B\): Provenance, identity, enumeration, conflict resolution
\item \(S\): Interface checking
\end{itemize}
Names are labels, not axes (Theorem 2.2). A discipline using subset \(A\) can only employ capabilities enabled by
axes in \(A\). Adding an axis to \(A\) adds capabilities but removes
none. Therefore the capability sets form a monotonic lattice under
subset inclusion. \(\blacksquare\)

\textbf{Corollary 2.16 (Bases Axis Primacy).} The Bases axis \(B\) is
the source of all strict dominance. Specifically: provenance, type
identity, subtype enumeration, and conflict resolution all require
\(B\). Any discipline that discards \(B\) forecloses these capabilities.

\textbf{Theorem 2.17 (Capability Completeness).} The capability set
\(\mathcal{C}_B = \{\text{provenance, identity, enumeration, conflict resolution}\}\)
is \textbf{exactly} the set of capabilities enabled by the Bases axis.
Formally:

\[c \in \mathcal{C}_B \iff c \text{ requires } B\]

\emph{Proof.} We prove both directions:

\textbf{(\(\Rightarrow\)) Each capability in \(\mathcal{C}_B\) requires
\(B\):}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Provenance} (``which type provided value \(v\)?''): By
  Definition 2.12, provenance queries require MRO traversal. MRO is the
  C3 linearization of ancestors, which is the transitive closure over
  \(B\). Without \(B\), MRO is undefined. \(\checkmark\)
\item
  \textbf{Identity} (``is \(x\) an instance of \(T\)?''): By Definition
  2.11, nominal compatibility requires
  \(T \in \text{ancestors}(\text{type}(x))\). Ancestors is defined as
  transitive closure over \(B\). Without \(B\), ancestors is undefined.
  \(\checkmark\)
\item
  \textbf{Enumeration} (``what are all subtypes of \(T\)?''): A subtype
  \(S\) of \(T\) satisfies \(T \in \text{ancestors}(S)\). Enumerating
  subtypes requires inverting the ancestor relation, which requires
  \(B\). \(\checkmark\)
\item
  \textbf{Conflict resolution} (``which definition wins in diamond
  inheritance?''): Diamond inheritance produces multiple paths to a
  common ancestor. Resolution uses MRO ordering, which requires \(B\).
  \(\checkmark\)
\end{enumerate}

\textbf{(\(\Leftarrow\)) No other capability requires \(B\):}

We exhaustively enumerate capabilities NOT in \(\mathcal{C}_B\) and show
none require \(B\):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\item
  \textbf{Interface checking} (``does \(x\) have method \(m\)?''):
  Answered by inspecting \(S(\text{type}(x))\). Requires only \(S\).
  Does not require \(B\). \(\checkmark\)
\item
  \textbf{Type naming} (``what is the name of type \(T\)?''): Answered
  by inspecting \(N(T)\). Requires only \(N\). Does not require \(B\).
  \(\checkmark\)
\item
  \textbf{Value access} (``what is \(x.a\)?''): Answered by attribute
  lookup in \(S(\text{type}(x))\). Requires only \(S\). Does not require
  \(B\). \(\checkmark\)

  \textbf{Remark (Inherited Attributes).} For inherited attributes,
  \(S(\text{type}(x))\) means the \emph{effective} namespace including
  inherited members. Computing this effective namespace initially
  requires \(B\) (to walk the MRO), but once computed, accessing a value
  from the flattened namespace requires only \(S\). The distinction is
  between \emph{computing} the namespace (requires \(B\)) and
  \emph{querying} a computed namespace (requires only \(S\)). Value
  access is the latter.
\item
  \textbf{Method invocation} (``call \(x.m()\)''): Answered by
  retrieving \(m\) from \(S\) and invoking. Requires only \(S\). Does
  not require \(B\). \(\checkmark\)
\end{enumerate}

No capability outside \(\mathcal{C}_B\) requires \(B\). Therefore
\(\mathcal{C}_B\) is exactly the \(B\)-dependent capabilities.
\(\blacksquare\)

\textbf{Significance:} This is a \textbf{tight characterization}, not an
observation. The capability gap is not ``here are some things you
lose''---it is ``here is \textbf{exactly} what you lose, nothing more,
nothing less.'' This completeness result is what distinguishes a formal
theory from an enumerated list.

\textbf{Theorem 2.18 (Strict Dominance --- Abstract).} In any class
system with \(B \neq \emptyset\), nominal typing strictly dominates
shape-based typing.

\emph{Proof.} Let \(\mathcal{C}_{\text{shape}}\) = capabilities of
shape-based typing. Let \(\mathcal{C}_{\text{nominal}}\) = capabilities
of nominal typing.

Shape-based typing can check interface satisfaction:
\(S(\text{type}(x)) \supseteq S(T)\).

Nominal typing can: 1. Check interface satisfaction (equivalent to
shape-based) 2. Check type identity:
\(T \in \text{ancestors}(\text{type}(x))\) --- \textbf{impossible for
shape-based} 3. Answer provenance queries --- \textbf{impossible for
shape-based} (Corollary 2.14) 4. Enumerate subtypes ---
\textbf{impossible for shape-based} 5. Use type as dictionary key ---
\textbf{impossible for shape-based}

Therefore
\(\mathcal{C}_{\text{shape}} \subset \mathcal{C}_{\text{nominal}}\)
(strict subset). In a class system with \(B \neq \emptyset\), both
disciplines are available. Choosing shape-based typing forecloses
capabilities for zero benefit. \(\blacksquare\)

\paragraph{2.5.1 The Decision Procedure}\label{the-decision-procedure}

Given a language \(L\) and development context \(C\):

\begin{verbatim}
FUNCTION select_typing_discipline(L, C):
    IF L has no inheritance syntax (B = {}):
        RETURN structural  # Theorem 3.1: correct when B absent

    # For all cases where B != {}:
    RETURN nominal  # Theorem 2.18: strict dominance

    # Note: "retrofit" is not a separate case. When integrating
    # external types, use explicit adapters (Theorem 2.10j).
    # Protocol is a convenience, not a correct discipline.
\end{verbatim}

This is a \textbf{decision procedure}, not a preference. The output is
determined by whether \(B = \emptyset\).

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}
