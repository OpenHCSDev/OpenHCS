\subsection{Observational Constraints and Semantic Inference}

Consider the following inference problem: a procedure observes a program value and must determine its semantic properties (e.g., type identity, provenance). The procedure's access is restricted to a fixed family of \emph{interface observations}---predicates that test membership in declared interfaces.

\begin{definition}[Interface observation family]
Fix a set of interfaces $\mathcal{I}$. For each $I \in \mathcal{I}$, define the interface-membership observation $q_I: \mathcal{V} \to \{0,1\}$, where $q_I(v) = 1$ iff $v$ satisfies interface $I$. Let $\Phi_{\mathcal{I}} = \{q_I : I \in \mathcal{I}\}$.
\end{definition}

\begin{definition}[Interface profile]
Define $\pi: \mathcal{V} \to \{0,1\}^{\mathcal{I}}$ by $\pi(v) = (q_I(v))_{I \in \mathcal{I}}$.
\end{definition}

\begin{definition}[Interface indistinguishability]
$v \sim w$ iff $\pi(v) = \pi(w)$.
\end{definition}

\begin{definition}[Interface-only procedure]
An interface-only procedure is any algorithm whose interaction with a value is limited to queries in $\Phi_{\mathcal{I}}$.
\end{definition}

The central question is: \textbf{what semantic properties can an interface-only procedure compute?}

\subsection{The Impossibility Barrier}

\begin{theorem}[Information barrier from interface-only evidence]
Every interface-only procedure is constant on $\sim$-equivalence classes. Consequently, no interface-only procedure can compute any property that differs for some $v \sim w$.
\end{theorem}

This is an information barrier: the restriction is not computational (unbounded time/memory does not help) but informational (the evidence itself is insufficient).

\subsection{The Positive Result: Nominal Tagging}

In contrast, nominal tagging—storing an explicit type identifier per value—provides constant-size evidence for type identity.

\begin{definition}[Witness cost]
Let $W(P)$ denote the minimum number of primitive queries required to compute property $P$. A primitive query is either an interface observation $q_I \in \Phi_{\mathcal{I}}$ or a nominal-tag access (reading the type identifier).
\end{definition}

\begin{theorem}[Constant witness for nominal type identity]
Nominal-tag access admits a constant-cost witness for type identity: $W(\text{type-identity}) = O(1)$ primitive queries.
\end{theorem}

\subsection{Main Contributions}

\begin{enumerate}
\item \textbf{Impossibility Theorem}: No interface-only procedure can compute properties that vary within $\sim$-equivalence classes (Theorem 1).

\item \textbf{Constant-Witness Result}: Nominal tagging achieves $W(\text{type-identity}) = O(1)$ (Theorem 2).

\item \textbf{Equicardinality Theorem}: All minimal complete type axis sets have equal cardinality (a consequence of matroid-like structure).

\item \textbf{Rate–Witness–Distortion Optimality}: Nominal-tag observers achieve the unique Pareto-optimal point in the $(L, W, D)$ tradeoff (tag length, witness cost, distortion).

\item \textbf{Machine-Checked Proofs}: All results formalized in Lean 4 (\textasciitilde6,000 lines, 265 theorems, 0 sorry).
\end{enumerate}

\subsection{Audience and Scope}

This paper is written for the information theory and compression community. We assume familiarity with matroid theory and basic information-theoretic concepts. We provide concrete instantiations in widely used programming language runtimes (CPython, Java, TypeScript, Rust) as corollaries to the main theorems.

