\subsection{Observational Constraints and Semantic Inference}

Consider the following inference problem: a procedure observes a program value and must determine its semantic properties (e.g., type identity, provenance). The procedure's access is restricted to a fixed set of \emph{shape queries}---observations that depend only on the structural interface of a value, not on its identity or provenance.

\begin{definition}[Shape query set]
The \emph{shape query set} $\mathcal{Q}$ is the set of all predicates $q: \mathcal{V} \to \{0,1\}$ that are \emph{shape-respecting}: if two values have the same structural interface (fields, methods, signatures), then $q$ returns the same answer on both. Examples include ``has method \texttt{foo}'' or ``field \texttt{x} has type \texttt{int}.''
\end{definition}

\begin{definition}[Shape-only procedure]
A shape-only procedure is any algorithm whose interaction with a value is limited to queries in $\mathcal{Q}$.
\end{definition}

\begin{definition}[Shape equivalence]
For values $x, y$, write $x \sim y$ iff $q(x) = q(y)$ for all $q \in \mathcal{Q}$.
\end{definition}

The central question is: \textbf{what semantic properties can a shape-only procedure compute?}

\subsection{The Impossibility Barrier}

\begin{theorem}[Impossibility from shape-only evidence]
Every shape-only procedure is constant on $\sim$-equivalence classes. Consequently, no shape-only procedure can compute any property that differs for some $x \sim y$.
\end{theorem}

This is an information barrier: the restriction is not computational (unbounded time/memory does not help) but informational (the evidence itself is insufficient).

\subsection{The Positive Result: Nominal Tagging}

In contrast, nominal tagging—storing an explicit type identifier per value—provides constant-size evidence for type identity.

\begin{definition}[Witness cost]
Let $W(P)$ denote the minimum number of primitive queries required to compute property $P$. A primitive query is either a shape query $q \in \mathcal{Q}$ or a nominal-tag access (reading the type identifier).
\end{definition}

\begin{theorem}[Constant witness for nominal type identity]
Nominal-tag access admits a constant-cost witness for type identity: $W(\text{type-identity}) = O(1)$ primitive queries.
\end{theorem}

\subsection{Main Contributions}

\begin{enumerate}
\item \textbf{Impossibility Theorem}: No shape-only procedure can compute properties that vary within $\sim$-equivalence classes (Theorem 1).

\item \textbf{Constant-Witness Result}: Nominal tagging achieves $W(\text{type-identity}) = O(1)$ (Theorem 2).

\item \textbf{Equicardinality Theorem}: All minimal complete type axis sets have equal cardinality (a consequence of matroid-like structure).

\item \textbf{Rate–Witness–Distortion Optimality}: Nominal tagging achieves the unique Pareto-optimal point in the (tag-length, witness-length, error-rate) tradeoff.

\item \textbf{Machine-Checked Proofs}: All results formalized in Lean 4 (\textasciitilde6,000 lines, 265 theorems, 0 sorry).
\end{enumerate}

\subsection{Audience and Scope}

This paper is written for the information theory and compression community. We assume familiarity with matroid theory and basic information-theoretic concepts. We provide concrete instantiations in widely used programming language runtimes (CPython, Java, TypeScript, Rust) as corollaries to the main theorems.

