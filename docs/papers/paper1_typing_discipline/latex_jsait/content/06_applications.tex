\subsection{CPython: Nominal-Tag Access}

\begin{corollary}[CPython instantiation]
CPython realizes nominal-tag access: the runtime stores a type tag (\texttt{ob\_type} pointer) per object and exposes it via the \texttt{type()} builtin. Therefore, the constant-witness construction applies: $W(\text{type-identity}) = O(1)$ in CPython.
\end{corollary}

\textbf{Evidence:} The CPython object model stores a pointer to the type object (\texttt{ob\_type}) in every heap-allocated value \cite{CPythonDocs}. The \texttt{type()} builtin \cite{PythonDocs} is a single pointer dereference, hence $O(1)$ primitive queries.

\subsection{Java: Nominal-Tag Access}

\begin{corollary}[Java instantiation]
Java realizes nominal-tag access via the \texttt{.getClass()} method, which returns the runtime type object. Like CPython, Java achieves $W(\text{type-identity}) = O(1)$.
\end{corollary}

\subsection{TypeScript: Structural Typing}

\begin{corollary}[TypeScript instantiation]
TypeScript uses interface-only (declared) observation: two types are equivalent iff they have the same structure (fields and method signatures). Type identity checking requires traversing the structure, hence $W(\text{type-identity}) = O(n)$ where $n$ is the structure size.
\end{corollary}

\subsection{Rust: Nominal-Tag Access (Compile-Time)}

\begin{corollary}[Rust instantiation]
Rust uses nominal typing at compile time: type identity is resolved statically via the type system. At runtime, Rust provides \texttt{std::any::type\_id()} for nominal-tag access, achieving $W(\text{type-identity}) = O(1)$.
\end{corollary}

\subsection{Summary: Witness Cost Across Runtimes}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Language} & \textbf{Observer Class} & \textbf{Witness Cost $W$} \\
\hline
CPython & Nominal-tag & $O(1)$ \\
Java & Nominal-tag & $O(1)$ \\
TypeScript & Interface-only (declared) & $O(n)$ \\
Rust & Nominal-tag & $O(1)$ \\
\hline
\end{tabular}
\caption{Witness cost for type identity across programming language runtimes.}
\end{table}

These instantiations realize the abstract observer model: nominal-tag observers achieve constant witness cost, while interface-only observers require linear witness cost in the number of interfaces.

