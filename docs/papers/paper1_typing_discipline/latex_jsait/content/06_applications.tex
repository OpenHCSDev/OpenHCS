The preceding sections established abstract results about observer classes and witness cost. We now ground these in concrete systems across multiple domains, showing that real classification systems instantiate the theoretical categories and that the complexity bounds are not artifacts of the model but observable properties of deployed implementations.

\subsection{Biological Taxonomy: Phenotype vs Genotype}

Linnean taxonomy classifies organisms by observable phenotypic characters: morphology, behavior, habitat. This is attribute-only observation. The information barrier applies: phenotypically identical organisms from distinct species are indistinguishable.

\textbf{The cryptic species problem:} Cryptic species share identical phenotypic profiles but are reproductively isolated and genetically distinct. Attribute-only observation (morphology) cannot distinguish them: $\pi(A) = \pi(B)$ but $\text{species}(A) \neq \text{species}(B)$.

\textbf{The nominal tag:} DNA barcoding provides the resolution \cite{DNABarcoding}. A short genetic sequence (e.g., mitochondrial COI) acts as the nominal tag: $O(1)$ identity verification via sequence comparison. This reduced cryptic species identification from $\Omega(s)$ phenotypic examination (checking $s$ characters) to constant-time molecular lookup.

\subsection{Library Classification: Subject vs ISBN}

Library classification systems like Dewey Decimal observe subject matter, a form of attribute-only classification. Two books on the same subject are indistinguishable by subject code alone.

\textbf{The nominal tag:} The ISBN (International Standard Book Number) is the nominal tag \cite{ISBN}. Given two physical books, identity verification is $O(1)$: compare ISBNs. Without ISBNs, distinguishing two copies of different editions on the same subject requires $O(s)$ attribute inspection (publication date, page count, publisher, etc.).

\subsection{Database Systems: Columns vs Primary Keys}

In big-data systems, relational databases observe entities via column values. The information barrier applies: rows with identical column values, excluding the key, are indistinguishable.

\textbf{The nominal tag:} The primary key is the nominal tag \cite{Codd1990}. Entity identity is $O(1)$: compare keys. This is why database theory requires keys---without them, the system cannot answer ``is this the same entity?''

\textbf{Natural vs surrogate keys:} Natural keys (composed of attributes) are attribute-only observation and inherit its limitations. Surrogate keys (auto-increment IDs, UUIDs) are pure nominal tags: no semantic content, pure identity.

\subsection{Programming Language Runtimes}

Type systems are the motivating example for this work. We survey four runtimes.

\subsubsection{CPython: The \texttt{ob\_type} Pointer}

Every CPython heap object begins with a \texttt{PyObject} header containing an \texttt{ob\_type} pointer to its type object \cite{CPythonDocs}. This is the nominal tag: a single machine word encoding complete type identity.

\textbf{Witness procedure:} Given objects \texttt{a} and \texttt{b}, type identity is \texttt{type(a) is type(b)}---two pointer dereferences and one pointer comparison. Cost: $O(1)$ primitive operations, independent of interface count.

\textbf{Contrast with \texttt{hasattr}:} Interface-only observation in Python uses \texttt{hasattr(obj, name)} for each required method. To verify an object satisfies a protocol with $s$ required methods requires $s$ attribute lookups. Worse: different call sites may check different subsets, creating $\Omega(m)$ total checks where $m$ is the number of call sites. The nominal tag eliminates this entirely.

\subsubsection{Java: \texttt{.getClass()} and the Method Table}

Java's object model stores a pointer to the class object in every instance header \cite{JVMSpec}. The \texttt{.getClass()} method exposes this \cite{JavaDocs}, and \texttt{instanceof} checks traverse the class hierarchy.

\textbf{Key observation:} Java's \texttt{instanceof} is $O(d)$ where $d$ is inheritance depth, not $O(|\mathcal{I}|)$ where $|\mathcal{I}|$ is the number of interfaces. This is because \texttt{instanceof} walks the inheritance hierarchy (a nominal-tag query), not the interface list (an attribute query).

\subsubsection{TypeScript: Structural Equivalence}

TypeScript uses attribute-only (declared) observation \cite{TypeScriptDocs}: the compiler checks structural compatibility, not nominal identity. Two types are assignment-compatible iff their structures match.

\textbf{Implication:} Type identity checking requires traversing the structure. For a type with $s$ fields/methods, $W(\text{type-identity}) = O(s)$. This is inherent to the observation model: no compilation strategy can reduce this to $O(1)$ without adding nominal tags.

\subsubsection{Rust: Static Nominal Tags}

Rust resolves type identity at compile time via its nominal type system. At runtime, \texttt{std::any::TypeId} provides nominal-tag access \cite{RustDocs}.

\textbf{The \texttt{dyn Trait} case:} Rust's trait objects include a vtable pointer but not a type tag \cite{RustTraitObjects}. This is attribute-only observation: the vtable encodes which methods exist, not which type provided them.

\subsection{Cross-Domain Summary}

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|c|}
\hline
\textbf{Domain} & \textbf{Attribute-Only} & \textbf{Nominal Tag} & \textbf{$W$} \\
\hline
Biology & Phenotype (morphology) & DNA barcode (COI) & $O(1)$ \\
Libraries & Subject (Dewey) & ISBN & $O(1)$ \\
Databases & Column values & Primary key & $O(1)$ \\
CPython & \texttt{hasattr} probing & \texttt{ob\_type} pointer & $O(1)$ \\
Java & Interface check & \texttt{.getClass()} & $O(1)$ \\
TypeScript & Structural check & (none at runtime) & $O(s)$ \\
Rust (static) & Trait bounds & \texttt{TypeId} & $O(1)$ \\
\hline
\end{tabular}
\caption{Witness cost for identity across classification systems. Nominal tags achieve $O(1)$; attribute-only pays $O(s)$ per structural check (or $O(k)$ when enumerating classes/declared interfaces).}
\end{table}

The pattern is universal: systems with nominal tags achieve $O(1)$ witness cost; systems without them pay $O(s)$ or $O(k)$. This is not domain-specific; it is the information barrier theorem instantiated across classification systems.

\subsection{Machine Learning: Model Identification and Versioning}

Neural network models in production systems face the identification problem: given two model instances, determine if they represent the same architecture. Model registries must compress model metadata while enabling efficient identification.

\textbf{Attribute-only approach:} Compare architecture fingerprints (layer counts, activation functions, parameter counts, connectivity patterns). Cost: $O(s)$ where $s$ is the number of architectural features.

\textbf{Nominal tag:} Model hash (e.g., SHA-256 of architecture definition) or registry ID. Cost: $O(1)$.

The $(L, W, D)$ tradeoff applies directly: storing $\lceil \log_2 k \rceil$ bits per model (where $k$ is the number of distinct architectures in the registry) enables $O(1)$ identification with $D = 0$. Attribute-based versioning requires $\Omega(d)$ feature comparisons and risks false positives ($D > 0$) when architectures share identical fingerprints but differ in subtle structural details.

\textbf{Example:} A model registry with $k = 10^6$ architectures requires only 20 bits per model for perfect identification via nominal tags, versus $O(d)$ queries over potentially hundreds of architectural features for attribute-based approaches.
