The preceding sections established abstract results about observer classes and witness cost. We now ground these in concrete runtime mechanisms, showing that real systems instantiate the theoretical categories---and that the complexity bounds are not artifacts of the model but observable properties of deployed implementations.

\subsection{CPython: The \texttt{ob\_type} Pointer}

Every CPython heap object begins with a \texttt{PyObject} header containing an \texttt{ob\_type} pointer to its type object \cite{CPythonDocs}. This is the nominal tag: a single machine word encoding complete type identity.

\textbf{Witness procedure:} Given objects \texttt{a} and \texttt{b}, type identity is \texttt{type(a) is type(b)}---two pointer dereferences and one pointer comparison. Cost: $O(1)$ primitive operations, independent of interface count.

\textbf{Contrast with \texttt{hasattr}:} Interface-only observation in Python uses \texttt{hasattr(obj, name)} for each required method. To verify an object satisfies a protocol with $k$ methods requires $k$ attribute lookups. Worse: different call sites may check different subsets, creating $\Omega(n)$ total checks where $n$ is the number of call sites. The nominal tag eliminates this entirely.

\subsection{Java: \texttt{.getClass()} and the Method Table}

Java's object model stores a pointer to the class object in every instance header. The \texttt{.getClass()} method exposes this, and \texttt{instanceof} checks traverse the class hierarchy.

\textbf{Key observation:} Java's \texttt{instanceof} is $O(d)$ where $d$ is inheritance depth, not $O(|\mathcal{I}|)$ where $|\mathcal{I}|$ is the number of interfaces. This is because \texttt{instanceof} walks the MRO (a $B$-axis query), not the interface list (an $S$-axis query). The JVM caches frequent \texttt{instanceof} results, but even without caching, the bound depends on inheritance depth---typically small---not interface count.

\subsection{TypeScript: Structural Equivalence}

TypeScript uses interface-only (declared) observation: the compiler checks structural compatibility, not nominal identity. Two types are assignment-compatible iff their structures match.

\textbf{Implication:} Type identity checking requires traversing the structure. For a type with $n$ fields/methods, $W(\text{type-identity}) = O(n)$. This is not a limitation of TypeScript's implementation; it is inherent to the observation model. The information barrier theorem applies: no compilation strategy can reduce this to $O(1)$ without adding nominal tags.

\textbf{Runtime erasure:} TypeScript compiles to JavaScript with types erased. At runtime, there are no type tags---only the objects themselves. This is interface-only observation in its purest form: the runtime literally cannot perform nominal-tag queries because the tags do not exist.

\subsection{Rust: Static Nominal Tags}

Rust resolves type identity at compile time via its nominal type system. At runtime, \texttt{std::any::TypeId} provides nominal-tag access for \texttt{'static} types.

\textbf{The \texttt{dyn Trait} case:} Rust's trait objects (\texttt{dyn Trait}) include a vtable pointer but not a type tag. This is interface-only observation: the vtable encodes which methods exist, not which type provided them. Consequently, \texttt{dyn Trait} values cannot answer ``which concrete type am I?'' without additional machinery (\texttt{Any} downcasting, which re-introduces the nominal tag).

\subsection{Summary}

\begin{table}[h]
\centering
\begin{tabular}{|l|l|c|l|}
\hline
\textbf{Language} & \textbf{Mechanism} & \textbf{$W$} & \textbf{Notes} \\
\hline
CPython & \texttt{ob\_type} pointer & $O(1)$ & Per-object header \\
Java & Class pointer + vtable & $O(1)$ & \texttt{instanceof} is $O(d)$ \\
TypeScript & Structural check & $O(n)$ & Types erased at runtime \\
Rust (static) & \texttt{TypeId} & $O(1)$ & Compile-time resolution \\
Rust (\texttt{dyn}) & Vtable only & $O(k)$ & No type tag without \texttt{Any} \\
\hline
\end{tabular}
\caption{Witness cost for type identity. $n$ = structure size, $d$ = inheritance depth, $k$ = interface count.}
\end{table}

The pattern is consistent: systems with nominal tags achieve $O(1)$ witness cost; systems without them pay $O(n)$ or $O(k)$. This is not coincidence---it is the information barrier theorem instantiated in production runtimes.

