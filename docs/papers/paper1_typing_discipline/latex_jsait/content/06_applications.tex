\subsection{CPython: Nominal-Tag Access}

\begin{corollary}[CPython instantiation]
CPython realizes nominal-tag access: the runtime stores a type tag (\texttt{ob\_type} pointer) per object and exposes it via the \texttt{type()} builtin. Therefore, the constant-witness construction applies: $W(\text{type-identity}) = O(1)$ in CPython.
\end{corollary}

\textbf{Evidence:} The CPython object model stores a pointer to the type object in every heap-allocated value. The \texttt{type()} function is a single pointer dereference, hence $O(1)$ time and $O(1)$ AST size.

\subsection{Java: Nominal-Tag Access}

\begin{corollary}[Java instantiation]
Java realizes nominal-tag access via the \texttt{.getClass()} method, which returns the runtime type object. Like CPython, Java achieves $W(\text{type-identity}) = O(1)$.
\end{corollary}

\subsection{TypeScript: Structural Typing}

\begin{corollary}[TypeScript instantiation]
TypeScript uses structural typing: two types are equivalent iff they have the same structure (fields and method signatures). Type identity checking requires traversing the structure, hence $W(\text{type-identity}) = O(n)$ where $n$ is the structure size.
\end{corollary}

\subsection{Rust: Nominal-Tag Access (Compile-Time)}

\begin{corollary}[Rust instantiation]
Rust uses nominal typing at compile time: type identity is resolved statically via the type system. At runtime, Rust provides \texttt{std::any::type\_id()} for nominal-tag access, achieving $W(\text{type-identity}) = O(1)$.
\end{corollary}

\subsection{Summary: Witness Complexity Across Runtimes}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Language} & \textbf{Typing Discipline} & \textbf{Witness Length} \\
\hline
CPython & Nominal & $O(1)$ \\
Java & Nominal & $O(1)$ \\
TypeScript & Structural & $O(n)$ \\
Rust & Nominal & $O(1)$ \\
\hline
\end{tabular}
\caption{Witness complexity for type identity across programming language runtimes.}
\end{table}

These instantiations confirm the theoretical predictions: nominal-tag access achieves constant witness length, while structural typing requires linear witness length in the structure size.

