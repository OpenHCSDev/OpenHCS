\section{Methodology}\label{case-studies-applying-the-methodology}

\subsection{Empirical Validation
Strategy}\label{empirical-validation-strategy}

\textbf{Addressing the ``n=1'' objection:} A potential criticism is that
our case studies come from a single codebase (OpenHCS~\cite{openhcs2025}). We address this
in three ways:

\textbf{First: Claim structure.} This paper makes two distinct types of
claims with different validation requirements. \emph{Mathematical
claims} (Theorems 3.1--3.62): ``Discarding B necessarily loses these
capabilities.'' These are proven by formal derivation in Lean (2600+
lines, 0 \texttt{sorry}). Mathematical proofs have no sample size: they
are universal by construction. \emph{Existence claims}: ``Production
systems requiring these capabilities exist.'' One example suffices for
an existential claim. OpenHCS demonstrates that real systems require
provenance tracking, MRO-based resolution, and type-identity
dispatch, exactly the capabilities Theorem 3.19 proves impossible under
structural typing.

\textbf{Second: Case studies are theorem instantiations.} Table 5.1
links each case study to the theorem it validates. These are not
arbitrary examples: they are empirical instantiations of theoretical
predictions. The theory predicts that systems requiring provenance will
use nominal typing; the case studies confirm this prediction. The 13
patterns are 13 independent architectural decisions, each of which could
have used structural typing but provably could not. Packaging these
patterns into separate repositories would not add information: it would
be technicality theater. The mathematical impossibility results are the
contribution; OpenHCS is the existence proof that the impossibility
matters.

\textbf{Third: Falsifiable predictions.} The decision procedure (Theorem
3.62) makes falsifiable predictions: systems where \(B \neq \emptyset\)
should exhibit nominal patterns; systems where \(B = \emptyset\) should
exhibit structural patterns. Any codebase where this prediction fails
would falsify our theory.

\textbf{The validation structure:}

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2121}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.5455}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2424}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Level
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
What it provides
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Status
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Formal proofs & Mathematical necessity & Complete (Lean, 2600+ lines, 0
\texttt{sorry}) \\
OpenHCS case studies & Existence proof & 13 patterns documented \\
Decision procedure & Falsifiability & Theorem 3.62 (machine-checked) \\
\end{longtable}

OpenHCS is a bioimage analysis platform for high-content screening
microscopy. The system was designed from the start with explicit
commitment to nominal typing, exposing the consequences of this
architectural decision through 13 distinct patterns. These case studies
demonstrate the methodology in action: for each pattern, we identify
whether it requires provenance tracking, MRO-based resolution, or type
identity as dictionary keys: all indicators that nominal typing is
mandatory per the formal model.

Duck typing fails for all 13 patterns because they fundamentally require
\textbf{type identity} rather than structural compatibility.
Configuration resolution needs to know \emph{which type} provided a
value (provenance tracking, Corollary 6.3). MRO-based priority needs
inheritance relationships preserved (Theorem 3.4). Metaclass
registration needs types as dictionary keys (type identity as hash).
These requirements are not implementation details. They are
architectural necessities proven impossible under duck typing's
structural equivalence axiom.

The 13 studies demonstrate four pattern taxonomies: (1) \textbf{type
discrimination} (WellFilterConfig hierarchy), (2) \textbf{metaclass
registration} (AutoRegisterMeta, GlobalConfigMeta,
DynamicInterfaceMeta), (3) \textbf{MRO-based resolution} (dual-axis
resolver, @global\_pipeline\_config chain), and (4)
\textbf{bidirectional lookup} (lazy \(\leftrightarrow\) base type
registries). Table 5.2 summarizes how each pattern fails under duck
typing and what nominal mechanism enables it.

\subsubsection{Table 5.1: Case Studies as Theorem
Validation}\label{table-5.1-case-studies-as-theorem-validation}

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1346}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1731}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3654}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3269}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Study
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Pattern
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Validates Theorem
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Validation Type
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & Type discrimination & Theorem 3.4 (Nominal Pareto-Dominance) & MRO
position distinguishes structurally identical types \\
2 & Discriminated unions & Theorem 3.5 (Strict Dominance) &
\texttt{\_\_subclasses\_\_()} provides exhaustiveness \\
3 & Converter dispatch & Theorem 4.1 (O(1) Complexity) & \texttt{type()}
as dict key vs O(n) probing \\
4 & Polymorphic config & Corollary 6.3 (Provenance Impossibility) & ABC
contracts track provenance \\
5 & Architecture migration & Theorem 4.1 (O(1) Complexity) &
Definition-time vs runtime failure \\
6 & Auto-registration & Theorem 3.5 (Strict Dominance) &
\texttt{\_\_init\_subclass\_\_} hook \\
7 & Type transformation & Corollary 6.3 (Provenance Impossibility) &
5-stage \texttt{type()} chain tracks lineage \\
8 & Dual-axis resolution & Theorem 3.4 (Nominal Pareto-Dominance) & Scope
\(\times\) MRO product requires MRO \\
9 & Custom isinstance & Theorem 3.5 (Strict Dominance) &
\texttt{\_\_instancecheck\_\_} override \\
10 & Dynamic interfaces & Theorem 3.5 (Strict Dominance) &
Metaclass-generated ABCs \\
11 & Framework detection & Theorem 4.1 (O(1) Complexity) & Sentinel type
vs module probing \\
12 & Method injection & Corollary 6.3 (Provenance Impossibility) &
\texttt{type()} namespace manipulation \\
13 & Bidirectional lookup & Theorem 4.1 (O(1) Complexity) & Single
registry with \texttt{type()} keys \\
\end{longtable}

\subsubsection{Table 5.2: Comprehensive Case Study
Summary}\label{table-5.2-comprehensive-case-study-summary}

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1296}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3519}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3519}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Study
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Pattern
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Duck Failure Mode
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Nominal Mechanism
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & Type discrimination & Structural equivalence & \texttt{isinstance()}
+ MRO position \\
2 & Discriminated unions & No exhaustiveness check &
\texttt{\_\_subclasses\_\_()} enumeration \\
3 & Converter dispatch & O(n) attribute probing & \texttt{type()} as
dict key \\
4 & Polymorphic config & No interface guarantee & ABC contracts \\
5 & Architecture migration & Fail-silent at runtime & Fail-loud at
definition \\
6 & Auto-registration & No type identity &
\texttt{\_\_init\_subclass\_\_} hook \\
7 & Type transformation & Cannot track lineage & 5-stage \texttt{type()}
chain \\
8 & Dual-axis resolution & No scope \(\times\) MRO product & Registry +
MRO traversal \\
9 & Custom isinstance & Impossible & \texttt{\_\_instancecheck\_\_}
override \\
10 & Dynamic interfaces & No interface identity & Metaclass-generated
ABCs \\
11 & Framework detection & Module probing fragile & Sentinel type in
registry \\
12 & Method injection & No target type & \texttt{type()} namespace
manipulation \\
13 & Bidirectional lookup & Two dicts, sync bugs & Single registry,
\texttt{type()} keys \\
\end{longtable}

\subsection{Case Study 1: Structurally Identical, Semantically
Distinct
Types}\label{case-study-1-structurally-identical-semantically-distinct-types}

\textbf{Theorem 5.1 (Structural Identity \(\neq\) Semantic Identity).}
Two types \(A\) and \(B\) with identical structure \(S(A) = S(B)\) may
have distinct semantics determined by their position in an inheritance
hierarchy. Duck typing's axiom of structural equivalence
(\(S(A) = S(B) \Rightarrow A \equiv B\)) destroys this semantic
distinction.

\emph{Proof.} By construction from production code.

\textbf{The Diamond Inheritance Pattern:}

\begin{verbatim}
                    WellFilterConfig
                   (well_filter, well_filter_mode)
                  /                              \
                 /                                \
    PathPlanningConfig                    StepWellFilterConfig
    (output_dir_suffix,                         (pass)
     global_output_folder,               [NO NEW FIELDS - STRUCTURALLY
     sub_dir = "images")                  IDENTICAL TO WellFilterConfig]
                 \                                /
                  \                              /
                   StepMaterializationConfig
                   (sub_dir = "checkpoints", enabled)
\end{verbatim}

\begin{verbatim}
@dataclass(frozen=True)
class WellFilterConfig:
    """Pipeline{-level scope."""}
    well\_filter: Optional[Union[List[str], str, int]] = None
    well\_filter\_mode: WellFilterMode = WellFilterMode.INCLUDE

@dataclass(frozen=True)
class PathPlanningConfig(WellFilterConfig):
    """Pipeline{-level path configuration."""}
    output\_dir\_suffix: str = "\_openhcs"
    sub\_dir: str = "images"  \# Pipeline default

@dataclass(frozen=True)
class StepWellFilterConfig(WellFilterConfig):
    """Step{-level scope marker."""}
    pass  \# ZERO new fields. Structurally identical to WellFilterConfig.

@dataclass(frozen=True)
class StepMaterializationConfig(StepWellFilterConfig, PathPlanningConfig):
    """Step{-level materialization."""}
    sub\_dir: str = "checkpoints"  \# Step default OVERRIDES pipeline default
    enabled: bool = False
\end{verbatim}

\textbf{Critical observation:} \texttt{StepWellFilterConfig} adds
\textbf{zero fields}. It is byte-for-byte structurally identical to
\texttt{WellFilterConfig}. Yet it serves a critical semantic role: it
marks the \textbf{scope boundary} between pipeline-level and step-level
configuration.

\textbf{The MRO encodes scope semantics:}

\begin{verbatim}
StepMaterializationConfig.\_\_mro\_\_ = (
    StepMaterializationConfig,  \# Step scope
    StepWellFilterConfig,       \# Step scope marker (NO FIELDS!)
    PathPlanningConfig,         \# Pipeline scope
    WellFilterConfig,           \# Pipeline scope
    object
)
\end{verbatim}

When resolving \texttt{sub\_dir}: 1.
\texttt{StepMaterializationConfig.sub\_dir\ =\ "checkpoints"} $\rightarrow$
\textbf{step-level value} 2.
\texttt{PathPlanningConfig.sub\_dir\ =\ "images"} $\rightarrow$ pipeline-level value
(shadowed)

The system answers ``which scope provided this value?'' by walking the
MRO. The \emph{position} of \texttt{StepWellFilterConfig} (before
\texttt{PathPlanningConfig}) encodes the scope boundary.

\textbf{What duck typing sees:}

\small
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Object & \texttt{well\_filter} & \texttt{well\_filter\_mode} &
\texttt{sub\_dir} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
WellFilterConfig() & None & INCLUDE & --- \\
StepWellFilterConfig() & None & INCLUDE & --- \\
\end{longtable}

Duck typing's verdict: \textbf{identical}. Same attributes, same values.

\textbf{What the system needs to know:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  ``Is this config pipeline-level or step-level?'' $\rightarrow$ Determines
  resolution priority
\item
  ``Which type in the MRO provided \texttt{sub\_dir}?'' $\rightarrow$ Provenance for
  debugging
\item
  ``Can I use \texttt{isinstance(config,\ StepWellFilterConfig)}?'' $\rightarrow$
  Scope discrimination
\end{enumerate}

Duck typing cannot answer ANY of these questions. The information is
\textbf{not in the structure}: it is in the \textbf{type identity} and
\textbf{MRO position}.

\textbf{Nominal typing answers all three in O(1):}

\begin{verbatim}
isinstance(config, StepWellFilterConfig)  \# Scope check: O(1)
type(config).\_\_mro\_\_                       \# Full provenance chain: O(1)
type(config).\_\_mro\_\_.index(StepWellFilterConfig)  \# MRO position: O(k)
\end{verbatim}

\textbf{Corollary 5.2 (Scope Encoding Requires Nominal Typing).} Any
system that encodes scope semantics in inheritance hierarchies (where
structurally-identical types at different MRO positions have different
meanings) \textbf{requires} nominal typing. Duck typing makes such
architectures impossible (not difficult, \textbf{impossible}).

\emph{Proof.} Duck typing defines equivalence as
\(S(A) = S(B) \Rightarrow A \equiv B\). If \(A\) and \(B\) are
structurally identical but semantically distinct (different scopes),
duck typing \textbf{by definition} cannot distinguish them. This is not
a limitation of duck typing implementations; it is the
\textbf{definition} of duck typing. \(\blacksquare\)

\textbf{This is not an edge case.} The OpenHCS configuration system has
15 \texttt{@global\_pipeline\_config} decorated dataclasses forming
multiple diamond inheritance patterns. The entire architecture depends
on MRO position distinguishing types with identical structure. Under
duck typing, this system \textbf{cannot exist}.

\textbf{Pattern (Table 5.1, Row 1):} Type discrimination via MRO
position. This case study demonstrates: - Theorem 4.1: O(1) type
identity via \texttt{isinstance()} - Theorem 4.3: O(1) vs $\Omega(n)$
complexity gap - The fundamental failure of structural equivalence to
capture semantic distinctions

\paragraph{5.2.1 Sentinel Attribute
Objection}\label{sentinel-attribute-objection}

\textbf{Objection:} ``Just add a sentinel attribute (e.g.,
\texttt{\_scope:\ str\ =\ \textquotesingle{}step\textquotesingle{}}) to
distinguish types structurally.''

\textbf{Theorem 5.2a (Sentinel Attribute Insufficiency).} Let
\(\sigma : T \to V\) be a sentinel attribute (a structural field
intended to distinguish types). Then \(\sigma\) cannot recover any
B-dependent capability.

\emph{Proof.} 1. \textbf{Sentinel is structural.} By definition,
\(\sigma\) is an attribute with a value. Therefore \(\sigma \in S(T)\)
(the structure axis). 2. \textbf{B-dependent capabilities require B.} By
Theorem 3.19, provenance, identity, enumeration, and conflict resolution
all require the Bases axis \(B\). 3. \textbf{S does not contain B.} By
the axis independence property (Definition 2.5), the axes \((B, S)\)
are independent: \(S\) carries no information about \(B\). 4.
\textbf{Therefore \(\sigma\) cannot provide B-dependent capabilities.}
Since \(\sigma \in S\) and B-dependent capabilities require information
not in \(S\), no sentinel attribute can recover them. \(\blacksquare\)

\textbf{Corollary 5.2b (Specific Sentinel Failures).}

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3871}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6129}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Capability
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Why sentinel fails
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Enumeration & Requires iterating over types with \(\sigma = v\). No type
registry exists in structural typing (Theorem 2.10q). Cannot compute
\texttt{{[}T\ for\ T\ in\ ?\ if\ T.\_scope\ ==\ \textquotesingle{}step\textquotesingle{}{]}}. There
is no source for \texttt{?}. \\
Enforcement & \(\sigma\) is a runtime value, not a type constraint.
Subtypes can set \(\sigma\) incorrectly without type error. No
enforcement mechanism exists. \\
Conflict resolution & When multiple mixins define \(\sigma\), which
wins? This requires MRO, which requires \(B\). Sentinel \(\sigma \in S\)
has no MRO. \\
Provenance & ``Which type provided \(\sigma\)?'' requires MRO traversal.
\(\sigma\) cannot answer queries about its own origin. \\
\end{longtable}

\textbf{Corollary 5.2c (Sentinel Simulates, Cannot Recover).} Sentinel
attributes can \emph{simulate} type identity (by convention) but cannot
\emph{recover} the capabilities that identity provides. The simulation
is unenforced (violable without type error), unenumerable (no registry),
and unordered (no MRO for conflicts). This is precisely the capability
gap of Theorem 3.19, repackaged. \(\blacksquare\)

\subsubsection{\texorpdfstring{5.3 Case Study 2: Discriminated Unions
via
\textbf{subclasses}()}{5.3 Case Study 2: Discriminated Unions via subclasses()}}\label{case-study-2-discriminated-unions-via-subclasses}

OpenHCS's parameter UI needs to dispatch widget creation based on
parameter type structure: \texttt{Optional{[}Dataclass{]}} parameters
need checkboxes, direct \texttt{Dataclass} parameters are always
visible, and primitive types use simple widgets. The challenge: how does
the system enumerate all possible parameter types to ensure exhaustive
handling?

\begin{verbatim}
@dataclass
class OptionalDataclassInfo(ParameterInfoBase):
    widget\_creation\_type: str = "OPTIONAL\_NESTED"

    @staticmethod
    def matches(param\_type: Type) {-\textgreater{}} bool:
        return is\_optional(param\_type) and is\_dataclass(inner\_type(param\_type))

@dataclass
class DirectDataclassInfo(ParameterInfoBase):
    widget\_creation\_type: str = "NESTED"

    @staticmethod
    def matches(param\_type: Type) {-\textgreater{}} bool:
        return is\_dataclass(param\_type)

@dataclass
class GenericInfo(ParameterInfoBase):
    @staticmethod
    def matches(param\_type: Type) {-\textgreater{}} bool:
        return True  \# Fallback
\end{verbatim}

The factory uses \texttt{ParameterInfoBase.\_\_subclasses\_\_()} to
enumerate all registered variants at runtime. This provides
exhaustiveness: adding a new parameter type (e.g., \texttt{EnumInfo})
automatically extends the dispatch table without modifying the factory.
Duck typing has no equivalent. There is no way to ask ``what are all the
types that have a \texttt{matches()} method?''

Structural typing would require manually maintaining a registry list.
Nominal typing provides it for free via inheritance tracking. The
dispatch is O(1) after the initial linear scan to find the matching
subclass.

\textbf{Pattern (Table 5.1, Row 2):} Discriminated union enumeration.
Demonstrates how nominal identity enables exhaustiveness checking that
duck typing cannot provide.

\subsection{Case Study 3: MemoryTypeConverter
Dispatch}\label{case-study-3-memorytypeconverter-dispatch}

\begin{verbatim}
\# 6 converter classes auto{-generated at module load}
\_CONVERTERS = \{
    mem\_type: type(
        f"\{mem\_type.value.capitalize()\}Converter",  \# name
        (MemoryTypeConverter,),                      \# bases
        \_TYPE\_OPERATIONS[mem\_type]                   \# namespace
    )()
    for mem\_type in MemoryType
\}

def convert\_memory(data, source\_type: str, target\_type: str, gpu\_id: int):
    source\_enum = MemoryType(source\_type)
    converter = \_CONVERTERS[source\_enum]  \# O(1) lookup by type
    method = getattr(converter, f"to\_\{target\_type\}")
    return method(data, gpu\_id)
\end{verbatim}

This generates \texttt{NumpyConverter}, \texttt{CupyConverter},
\texttt{TorchConverter}, \texttt{TensorflowConverter},
\texttt{JaxConverter}, \texttt{PyclesperantoConverter}, all with
identical method signatures (\texttt{to\_numpy()}, \texttt{to\_cupy()},
etc.) but completely different implementations.

The nominal type identity created by \texttt{type()} allows using
converters as dict keys in \texttt{\_CONVERTERS}. Duck typing would see
all converters as structurally identical (same method names), making
O(1) dispatch impossible. The system would need to probe each converter
with hasattr or maintain a parallel string-based registry.

\textbf{Pattern (Table 5.1, Row 3):} Factory-generated types as
dictionary keys. Demonstrates Theorem 4.1 (O(1) dispatch) and the
necessity of type identity for efficient lookup.

\subsection{Case Study 4: Polymorphic
Configuration}\label{case-study-4-polymorphic-configuration}

The streaming subsystem supports multiple viewers (Napari, Fiji) with
different port configurations and backend protocols. How should the
orchestrator determine which viewer config is present without fragile
attribute checks?

\begin{verbatim}
class StreamingConfig(StreamingDefaults, ABC):
    @property
    @abstractmethod
    def backend(self) {-\textgreater{}} Backend: pass

\# Factory{-generated concrete types}
NapariStreamingConfig = create\_streaming\_config(
    viewer\_name=\textquotesingle{napari\textquotesingle{}}, port=5555, backend=Backend.NAPARI\_STREAM)
FijiStreamingConfig = create\_streaming\_config(
    viewer\_name=\textquotesingle{fiji\textquotesingle{}}, port=5565, backend=Backend.FIJI\_STREAM)

\# Orchestrator dispatch
if isinstance(config, StreamingConfig):
    registry.get\_or\_create\_tracker(config.port, config.viewer\_type)
\end{verbatim}

The codebase documentation explicitly contrasts approaches:

\begin{quote}
\textbf{Old:}
\texttt{hasattr(config,\ \textquotesingle{}napari\_port\textquotesingle{})}
--- fragile (breaks if renamed), no type checking \textbf{New:}
\texttt{isinstance(config,\ NapariStreamingConfig)} --- type-safe,
explicit
\end{quote}

Duck typing couples the check to attribute names (strings), creating
maintenance fragility. Renaming a field breaks all \texttt{hasattr()}
call sites. Nominal typing couples the check to type identity, which is
refactoring-safe.

\textbf{Pattern (Table 5.1, Row 4):} Polymorphic dispatch with interface
guarantees. Demonstrates how nominal ABC contracts provide fail-loud
validation that duck typing's fail-silent probing cannot match.

\subsection{Case Study 5: Migration from Duck to Nominal Typing
(PR
\#44)}\label{case-study-5-migration-from-duck-to-nominal-typing-pr-44}

PR \#44~\cite{openhcsPR44} (``UI Anti-Duck-Typing Refactor'') migrated OpenHCS's UI layer from duck typing to
nominal ABC contracts. The architectural changes:

\textbf{Before (duck typing):} - ParameterFormManager: 47
\texttt{hasattr()} dispatch points scattered across methods -
CrossWindowPreviewMixin: attribute-based widget probing throughout -
Dispatch tables: string attribute names mapped to handlers

\textbf{After (nominal typing):} - ParameterFormManager: single
\texttt{AbstractFormWidget} ABC with explicit contracts -
CrossWindowPreviewMixin: explicit widget protocols - Dispatch tables:
eliminated --- replaced by \texttt{isinstance()} + method calls

\textbf{Architectural transformation:}

\begin{verbatim}
\# BEFORE: Duck typing dispatch (scattered across 47 call sites)
if hasattr(widget, \textquotesingle{isChecked\textquotesingle{}}):
    return widget.isChecked()
elif hasattr(widget, \textquotesingle{currentText\textquotesingle{}}):
    return widget.currentText()
\# ... 45 more cases

\# AFTER: Nominal ABC (single definition point)
class AbstractFormWidget(ABC):
    @abstractmethod
    def get\_value(self) {-\textgreater{}} Any: pass

\# Error detection: attribute typos caught at import time, not user interaction time
\end{verbatim}

The migration eliminated fail-silent bugs where missing attributes
returned \texttt{None} instead of raising exceptions. Type errors now
surface at class definition time (when ABC contract is violated) rather
than at user interaction time (when attribute access fails silently).

\textbf{Pattern (Table 5.1, Row 5):} Architecture migration from
fail-silent duck typing to fail-loud nominal contracts. Demonstrates
the complexity reduction predicted by Theorem 4.3: scattered
\texttt{hasattr()} checks (n=47) were replaced with O(1) centralized ABC
validation.

\subsection{Case Study 6:
AutoRegisterMeta}\label{case-study-6-autoregistermeta}

\textbf{Pattern:} Metaclass-based auto-registration uses type identity
as the registry key. At class definition time, the metaclass registers
each concrete class (skipping ABCs) in a type-keyed dictionary.

\begin{verbatim}
class AutoRegisterMeta(ABCMeta):
    def \_\_new\_\_(mcs, name, bases, attrs, registry\_config=None):
        new\_class = super().\_\_new\_\_(mcs, name, bases, attrs)

        \# Skip abstract classes (nominal check via \_\_abstractmethods\_\_)
        if getattr(new\_class, \textquotesingle{\_\_abstractmethods\_\_\textquotesingle{}}, None):
            return new\_class

        \# Register using type as value
        key = mcs.\_get\_registration\_key(name, new\_class, registry\_config)
        registry\_config.registry\_dict[key] = new\_class
        return new\_class

\# Usage: Define class $\backslash{rightarrow$ auto{-}registered}
class ImageXpressHandler(MicroscopeHandler, metaclass=MicroscopeHandlerMeta):
    \_microscope\_type = \textquotesingle{imagexpress\textquotesingle{}}
\end{verbatim}

This pattern is impossible with duck typing because: (1) type identity
is required as dict values. Duck typing has no way to reference ``the
type itself'' distinct from instances, (2) skipping abstract classes
requires checking \texttt{\_\_abstractmethods\_\_}, a class-level
attribute inaccessible to duck typing's instance-level probing, and (3)
inheritance-based key derivation (extracting ``imagexpress'' from
``ImageXpressHandler'') requires class name access.

The metaclass ensures exactly one handler per microscope type.
Attempting to define a second \texttt{ImageXpressHandler} raises an
exception at import time. Duck typing's runtime checks cannot provide
this guarantee. Duplicates would silently overwrite.

\textbf{Pattern (Table 5.1, Row 6):} Auto-registration with type
identity. Demonstrates that metaclasses fundamentally depend on nominal
typing to distinguish classes from instances.

\subsection{Case Study 7: Five-Stage Type
Transformation}\label{case-study-7-five-stage-type-transformation}

The decorator chain demonstrates nominal typing's power for systematic
type manipulation. Starting from \texttt{@auto\_create\_decorator}, one
decorator invocation spawns a cascade that generates lazy companion
types, injects fields into parent configs, and maintains bidirectional
registries.

\textbf{Stage 1: \texttt{@auto\_create\_decorator} on
\texttt{GlobalPipelineConfig}}

\begin{verbatim}
@auto\_create\_decorator
@dataclass(frozen=True)
class GlobalPipelineConfig:
    num\_workers: int = 1
\end{verbatim}

The decorator: 1. Validates naming convention (must start with
``Global'') 2. Marks class:
\texttt{global\_config\_class.\_is\_global\_config\ =\ True} 3. Calls
\texttt{create\_global\_default\_decorator(GlobalPipelineConfig)} $\rightarrow$
returns \texttt{global\_pipeline\_config} 4. Exports to module:
\texttt{setattr(module,\ \textquotesingle{}global\_pipeline\_config\textquotesingle{},\ decorator)}

\textbf{Stage 2: \texttt{@global\_pipeline\_config} applied to nested
configs}

\begin{verbatim}
@global\_pipeline\_config(inherit\_as\_none=True)
@dataclass(frozen=True)
class PathPlanningConfig(WellFilterConfig):
    output\_dir\_suffix: str = ""
\end{verbatim}

The generated decorator: 1. If \texttt{inherit\_as\_none=True}: rebuilds
class with \texttt{None} defaults for inherited fields via
\texttt{rebuild\_with\_none\_defaults()} 2. Generates lazy class:
\texttt{LazyDataclassFactory.make\_lazy\_simple(PathPlanningConfig,\ "LazyPathPlanningConfig")}
3. Exports lazy class to module:
\texttt{setattr(config\_module,\ "LazyPathPlanningConfig",\ lazy\_class)}
4. Registers for pending field injection into
\texttt{GlobalPipelineConfig} 5. Binds lazy resolution to concrete class
via \texttt{bind\_lazy\_resolution\_to\_class()}

\textbf{Stage 3: Lazy class generation via \texttt{make\_lazy\_simple}}

Inside \texttt{LazyDataclassFactory.make\_lazy\_simple()}: 1.
Introspects base class fields via
\texttt{\_introspect\_dataclass\_fields()} 2. Creates new class:
\texttt{make\_dataclass("LazyPathPlanningConfig",\ fields,\ bases=(PathPlanningConfig,\ LazyDataclass))}
3. Registers bidirectional type mapping:
\texttt{register\_lazy\_type\_mapping(lazy\_class,\ base\_class)}

\textbf{Stage 4: Field injection via
\texttt{\_inject\_all\_pending\_fields}}

At module load completion: 1. Collects all pending configs registered by
\texttt{@global\_pipeline\_config} 2. Rebuilds
\texttt{GlobalPipelineConfig} with new fields:
\texttt{path\_planning:\ LazyPathPlanningConfig\ =\ field(default\_factory=LazyPathPlanningConfig)}
3. Preserves \texttt{\_is\_global\_config\ =\ True} marker on rebuilt
class

\textbf{Stage 5: Resolution via MRO + context stack}

At runtime, dual-axis resolution walks
\texttt{type(config).\_\_mro\_\_}, normalizing each type via registry
lookup. The \texttt{sourceType} in \texttt{(value,\ scope,\ sourceType)}
carries provenance that duck typing cannot provide.

\textbf{Nominal typing requirements throughout:} - Stage 1:
\texttt{\_is\_global\_config} marker enables
\texttt{isinstance(obj,\ GlobalConfigBase)} via metaclass - Stage 2:
\texttt{inherit\_as\_none} marker controls lazy factory behavior - Stage
3: \texttt{type()} identity in bidirectional registries - Stage 4:
\texttt{type()} identity for field injection targeting - Stage 5: MRO
traversal requires \texttt{B} axis

This 5-stage chain is single-stage generation (not nested
metaprogramming). It respects Veldhuizen's (2006) bounds: full power
without complexity explosion. The lineage tracking (which lazy type came
from which base) is only possible with nominal identity. Structurally
equivalent types would be indistinguishable.

\textbf{Pattern (Table 5.1, Row 7):} Type transformation with lineage
tracking. Demonstrates the limits of what duck typing can express:
runtime type generation requires \texttt{type()}, which returns nominal
identities.

\subsection{Case Study 8: Dual-Axis Resolution
Algorithm}\label{case-study-8-dual-axis-resolution-algorithm}

\begin{verbatim}
def resolve\_field\_inheritance(obj, field\_name, scope\_stack):
    mro = [normalize\_type(T) for T in type(obj).\_\_mro\_\_]

    for scope in scope\_stack:  \# X{-axis: context hierarchy}
        for mro\_type in mro:    \# Y{-axis: class hierarchy}
            config = get\_config\_at\_scope(scope, mro\_type)
            if config and hasattr(config, field\_name):
                value = getattr(config, field\_name)
                if value is not None:
                    return (value, scope, mro\_type)  \# Provenance tuple
    return (None, None, None)
\end{verbatim}

The algorithm walks two hierarchies simultaneously: scope\_stack (global
\(\rightarrow\) plate \(\rightarrow\) step) and MRO (child class
\(\rightarrow\) parent class). For each (scope, type) pair, it checks if
a config of that type exists at that scope with a non-None value for the
requested field.

The \texttt{mro\_type} in the return tuple is the provenance: it records
\emph{which type} provided the value. This is only meaningful under
nominal typing where \texttt{PathPlanningConfig} and
\texttt{LazyPathPlanningConfig} are distinct despite identical
structure. Duck typing sees both as having the same attributes, making
\texttt{mro\_type} meaningless.

MRO position encodes priority: types earlier in the MRO override later
types. The dual-axis product (scope \(\times\) MRO) creates
O(\textbar scopes\textbar{} \(\times\) \textbar MRO\textbar) checks in
worst case, but terminates early on first match. Duck typing would
require O(n) sequential attribute probing with no principled ordering.

\textbf{Pattern (Table 5.1, Row 8):} Dual-axis resolution with scope
\(\times\) MRO product. Demonstrates that provenance tracking
fundamentally requires nominal identity (Corollary 6.3).

\subsection{Case Study 9: Custom isinstance()
Implementation}\label{case-study-9-custom-isinstance-implementation}

\begin{verbatim}
class GlobalConfigMeta(type):
    def \_\_instancecheck\_\_(cls, instance):
        \# Virtual base class check
        if hasattr(instance.\_\_class\_\_, \textquotesingle{\_is\_global\_config\textquotesingle{}}):
            return instance.\_\_class\_\_.\_is\_global\_config
        return super().\_\_instancecheck\_\_(instance)

\# Usage: isinstance(config, GlobalConfigBase) returns True
\# even if config doesn\textquotesingle{t inherit from GlobalConfigBase}
\end{verbatim}

This metaclass enables ``virtual inheritance''. Classes can satisfy
\texttt{isinstance(obj,\ Base)} without explicitly inheriting from
\texttt{Base}. The check relies on the \texttt{\_is\_global\_config}
class attribute (set by \texttt{@auto\_create\_decorator}), creating a
nominal marker that duck typing cannot replicate.

Duck typing could check
\texttt{hasattr(instance,\ \textquotesingle{}\_is\_global\_config\textquotesingle{})},
but this is instance-level. The metaclass pattern requires class-level
checks (\texttt{instance.\_\_class\_\_.\_is\_global\_config}),
distinguishing the class from its instances. This is fundamentally
nominal: the check is ``does this type have this marker?'' not ``does
this instance have this attribute?''

The virtual inheritance enables interface segregation:
\texttt{GlobalPipelineConfig} advertises conformance to
\texttt{GlobalConfigBase} without inheriting implementation. This is
impossible with duck typing's attribute probing. There's no way to
express ``this class satisfies this interface'' as a runtime-checkable
property.

\textbf{Pattern (Table 5.1, Row 9):} Custom isinstance via class-level
markers. Demonstrates that Python's metaobject protocol is fundamentally
nominal.

\subsection{Case Study 10: Dynamic Interface
Generation}\label{case-study-10-dynamic-interface-generation}

\textbf{Pattern:} Metaclass-generated abstract base classes create
interfaces at runtime based on configuration. The generated ABCs have no
methods or attributes (they exist purely for nominal identity).

\begin{verbatim}
class DynamicInterfaceMeta(ABCMeta):
    \_generated\_interfaces: Dict[str, Type] = \{\}

    @classmethod
    def get\_or\_create\_interface(mcs, interface\_name: str) {-\textgreater{}} Type:
        if interface\_name not in mcs.\_generated\_interfaces:
            \# Generate pure nominal type
            interface = type(interface\_name, (ABC,), \{\)}
            mcs.\_generated\_interfaces[interface\_name] = interface
        return mcs.\_generated\_interfaces[interface\_name]

\# Runtime usage
IStreamingConfig = DynamicInterfaceMeta.get\_or\_create\_interface("IStreamingConfig")
class NapariConfig(StreamingConfig, IStreamingConfig): pass

\# Later: isinstance(config, IStreamingConfig) $\backslash{rightarrow$ True}
\end{verbatim}

The generated interfaces have empty namespaces: no methods, no
attributes. Their sole purpose is nominal identity: marking that a class
explicitly claims to implement an interface. This is pure nominal
typing: structural typing would see these interfaces as equivalent to
\texttt{object} (since they have no distinguishing structure), but
nominal typing distinguishes \texttt{IStreamingConfig} from
\texttt{IVideoConfig} even though both are structurally empty.

Duck typing has no equivalent concept. There's no way to express ``this
class explicitly implements this contract'' without actual attributes to
probe. The nominal marker enables explicit interface declarations in a
dynamically-typed language.

\textbf{Pattern (Table 5.1, Row 10):} Runtime-generated interfaces with
empty structure. Demonstrates that nominal identity can exist
independent of structural content.

\subsection{Case Study 11: Framework Detection via Sentinel
Type}\label{case-study-11-framework-detection-via-sentinel-type}

\begin{verbatim}
\# Framework config uses sentinel type as registry key
\_FRAMEWORK\_CONFIG = type("\_FrameworkConfigSentinel", (), \{\)()}

\# Detection: check if sentinel is registered
def has\_framework\_config():
    return \_FRAMEWORK\_CONFIG in GlobalRegistry.configs

\# Alternative approaches fail:
\# hasattr(module, \textquotesingle{\_FRAMEWORK\_CONFIG\textquotesingle{}) $\backslash{}rightarrow$ fragile, module probing}
\# \textquotesingle{framework\textquotesingle{} in config\_names $\backslash{}rightarrow$ string{-}based, no type safety}
\end{verbatim}

The sentinel is a runtime-generated type with empty namespace,
instantiated once, and used as a dictionary key. Its nominal identity
(memory address) guarantees uniqueness. Even if another module creates
\texttt{type("\_FrameworkConfigSentinel",\ (),\ \{\})()}, the two
sentinels are distinct objects with distinct identities.

Duck typing cannot replicate this pattern. Attribute-based detection
(\texttt{hasattr(module,\ attr\_name)}) couples the check to module
structure. String-based keys (`framework') lack type safety. The nominal
sentinel provides a refactoring-safe, type-safe marker that exists
independent of names or attributes.

This pattern appears in framework detection, feature flags, and
capability markers. Contexts where the existence of a capability needs
to be checked without coupling to implementation details.

\textbf{Pattern (Table 5.1, Row 11):} Sentinel types for framework
detection. Demonstrates nominal identity as a capability marker
independent of structure.

\subsection{Case Study 12: Dynamic Method
Injection}\label{case-study-12-dynamic-method-injection}

\begin{verbatim}
def inject\_conversion\_methods(target\_type: Type, methods: Dict[str, Callable]):
    """Inject methods into a type\textquotesingle{s namespace at runtime."""}
    for method\_name, method\_impl in methods.items():
        setattr(target\_type, method\_name, method\_impl)

\# Usage: Inject GPU conversion methods into MemoryType converters
inject\_conversion\_methods(NumpyConverter, \{
    \textquotesingle{to\_cupy\textquotesingle{}}: lambda self, data, gpu: cupy.asarray(data, gpu),
    \textquotesingle{to\_torch\textquotesingle{}}: lambda self, data, gpu: torch.tensor(data, device=gpu),
\)}
\end{verbatim}

Method injection requires a target type: the type whose namespace will
be modified. Duck typing has no concept of ``the type itself'' as a
mutable namespace. It can only access instances. To inject methods
duck-style would require modifying every instance's
\texttt{\_\_dict\_\_}, which doesn't affect future instances.

The nominal type serves as a shared namespace. Injecting
\texttt{to\_cupy} into \texttt{NumpyConverter} affects all instances
(current and future) because method lookup walks
\texttt{type(obj).\_\_dict\_\_} before \texttt{obj.\_\_dict\_\_}. This
is fundamentally nominal: the type is a first-class object with its own
namespace, distinct from instance namespaces.

This pattern enables plugins, mixins, and monkey-patching. All
requiring types as mutable namespaces. Duck typing's instance-level view
cannot express ``modify the behavior of all objects of this kind.''

\textbf{Pattern (Table 5.1, Row 12):} Dynamic method injection into type
namespaces. Demonstrates that Python's type system treats types as
first-class objects with nominal identity.

\subsection{Case Study 13: Bidirectional Type
Lookup}\label{case-study-13-bidirectional-type-lookup}

OpenHCS maintains bidirectional registries linking lazy types to base
types: \texttt{\_lazy\_to\_base{[}LazyX{]}\ =\ X} and
\texttt{\_base\_to\_lazy{[}X{]}\ =\ LazyX}. How should the system
prevent desynchronization bugs where the two dicts fall out of sync?

\begin{verbatim}
class BidirectionalTypeRegistry:
    def \_\_init\_\_(self):
        self.\_forward: Dict[Type, Type] = \{\  }\# lazy $\backslash{rightarrow$ base}
        self.\_reverse: Dict[Type, Type] = \{\  }\# base $\backslash{rightarrow$ lazy}

    def register(self, lazy\_type: Type, base\_type: Type):
        \# Single source of truth: type identity enforces bijection
        if lazy\_type in self.\_forward:
            raise ValueError(f"\{lazy\_type\} already registered")
        if base\_type in self.\_reverse:
            raise ValueError(f"\{base\_type\} already has lazy companion")

        self.\_forward[lazy\_type] = base\_type
        self.\_reverse[base\_type] = lazy\_type

\# Type identity as key ensures sync
registry.register(LazyPathPlanningConfig, PathPlanningConfig)
\# Later: registry.normalize(LazyPathPlanningConfig) $\backslash{rightarrow$ PathPlanningConfig}
\#        registry.get\_lazy(PathPlanningConfig) $\backslash{rightarrow$ LazyPathPlanningConfig}
\end{verbatim}

Duck typing would require maintaining two separate dicts with string
keys (class names), introducing synchronization bugs. Renaming
\texttt{PathPlanningConfig} would break the string-based lookup. The
nominal type identity serves as a refactoring-safe key that guarantees
both dicts stay synchronized (a type can only be registered once,
enforcing bijection.

The registry operations are O(1) lookups by type identity. Duck typing's
string-based approach would require O(n) string matching or maintaining
parallel indices, both error-prone and slower.

\textbf{Pattern (Table 5.1, Row 13):} Bidirectional type registries with
synchronization guarantees. Demonstrates that nominal identity as dict
key prevents desynchronization bugs inherent to string-based approaches.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}
