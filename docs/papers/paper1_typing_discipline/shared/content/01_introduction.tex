\section{Introduction}\label{introduction}

This paper proves that nominal typing strictly dominates structural and
duck typing for object-oriented systems with inheritance hierarchies.
All results are machine-checked in Lean 4 (2400+ lines, 111 theorems,
0 \texttt{sorry} placeholders).

We develop a metatheory of class system design applicable to any
language with explicit inheritance. The core insight: every class system
is characterized by which axes of the three-axis model (N, B, S) it
employs. These axes form a lattice under subset ordering, inducing a
strict partial order over typing disciplines. Disciplines using more
axes strictly dominate those using fewer---a universal principle with
implications for typing, architecture, and language design.

The three-axis model formalizes what programmers intuitively understand
but rarely make explicit:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Universal dominance} (Theorem 3.4): Languages with explicit
  inheritance (\texttt{bases} axis) mandate nominal typing. Structural
  typing is valid only when \texttt{bases\ =\ {[}{]}} universally. The
  ``retrofit exception'' is eliminated by adapters (Theorem 2.10j).
\item
  \textbf{Complexity separation} (Theorem 4.3): Nominal typing achieves
  O(1) error localization; duck typing requires \(\Omega\)(n) call-site
  inspection.
\item
  \textbf{Provenance impossibility} (Corollary 6.3): Duck typing cannot
  answer ``which type provided this value?'' because structurally
  equivalent objects are indistinguishable by definition.
  Machine-checked in Lean 4.
\end{enumerate}

These theorems yield four measurable code quality metrics:

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2162}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4865}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2973}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Metric
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
What it measures
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Indicates
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Duck typing density & \texttt{hasattr()} + \texttt{getattr()} +
\texttt{try/except\ AttributeError} per KLOC & Discipline violations
(duck typing is incoherent per Theorem 2.10d) \\
Nominal typing ratio & \texttt{isinstance()} + ABC registrations per
KLOC & Explicit type contracts \\
Provenance capability & Presence of ``which type provided this'' queries
& System requires nominal typing \\
Resolution determinism & MRO-based dispatch vs runtime probing & O(1) vs
\(\Omega\)(n) error localization \\
\end{longtable}

The methodology is validated through 13 case studies from OpenHCS, a
production bioimage analysis platform. The system's architecture exposed
the formal necessity of nominal typing through patterns ranging from
metaclass auto-registration to bidirectional type registries. A
migration from duck typing to nominal contracts (PR \#44) eliminated 47
scattered \texttt{hasattr()} checks and consolidated dispatch logic into
explicit ABC contracts.

\subsection{Contributions}\label{contributions}

This paper makes five contributions:

\textbf{1. Universal Theorems (Section 3.8):} - \textbf{Theorem 3.13
(Provenance Impossibility):} No shape discipline can compute
provenance---information-theoretically impossible. - \textbf{Theorem
3.19 (Derived Characterization):} Capability gap = B-dependent
queries---derived from query space partition, not enumerated. -
\textbf{Theorem 3.24 (Complexity Lower Bound):} Duck typing requires
$\\Omega$(n) inspections---proved by adversary argument. - These theorems
make claims about the universe of possible systems through
information-theoretic analysis, mathematical partition, and adversary arguments.

\textbf{2. Bulletproof Theorems (Section 3.11):} - \textbf{Theorem 3.32
(Model Completeness):} \((N, B, S)\) captures ALL runtime-available type
information. - \textbf{Theorem 3.34-3.35 (No Tradeoff):}
\(\mathcal{C}_{\text{duck}} \subsetneq \mathcal{C}_{\text{nom}}\)---nominal
loses nothing, gains four capabilities. - \textbf{Lemma 3.37 (Axiom
Justification):} Shape axiom is definitional, not assumptive. -
\textbf{Theorem 3.39 (Extension Impossibility):} No computable extension
to duck typing recovers provenance. - \textbf{Theorems 3.43-3.47
(Generics):} Type parameters refine \(N\), not a fourth axis. All
theorems extend to generic types. Erasure is irrelevant (type checking
at compile time). - \textbf{Non-Claims 3.41-3.42, Claim 3.48 (Scope):}
Explicit limits and claims.

\textbf{3. Metatheoretic foundations (Sections 2-3):} - The three-axis
model (N, B, S) as a universal framework for class systems - Theorem
2.15 (Axis Lattice Dominance): capability monotonicity under axis subset
ordering - Theorem 2.17 (Capability Completeness): the capability set
\(\mathcal{C}_B\) is exactly four elements---minimal and complete -
Theorem 3.5: Nominal typing strictly dominates shape-based typing
universally (when \(B \neq \emptyset\))

\textbf{4. Machine-checked verification (Section 6):} - 2400+ lines of
Lean 4 proofs across four modules - 111 theorems/lemmas covering typing,
architecture, information theory, complexity bounds, impossibility,
lower bounds, bulletproofing, generics, exotic features, universal
scope, discipline vs migration separation, context formalization,
capability exhaustiveness, and adapter amortization - Formalized O(1) vs
O(k) vs $\\Omega$(n) complexity separation with adversary-based lower bound
proof - Universal extension to 8 languages (Java, C\#, Rust, TypeScript,
Kotlin, Swift, Scala, C++) - Exotic type features covered (intersection,
union, row polymorphism, HKT, multiple dispatch) - \textbf{Zero
\texttt{sorry} placeholders---all 111 theorems/lemmas complete}

\textbf{5. Empirical validation (Section 5):} - 13 case studies from
OpenHCS (45K LoC production Python codebase) - Demonstrates theoretical
predictions align with real-world architectural decisions - Four
derivable code quality metrics (DTD, NTR, PC, RD)

\subsubsection{Empirical Context:
OpenHCS}\label{empirical-context-openhcs}

\textbf{What it does:} OpenHCS is a bioimage analysis platform.
Pipelines are compiled before execution---errors surface at definition
time, not after processing starts. The GUI and Python code are
interconvertible: design in GUI, export to code, edit, re-import.
Changes to parent config propagate automatically to all child windows.

\textbf{Why it matters for this paper:} The system requires knowing
\emph{which type} provided a value, not just \emph{what} the value is.
Dual-axis resolution walks both the context hierarchy (global
\(\rightarrow\) plate \(\rightarrow\) step) and the class hierarchy
(MRO) simultaneously. Every resolved value carries provenance: (value,
source\_scope, source\_type). This is only possible with nominal
typing---duck typing cannot answer ``which type provided this?''

\textbf{Key architectural patterns (detailed in Section 5):} -
\texttt{@auto\_create\_decorator} $\\rightarrow$ \texttt{@global\_pipeline\_config}
cascade: one decorator spawns a 5-stage type transformation (Case Study
7) - Dual-axis resolver: MRO \emph{is} the priority system---no custom
priority function exists (Case Study 8) - Bidirectional type registries:
single source of truth with \texttt{type()} identity as key (Case Study
13)

\subsubsection{Decision Procedure, Not
Preference}\label{decision-procedure-not-preference}

The contribution of this paper is not the theorems alone, but their
consequence: typing discipline selection becomes a decision procedure.
Given requirements, the discipline is derived.

\textbf{Implications:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Pedagogy.} Architecture courses should not teach ``pick the
  style that feels Pythonic.'' They should teach how to derive the
  correct discipline from requirements. This is engineering, not taste.
\item
  \textbf{AI code generation.} LLMs can apply the decision procedure.
  ``Given requirements R, apply Algorithm 1, emit code with the derived
  discipline'' is an objective correctness criterion. The model either
  applies the procedure correctly or it does not.
\item
  \textbf{Language design.} Future languages could enforce discipline
  based on declared requirements. A \texttt{@requires\_provenance}
  annotation could mandate nominal patterns at compile time.
\item
  \textbf{Formal constraints.} When requirements include provenance,
  the mathematics constrains the choice: shape-based typing cannot
  provide this capability (Theorem 3.13, information-theoretic
  impossibility). The procedure derives the discipline from requirements.
\end{enumerate}

\subsubsection{Scope and Limitations}\label{scope-limitations}

This paper makes absolute claims. We do not argue nominal typing is
``preferred'' or ``more elegant.'' We prove:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Shape-based typing cannot provide provenance.} Duck typing and
  structural typing check type \emph{shape}---attributes, method
  signatures. Provenance requires type \emph{identity}. Shape-based
  disciplines cannot provide what they do not track.
\item
  \textbf{When B $\\neq$ $\\emptyset$, shape-based typing is wrong.} Nominal typing
  strictly dominates. Adapters eliminate the retrofit exception (Theorem
  2.10j). There is no context where shape-based typing is the correct
  choice when inheritance exists.
\item
  \textbf{Shape-based typing is a capability sacrifice.} Protocol and
  duck typing discard the Bases axis. This is not a ``concession'' or
  ``tradeoff''---it is a dominated choice that forecloses four
  capabilities for zero benefit.
\end{enumerate}

We do not claim all systems require provenance. We prove that systems
requiring provenance cannot use shape-based typing. The requirements are
the architect's choice; the discipline, given requirements, is derived.

\subsection{Roadmap}\label{roadmap}

\textbf{Section 2: Metatheoretic foundations} --- The three-axis model,
abstract class system formalization, and the Axis Lattice Metatheorem
(Theorem 2.15)

\textbf{Section 3: Universal dominance} --- Strict dominance (Theorem
3.5), information-theoretic completeness (Theorem 3.19), retrofit
exception eliminated (Theorem 2.10j)

\textbf{Section 4: Decision procedure} --- Deriving typing discipline
from system properties

\textbf{Section 5: Empirical validation} --- 13 OpenHCS case studies
validating theoretical predictions

\textbf{Section 6: Machine-checked proofs} --- Lean 4 formalization
(2400+ lines)

\textbf{Section 7: Related work} --- Positioning within PL theory
literature

\textbf{Section 8: Extensions} --- Mixins vs composition (Theorem 8.1),
TypeScript coherence analysis (Theorem 8.7), gradual typing connection,
Zen alignment

\textbf{Section 9: Conclusion} --- Implications for PL theory and
practice

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

