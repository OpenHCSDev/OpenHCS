\appendix

\section{Completeness and Robustness Analysis}\label{appendix:robustness}

This appendix provides detailed analysis addressing potential concerns
about the scope, applicability, and completeness of our results.

\subsection{Comprehensive Concern Analysis}\label{appendix:concerns}

We identify the major categories of potential concerns and demonstrate
why each does not affect our conclusions.

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5143}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4857}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Potential Concern
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Formal Analysis
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
``Model is incomplete'' & Theorem 3.32 (Model Completeness) \\
``Duck typing has tradeoffs'' & Theorems 3.34-3.36 (Capability Comparison) \\
``Axioms are assumptive'' & Lemma 3.37 (Axiom is Definitional) \\
``Clever extension could fix it'' & Theorem 3.39 (Extension Impossibility) \\
``What about generics?'' & Theorems 3.43-3.48, Table 2.2 (Parameterized N) \\
``Erasure changes things'' & Theorems 3.46-3.47 (Compile-Time Type Checking) \\
``Only works for some languages'' & Theorem 3.47 (8 languages), Remark 3.49 (exotic features) \\
``What about intersection/union types?'' & Remark 3.49 (still three axes) \\
``What about row polymorphism?'' & Remark 3.49 (pure S, loses capabilities) \\
``What about higher-kinded types?'' & Remark 3.49 (parameterized N) \\
``Only applies to greenfield'' & Theorem 2.10j (Adapters eliminate retrofit exception) \\
``Legacy codebases are different'' & Corollary 3.51 (sacrifice, not alternative) \\
``Claims are too broad'' & Non-Claims 3.41-3.42 (true scope limits) \\
``Dominance $\neq$ migration'' & Theorem 3.55 (Dominance $\neq$ Migration) \\
``Greenfield is undefined'' & Definitions 3.57-3.58, Theorem 3.59 \\
``Provenance requirement is circular'' & Theorem 3.61 (Provenance Detection) \\
\end{longtable}
\normalsize

\subsection{Detailed Analysis of Each Concern}\label{appendix:detailed-concerns}

For each identified concern, we provide the formal analysis demonstrating
why it does not affect our conclusions.

\paragraph{Concern 1: Model Completeness.}
\emph{Potential concern:} The (N, B, S) model may fail to capture relevant
aspects of type systems.

\emph{Analysis:} Theorem 3.32 establishes model completeness by demonstrating
that any type system feature expressible in a Turing-complete language
maps to operations on (N, B, S). At runtime, a class system can observe exactly three
things about a type $T$: the identifier (N), the declared parent types (B), and
the declared attributes (S). Any other observation is either derivable from
$(N, B, S)$ or not available at runtime.

\paragraph{Concern 2: Duck Typing Tradeoffs.}
\emph{Potential concern:} Duck typing has flexibility that nominal typing lacks.

\emph{Analysis:} Theorems 3.34-3.36 establish that nominal typing provides a
strict superset of duck typing capabilities. Duck typing's ``acceptance'' of
structurally-equivalent types is not a capability---it is the \emph{absence}
of the capability to distinguish them.

\paragraph{Concern 3: Axiom Circularity.}
\emph{Potential concern:} The axioms are chosen to guarantee the conclusion.

\emph{Analysis:} Lemma 3.37 establishes that the axiom ``shape-based typing treats
same-namespace types identically'' is not an assumption---it is the
\emph{definition} of shape-based typing (Definition 2.10).

\paragraph{Concern 4: Future Extensions.}
\emph{Potential concern:} A clever extension to duck typing could recover provenance.

\emph{Analysis:} Theorem 3.39 proves that any computable extension over $\{N, S\}$
alone cannot recover provenance. The limitation is structural, not technical.

\paragraph{Concern 5: Generics and Parametric Polymorphism.}
\emph{Potential concern:} The model doesn't handle generics.

\emph{Analysis:} Theorems 3.43-3.48 establish that generics preserve the axis
structure. Type parameters are a refinement of N, not additional information
orthogonal to $(N, B, S)$.

\paragraph{Concern 6: Single Codebase Evidence.}
\emph{Potential concern:} Evidence is from one codebase (OpenHCS).

\emph{Analysis:} Theorem 3.43g establishes methodological independence. The
dominance theorems are derived from the structure of $(N, B, S)$, not from
any implementation. OpenHCS is an existence proof, not a premise.

\paragraph{Concern 7: Scope Confusion.}
\emph{Potential concern:} Discipline dominance implies migration recommendation.

\emph{Analysis:} Theorem 3.55 formally proves that Pareto dominance of discipline
A over B does NOT imply that migrating from B to A is beneficial for all
codebases. Dominance is codebase-independent; migration cost is codebase-dependent.

\subsection{Formal Verification Status}\label{appendix:verification}

All core theorems are machine-checked in Lean 4:

\begin{itemize}
\tightlist
\item 2400+ lines of Lean code
\item 111 theorems verified
\item 0 \texttt{sorry} placeholders
\item 0 axioms beyond standard Lean foundations
\end{itemize}

The Lean formalization is publicly available for verification.

\section{Historical and Methodological Context}\label{appendix:historical}

\subsection{On the Treatment of Defaults}\label{appendix:defaults}

Duck typing was accepted as ``Pythonic'' without formal justification.
The theorems in this paper exist because institutional inertia demands
formal refutation of practices that were never formally justified. This
asymmetry---defaults require no justification, changing defaults requires
proof---is a methodological observation, not a logical requirement.

\subsection{Why Formal Treatment Was Delayed}\label{appendix:delay}

Prior work established qualitative foundations (Malayeri \& Aldrich 2008, 2009;
Abdelgawad \& Cartwright 2014; Abdelgawad 2016). We provide the first
machine-verified formal treatment of typing discipline selection.

