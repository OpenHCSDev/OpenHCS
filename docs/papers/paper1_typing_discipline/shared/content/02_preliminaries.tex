\section{Preliminaries}\label{preliminaries}

\subsection{Definitions}\label{definitions}

\textbf{Definition 2.1 (Class).} A class C is a triple (name, bases,
namespace) where: - name \(\in\) String --- the identity of the class -
bases \(\in\) List{[}Class{]} --- explicit inheritance declarations -
namespace \(\in\) Dict{[}String, Any{]} --- attributes and methods

\textbf{Definition 2.2 (Typing Discipline).} A typing discipline T is a
method for determining whether an object x satisfies a type constraint
A.

\textbf{Definition 2.3 (Nominal Typing).} x satisfies A iff A \(\in\)
MRO(type(x)). The constraint is checked via explicit inheritance.

\textbf{Definition 2.4 (Structural Typing).} x satisfies A iff
namespace(x) \(\supseteq\) signature(A). The constraint is checked via
method/attribute matching. In Python, \texttt{typing.Protocol}
implements structural typing: a class satisfies a Protocol if it has
matching method signatures, regardless of inheritance.

\textbf{Definition 2.5 (Duck Typing).} x satisfies A iff hasattr(x, m)
returns True for each m in some implicit set M. The constraint is
checked via runtime string-based probing.

\textbf{Observation 2.1 (Shape-Based Typing).} Structural typing and
duck typing are both \emph{shape-based}: they check what methods or
attributes an object has, not what type it is. Nominal typing is
\emph{identity-based}: it checks the inheritance chain. This distinction
is fundamental. Python's \texttt{Protocol}, TypeScript's interfaces, and
Go's implicit interface satisfaction are all shape-based. ABCs with
explicit inheritance are identity-based. The theorems in this paper
prove shape-based typing cannot provide provenance---regardless of
whether the shape-checking happens at compile time (structural) or
runtime (duck).

\textbf{Complexity distinction:} While structural typing and duck typing
are both shape-based, they differ critically in \emph{when} the
shape-checking occurs:

\begin{itemize}
\tightlist
\item
  \textbf{Structural typing} (Protocol): Shape-checking at \emph{static
  analysis time} or \emph{type definition time}. Complexity: O(k) where
  k = number of classes implementing the protocol.
\item
  \textbf{Duck typing} (hasattr/getattr): Shape-checking at
  \emph{runtime, per call site}. Complexity: \(\Omega\)(n) where n =
  number of call sites.
\end{itemize}

This explains why structural typing (TypeScript interfaces, Go
interfaces, Python Protocols) is considered superior to duck typing in
practice: both are shape-based, but structural typing performs the
checking once at compile/definition time, while duck typing repeats the
checking at every usage site.

\textbf{Critical insight:} Even though structural typing has better
complexity than duck typing (O(k) vs \(\Omega\)(n)), \emph{both} are
strictly dominated by nominal typing's O(1) error localization (Theorem
4.1). Nominal typing checks inheritance at the single class definition
point---not once per implementing class (structural) or once per call
site (duck).

\subsection{The type() Theorem}\label{the-type-theorem}

\textbf{Theorem 2.1 (Completeness).} For any valid triple (name, bases,
namespace), \texttt{type(name,\ bases,\ namespace)} produces a class C
with exactly those properties.

\emph{Proof.} By construction:

\begin{verbatim}
C = type(name, bases, namespace)
assert C.\_\_name\_\_ == name
assert C.\_\_bases\_\_ == bases
assert all(namespace[k] == getattr(C, k) for k in namespace)
\end{verbatim}

The \texttt{class} statement is syntactic sugar for \texttt{type()}. Any
class expressible via syntax is expressible via \texttt{type()}.
\(\blacksquare\)

\textbf{Theorem 2.2 (Semantic Minimality).} The semantically minimal
class constructor has arity 2: \texttt{type(bases,\ namespace)}.

\emph{Proof.} - \texttt{bases} determines inheritance hierarchy and MRO
- \texttt{namespace} determines attributes and methods - \texttt{name}
is metadata; object identity distinguishes types at runtime - Each call
to \texttt{type(bases,\ namespace)} produces a distinct object -
Therefore name is not necessary for type semantics. \(\blacksquare\)

\textbf{Theorem 2.3 (Practical Minimality).} The practically minimal
class constructor has arity 3: \texttt{type(name,\ bases,\ namespace)}.

\emph{Proof.} The name string is required for: 1. \textbf{Debugging}:
\texttt{repr(C)} \(\rightarrow\)
\texttt{\textless{}class\ \textquotesingle{}\_\_main\_\_.Foo\textquotesingle{}\textgreater{}}
vs
\texttt{\textless{}class\ \textquotesingle{}\_\_main\_\_.???\textquotesingle{}\textgreater{}}
2. \textbf{Serialization}: Pickling uses \texttt{\_\_name\_\_} to
reconstruct classes 3. \textbf{Error messages}: ``Expected Foo, got
Bar'' requires names 4. \textbf{Metaclass protocols}:
\texttt{\_\_init\_subclass\_\_}, registries key on \texttt{\_\_name\_\_}

Without name, the system is semantically complete but practically
unusable. \(\blacksquare\)

\textbf{Definition 2.6 (The Two-Axis Semantic Core).} The semantic core
of Python's class system is: - \textbf{bases}: inheritance relationships
(\(\rightarrow\) MRO, nominal typing) - \textbf{namespace}: attributes
and methods (\(\rightarrow\) behavior, structural typing)

The \texttt{name} axis is orthogonal to both and carries no semantic
weight.

\textbf{Theorem 2.4 (Orthogonality of Semantic Axes).} The
\texttt{bases} and \texttt{namespace} axes are orthogonal.

\emph{Proof.} Independence: - Changing bases does not change namespace
content (only resolution order for inherited methods) - Changing
namespace does not change bases or MRO

The factorization (bases, namespace) is unique. \(\blacksquare\)

\textbf{Corollary 2.5.} The semantic content of a class is fully
determined by (bases, namespace). Two classes with identical bases and
namespace are semantically equivalent, differing only in object
identity.

\subsection{C3 Linearization (Prior
Work)}\label{c3-linearization-prior-work}

\textbf{Theorem 2.6 (C3 Optimality).} C3 linearization is the unique
algorithm satisfying: 1. \textbf{Monotonicity:} If A precedes B in
linearization of C, and C' extends C, then A precedes B in linearization
of C' 2. \textbf{Local precedence:} A class precedes its parents in its
own linearization 3. \textbf{Consistency:} Linearization respects all
local precedence orderings

\emph{Proof.} See Barrett et al.~(1996), ``A Monotonic Superclass
Linearization for Dylan.'' \(\blacksquare\)

\textbf{Corollary 2.7.} Given bases, MRO is deterministically derived.
There is no configuration; there is only computation.

\subsection{Abstract Class System
Model}\label{abstract-class-system-model}

We formalize class systems independently of any specific language. This
establishes that our theorems apply to \textbf{any} language with
explicit inheritance, not just Python.

\paragraph{2.4.1 The Three-Axis Model}\label{the-three-axis-model}

\textbf{Definition 2.7 (Abstract Class System).} A class system is a
tuple \((N, B, S)\) where: - \(N\): Name --- the identifier for a type -
\(B\): Bases --- the set of explicitly declared parent types
(inheritance) - \(S\): Namespace --- the set of (attribute, value) pairs
defining the type's interface

\textbf{Definition 2.8 (Class Constructor).} A class constructor is a
function: \[\text{class}: N \times \mathcal{P}(T) \times S \to T\] where
\(T\) is the universe of types, taking a name, a set of base types, and
a namespace, returning a new type.

\textbf{Language instantiations:}

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1887}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1132}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1321}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2075}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.3585}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Language
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Name
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Bases
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Namespace
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Constructor Syntax
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Python & \texttt{str} & \texttt{tuple{[}type{]}} &
\texttt{dict{[}str,\ Any{]}} &
\texttt{type(name,\ bases,\ namespace)} \\
Java & \texttt{String} & \texttt{Class\textless{}?\textgreater{}} &
method/field declarations &
\texttt{class\ Name\ extends\ Base\ \{\ ...\ \}} \\
C\# & \texttt{string} & \texttt{Type} & member declarations &
\texttt{class\ Name\ :\ Base\ \{\ ...\ \}} \\
Ruby & \texttt{Symbol} & \texttt{Class} & method definitions &
\texttt{class\ Name\ \textless{}\ Base;\ end} \\
TypeScript & \texttt{string} & \texttt{Function} & property declarations
& \texttt{class\ Name\ extends\ Base\ \{\ ...\ \}} \\
\end{longtable}

\textbf{Definition 2.9 (Reduced Class System).} A class system is
\emph{reduced} if \(B = \emptyset\) for all types (no inheritance).
Examples: Go (structs only), C (no classes), JavaScript ES5
(prototype-based, no \texttt{class} keyword).

\textbf{Remark (Implicit Root Classes).} In Python, every class
implicitly inherits from \texttt{object}: \texttt{class\ X:\ pass} has
\texttt{X.\_\_bases\_\_\ ==\ (object,)}. Definition 2.9's
``\(B = \emptyset\)'' refers to the abstract model where inheritance
from a universal root (Python's \texttt{object}, Java's \texttt{Object})
is elided. Equivalently, \(B = \emptyset\) means ``no user-declared
inheritance beyond the implicit root.'' The theorems apply when
\(B \neq \emptyset\) in this sense---i.e., when the programmer
explicitly declares inheritance relationships.

\textbf{Remark (Go Embedding $\\neq$ Inheritance).} Go's struct embedding
provides method forwarding but is not inheritance: (1) embedded methods
cannot be overridden---calling \texttt{outer.Method()} always invokes
the embedded type's implementation, (2) there is no MRO---Go has no
linearization algorithm, (3) there is no \texttt{super()} equivalent.
Embedding is composition with syntactic sugar, not polymorphic
inheritance. Therefore Go has \(B = \emptyset\).

\paragraph{2.4.2 Typing Disciplines as Axis
Projections}\label{typing-disciplines-as-axis-projections}

\textbf{Definition 2.10 (Shape-Based Typing).} A typing discipline is
\emph{shape-based} if type compatibility is determined solely by \(S\)
(namespace):
\[\text{compatible}_{\text{shape}}(x, T) \iff S(\text{type}(x)) \supseteq S(T)\]

Shape-based typing projects out the \(B\) axis entirely. It cannot
distinguish types with identical namespaces.

\textbf{Remark (Operational Characterization).} In Python, shape-based
compatibility reduces to capability probing via \texttt{hasattr}:
\texttt{all(hasattr(x,\ a)\ for\ a\ in\ S(T))}. We use \texttt{hasattr}
(not \texttt{getattr}) because shape-based typing is about
\emph{capability detection}, not attribute retrieval. \texttt{getattr}
involves metaprogramming machinery (\texttt{\_\_getattr\_\_},
\texttt{\_\_getattribute\_\_}, descriptors) orthogonal to type
discipline.

\textbf{Remark (Partial vs Full Structural Compatibility).} Definition
2.10 uses partial compatibility (\(\supseteq\)): \(x\) has \emph{at
least} \(T\)'s interface. Full compatibility (\(=\)) requires exact
match. Both are \(\{S\}\)-only disciplines; the capability gap (Theorem
2.17) applies to both. The distinction is a refinement \emph{within} the
S axis, not a fourth axis.

\textbf{Definition 2.10a (Typing Discipline Completeness).} A typing
discipline is \emph{complete} if it provides a well-defined,
deterministic answer to ``when is \(x\) compatible with \(T\)?'' for all
\(x\) and declared \(T\). Formally: there exists a predicate
\(\text{compatible}(x, T)\) that is well-defined for all \((x, T)\)
pairs where \(T\) is a declared type constraint.

\textbf{Remark (Completeness vs Coherence).} Definition 2.10a defines
\emph{completeness}: whether the discipline answers the compatibility
question. Definition 8.3 later defines \emph{coherence}: whether the
discipline's answers align with runtime semantics. These are distinct
properties. A discipline can be complete but incoherent (TypeScript's
structural typing with \texttt{class}), or incomplete and thus trivially
incoherent (duck typing).

\textbf{Definition 2.10b (Structural Typing).} Structural typing with
declared interfaces (e.g., \texttt{typing.Protocol}) is coherent: \(T\)
is declared as a Protocol with interface \(S(T)\), and compatibility is
\(S(\text{type}(x)) \supseteq S(T)\). The discipline commits to a
position: ``structure determines compatibility.''

\textbf{Definition 2.10c (Duck Typing).} Duck typing is ad-hoc
capability probing: \texttt{hasattr(x,\ attr)} for individual attributes
without declaring \(T\). No interface is specified; the ``required
interface'' is implicit in whichever attributes the code path happens to
access.

\textbf{Theorem 2.10d (Duck Typing Incoherence).} Duck typing is not a
coherent typing discipline.

\emph{Proof.} A coherent discipline requires a well-defined
\(\text{compatible}(x, T)\) for declared \(T\). Duck typing:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Does not declare \(T\).} There is no Protocol, no interface,
  no specification of required capabilities. The ``interface'' is
  implicit in the code.
\item
  \textbf{Provides different answers based on code path.} If module
  \(A\) probes
  \texttt{hasattr(x,\ \textquotesingle{}foo\textquotesingle{})} and
  module \(B\) probes
  \texttt{hasattr(x,\ \textquotesingle{}bar\textquotesingle{})}, the
  same object \(x\) is ``compatible'' with \(A\)'s requirements iff it
  has \texttt{foo}, and ``compatible'' with \(B\)'s requirements iff it
  has \texttt{bar}. There is no unified \(T\) to check against.
\item
  \textbf{Commits to neither position on structure-semantics
  relationship:}

  \begin{itemize}
  \tightlist
  \item
    ``Structure = semantics'' would require checking \emph{full}
    structural compatibility against a declared interface
  \item
    ``Structure $\\neq$ semantics'' would require nominal identity via
    inheritance
  \item
    Duck typing checks \emph{partial} structure \emph{ad-hoc} without
    declaration---neither position
  \end{itemize}
\end{enumerate}

A discipline that gives different compatibility answers depending on
which code path executes, with no declared \(T\) to verify against, is
not a discipline. It is the absence of one. \(\blacksquare\)

\textbf{Corollary 2.10e (Duck Typing vs Structural Typing).} Duck typing
(\(\{S\}\), ad-hoc) is strictly weaker than structural typing with
Protocols (\(\{N, S\}\), declared). The distinction is not just
``dominated'' but ``incoherent vs coherent.''

\emph{Proof.} Protocols declare \(T\), enabling static verification,
documentation, and composition guarantees. Duck typing declares nothing.
A Protocol-based discipline is coherent (Definition 2.10a); duck typing
is not (Theorem 2.10d). \(\blacksquare\)

\textbf{Corollary 2.10f (No Valid Context for Duck Typing).} There
exists no production context where duck typing is the correct choice.

\emph{Proof.} In systems with inheritance (\(B \neq \emptyset\)):
nominal typing (\(\{N, B, S\}\)) strictly dominates. In systems without
inheritance (\(B = \emptyset\)): structural typing with Protocols
(\(\{N, S\}\)) is coherent and strictly dominates incoherent duck
typing. The only ``advantage'' of duck typing---avoiding interface
declaration---is not a capability but deferred work with negative value
(lost verification, documentation, composition guarantees).
\(\blacksquare\)

\textbf{Theorem 2.10g (Structural Typing Eliminability).} In systems
with inheritance (\(B \neq \emptyset\)), structural typing is eliminable
via boundary adaptation.

\emph{Proof.} Let \(S\) be a system using Protocol \(P\) to accept
third-party type \(T\) that cannot be modified.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Adapter construction.} Define adapter class:
  \texttt{class\ TAdapter(T,\ P\_as\_ABC):\ pass}
\item
  \textbf{Boundary wrapping.} At ingestion, wrap:
  \texttt{adapted\ =\ TAdapter(instance)} (for instances) or simply use
  \texttt{TAdapter} as the internal type (for classes)
\item
  \textbf{Internal nominal typing.} All internal code uses
  \texttt{isinstance(x,\ P\_as\_ABC)} with nominal semantics
\item
  \textbf{Equivalence.} The adapted system \(S'\) accepts exactly the
  same inputs as \(S\) but uses nominal typing internally
\end{enumerate}

The systems are equivalent in capability. Structural typing provides no
capability that nominal typing with adapters lacks. \(\blacksquare\)

\textbf{Corollary 2.10h (Structural Typing as Convenience).} When
\(B \neq \emptyset\), structural typing (Protocol) is not a typing
necessity but a convenience---it avoids writing the 2-line adapter
class. Convenience is not a typing capability.

\textbf{Corollary 2.10i (Typing Discipline Hierarchy).} The typing
disciplines form a strict hierarchy:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Duck typing} (\(\{S\}\), ad-hoc): Incoherent (Theorem 2.10d).
  Never valid.
\item
  \textbf{Structural typing} (\(\{N, S\}\), Protocol): Coherent but
  eliminable when \(B \neq \emptyset\) (Theorem 2.10g). Valid only when
  \(B = \emptyset\).
\item
  \textbf{Nominal typing} (\(\{N, B, S\}\), ABC): Coherent and
  necessary. The only non-eliminable discipline for systems with
  inheritance.
\end{enumerate}

\textbf{Theorem 2.10j (Protocol Is Strictly Dominated When B $\neq$ $\emptyset$).}\label{thm:protocol-strictly-dominated} In
systems with inheritance, Protocol is strictly dominated by explicit
adapters.

\emph{Proof.} Compare the two approaches for accepting third-party type
\(T\):

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2632}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2632}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4737}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Property
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Protocol
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Explicit Adapter
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Accepts same inputs & Yes & Yes \\
Documents adaptation boundary & No (implicit) & Yes (class
definition) \\
Failure mode & Runtime (\texttt{isinstance} returns False, or missing
method during execution) & Class definition time (if \(T\) lacks
required methods) \\
Provenance & No (\(T\) not in your hierarchy) & Yes (adapter is in your
hierarchy) \\
Explicit & No & Yes \\
\end{longtable}

The adapter provides strictly more: same inputs, plus explicit
documentation, plus fail-loud at definition time, plus provenance.
Protocol provides strictly less.

Protocol's only ``advantage'' is avoiding the 2-line adapter class. But
avoiding explicitness is not an advantage---it is negative value.
``Explicit is better than implicit'' (Zen of Python, line 2).
\(\blacksquare\)

\textbf{Corollary 2.10k (Protocol's Value Proposition Is Negative).}
When \(B \neq \emptyset\), Protocol trades explicitness, fail-loud
behavior, and provenance for 2 fewer lines of code. This is not a
tradeoff---it is a loss.

\textbf{Corollary 2.10l (Complete Typing Discipline Validity).} The
complete validity table:

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2034}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4237}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3729}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Discipline
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
When \(B \neq \emptyset\)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
When \(B = \emptyset\)
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Duck typing & Never (incoherent) & Never (incoherent) \\
Protocol & Never (dominated by adapters) & Valid (only coherent
option) \\
Nominal/Adapters & Always & N/A (requires \(B\)) \\
\end{longtable}

\paragraph{2.4.2a The Metaprogramming Capability
Gap}\label{a-the-metaprogramming-capability-gap}

Beyond typing discipline, nominal and structural typing differ in a
second, independent dimension: \textbf{metaprogramming capability}. This
gap is not an implementation accident---it is mathematically necessary.

\textbf{Definition 2.10m (Declaration-Time Event).} A
\emph{declaration-time event} occurs when a type is defined, before any
instance exists. Examples: class definition, inheritance declaration,
trait implementation.

\textbf{Definition 2.10n (Query-Time Check).} A \emph{query-time check}
occurs when type compatibility is evaluated during program execution.
Examples: \texttt{isinstance()}, Protocol conformance check, structural
matching.

\textbf{Definition 2.10o (Metaprogramming Hook).} A
\emph{metaprogramming hook} is a user-defined function that executes in
response to a declaration-time event. Examples:
\texttt{\_\_init\_subclass\_\_()}, metaclass \texttt{\_\_new\_\_()},
Rust's \texttt{\#{[}derive{]}}.

\textbf{Theorem 2.10p (Hooks Require Declarations).} Metaprogramming
hooks require declaration-time events. Structural typing provides no
declaration-time events for conformance. Therefore, structural typing
cannot provide conformance-based metaprogramming hooks.

\emph{Proof.} 1. A hook is a function that fires when an event occurs.
2. In nominal typing, \texttt{class\ C(Base)} is a declaration-time
event. The act of writing the inheritance declaration fires hooks:
Python's \texttt{\_\_init\_subclass\_\_()}, metaclass
\texttt{\_\_new\_\_()}, Java's annotation processors, Rust's derive
macros. 3. In structural typing, ``Does \(X\) conform to interface
\(I\)?'' is evaluated at query time. There is no syntax declaring
``\(X\) implements \(I\)''---conformance is inferred from structure. 4.
No declaration $\\rightarrow$ no event. No event $\\rightarrow$ no hook point. 5. Therefore,
structural typing cannot provide hooks that fire when a type ``becomes''
conformant to an interface. \(\blacksquare\)

\textbf{Theorem 2.10q (Enumeration Requires Registration).} To enumerate
all types conforming to interface \(I\), a registry mapping types to
interfaces is required. Nominal typing provides this registry implicitly
via inheritance declarations. Structural typing does not.

\emph{Proof.} 1. Enumeration requires a finite data structure containing
conforming types. 2. In nominal typing, each declaration
\texttt{class\ C(Base)} registers \(C\) as a subtype of \(\text{Base}\).
The transitive closure of declarations forms the registry.
\texttt{\_\_subclasses\_\_()} queries this registry in \(O(k)\) where
\(k = |\text{subtypes}(T)|\). 3. In structural typing, no registration
occurs. Conformance is computed at query time by checking structural
compatibility. 4. To enumerate conforming types under structural typing,
one must iterate over all types in the universe and check conformance
for each. In an open system (where new types can be added at any time),
\(|\text{universe}|\) is unbounded. 5. Therefore, enumeration under
structural typing is \(O(|\text{universe}|)\), which is infeasible for
open systems. \(\blacksquare\)

\textbf{Corollary 2.10r (Metaprogramming Capability Gap Is Necessary).}
The gap between nominal and structural typing in metaprogramming
capability is not an implementation choice---it is a logical consequence
of declaration vs.~query.

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2308}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3077}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3654}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.0962}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Capability
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Nominal Typing
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Structural Typing
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Why
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Definition-time hooks & Yes (\texttt{\_\_init\_subclass\_\_}, metaclass)
& No & Requires declaration event \\
Enumerate implementers & Yes (\texttt{\_\_subclasses\_\_()}, O(k)) & No
(O($\\infty$) in open systems) & Requires registration \\
Auto-registration & Yes (metaclass \texttt{\_\_new\_\_}) & No & Requires
hook \\
Derive/generate code & Yes (Rust \texttt{\#{[}derive{]}}, Python
descriptors) & No & Requires declaration context \\
\end{longtable}

\textbf{Corollary 2.10s (Universal Applicability).} This gap applies to
all languages:

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1515}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1212}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3636}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3636}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Language
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Typing
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Enumerate implementers?
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Definition-time hooks?
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Go & Structural & No & No \\
TypeScript & Structural & No & No (decorators are nominal---require
\texttt{class}) \\
Python Protocol & Structural & No & No \\
Python ABC & Nominal & Yes (\texttt{\_\_subclasses\_\_()}) & Yes
(\texttt{\_\_init\_subclass\_\_}, metaclass) \\
Java & Nominal & Yes (reflection) & Yes (annotation processors) \\
C\# & Nominal & Yes (reflection) & Yes (attributes, source
generators) \\
Rust traits & Nominal (\texttt{impl}) & Yes & Yes
(\texttt{\#{[}derive{]}}, proc macros) \\
Haskell typeclasses & Nominal (\texttt{instance}) & Yes & Yes (deriving,
TH) \\
\end{longtable}

\textbf{Remark (TypeScript Decorators).} TypeScript decorators appear to
be metaprogramming hooks, but they attach to \emph{class declarations},
not structural conformance. A decorator fires when \texttt{class\ C} is
defined---this is a nominal event (the class is named and declared).
Decorators cannot fire when ``some object happens to match interface
I''---that is a query, not a declaration.

\textbf{Remark (The Two Axes of Dominance).} Nominal typing strictly
dominates structural typing on two independent axes: 1. \textbf{Typing
capability} (Theorems 2.10j, 2.18): Provenance, identity, enumeration,
conflict resolution 2. \textbf{Metaprogramming capability} (Theorems
2.10p, 2.10q): Hooks, registration, code generation

Neither axis is an implementation accident. Both follow from the
structure of declaration vs.~query. Protocol is dominated on both axes.

\textbf{Remark.} Languages without inheritance (Go) have
\(B = \emptyset\) by design. For these languages, structural typing with
declared interfaces is the correct choice---not because structural
typing is superior, but because nominal typing requires \(B\) and Go
provides none. Go's interfaces are coherent (\(\{N, S\}\)). Go does not
use duck typing.

\textbf{Remark (Historical Context).} Duck typing became established in
Python practice without formal capability analysis. This paper provides
the first machine-verified comparison of typing discipline capabilities.
See Appendix~\ref{appendix:historical} for additional historical context.

\textbf{Definition 2.11 (Nominal Typing).} A typing discipline is
\emph{nominal} if type compatibility requires identity in the
inheritance hierarchy:
\[\text{compatible}_{\text{nominal}}(x, T) \iff T \in \text{ancestors}(\text{type}(x))\]

where
\(\text{ancestors}(C) = \{C\} \cup \bigcup_{P \in B(C)} \text{ancestors}(P)\)
(transitive closure over \(B\)).

\paragraph{2.4.3 Provenance as MRO Query}\label{provenance-as-mro-query}

\textbf{Definition 2.12 (Provenance Query).} A provenance query asks:
``Given object \(x\) and attribute \(a\), which type
\(T \in \text{MRO}(\text{type}(x))\) provided the value of \(a\)?''

\textbf{Theorem 2.13 (Provenance Requires MRO).} Provenance queries
require access to MRO, which requires access to \(B\).

\emph{Proof.} MRO is defined as a linearization over ancestors, which is
the transitive closure over \(B\). Without \(B\), MRO is undefined.
Without MRO, provenance queries cannot be answered. \(\blacksquare\)

\textbf{Corollary 2.14 (Shape-Based Typing Cannot Provide Provenance).}
Shape-based typing cannot answer provenance queries.

\emph{Proof.} By Definition 2.10, shape-based typing uses only \(S\). By
Theorem 2.13, provenance requires \(B\). Shape-based typing has no
access to \(B\). Therefore shape-based typing cannot provide provenance.
\(\blacksquare\)

\paragraph{2.4.4 Cross-Language
Instantiation}\label{cross-language-instantiation}

\textbf{Table 2.1: Cross-Language Instantiation of the (N, B, S) Model}

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1695}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1695}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1864}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2542}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2203}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Language
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
N (Name)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
B (Bases)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
S (Namespace)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Type System
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Python & \texttt{type(x).\_\_name\_\_} & \texttt{\_\_bases\_\_},
\texttt{\_\_mro\_\_} & \texttt{\_\_dict\_\_}, \texttt{dir()} &
Nominal \\
Java & \texttt{getClass().getName()} & \texttt{getSuperclass()},
\texttt{getInterfaces()} & \texttt{getDeclaredMethods()} & Nominal \\
Ruby & \texttt{obj.class.name} & \texttt{ancestors} (include order) &
\texttt{methods}, \texttt{instance\_variables} & Nominal \\
C\# & \texttt{GetType().Name} & \texttt{BaseType},
\texttt{GetInterfaces()} & \texttt{GetProperties()},
\texttt{GetMethods()} & Nominal \\
\end{longtable}

All four languages provide \textbf{runtime access to all three axes}.
The critical difference lies in which axes the \textbf{type system}
inspects.

\textbf{Table 2.2: Generic Types Across Languages --- Parameterized N,
Not a Fourth Axis}

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2083}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2083}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2083}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3750}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Language
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Generics
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Encoding
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Runtime Behavior
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Java & \texttt{List\textless{}T\textgreater{}} & Parameterized N:
\texttt{(List,\ {[}T{]})} & Erased to \texttt{List} \\
C\# & \texttt{List\textless{}T\textgreater{}} & Parameterized N:
\texttt{(List,\ {[}T{]})} & Fully reified \\
TypeScript & \texttt{Array\textless{}T\textgreater{}} & Parameterized N:
\texttt{(Array,\ {[}T{]})} & Compile-time only \\
Rust & \texttt{Vec\textless{}T\textgreater{}} & Parameterized N:
\texttt{(Vec,\ {[}T{]})} & Monomorphized \\
Kotlin & \texttt{List\textless{}T\textgreater{}} & Parameterized N:
\texttt{(List,\ {[}T{]})} & Erased (reified via \texttt{inline}) \\
Swift & \texttt{Array\textless{}T\textgreater{}} & Parameterized N:
\texttt{(Array,\ {[}T{]})} & Specialized at compile-time \\
Scala & \texttt{List{[}T{]}} & Parameterized N:
\texttt{(List,\ {[}T{]})} & Erased \\
C++ & \texttt{vector\textless{}T\textgreater{}} & Parameterized N:
\texttt{(vector,\ {[}T{]})} & Template instantiation \\
\end{longtable}

\textbf{Key observation:} No major language invented a fourth axis for
generics. All encode type parameters as an extension of the Name axis:
\(N_{\text{generic}} = (G, [T_1, \ldots, T_k])\) where \(G\) is the base
name and \([T_i]\) are type arguments. The \((N, B, S)\) model is
\textbf{universal} across generic type systems.

\subsection{The Axis Lattice
Metatheorem}\label{the-axis-lattice-metatheorem}

The three-axis model \((N, B, S)\) induces a lattice of typing
disciplines. Each discipline is characterized by which axes it inspects:

\small
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Axis Subset & Discipline & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\(\emptyset\) & Untyped & Accept all \\
\(\{N\}\) & Named-only & Type aliases \\
\(\{S\}\) & Shape-based (ad-hoc) & Duck typing, \texttt{hasattr} \\
\(\{S\}\) & Shape-based (declared) & OCaml
\texttt{\textless{}\ get\ :\ int;\ ..\ \textgreater{}} \\
\(\{N, S\}\) & Named structural & \texttt{typing.Protocol} \\
\(\{N, B, S\}\) & Nominal & ABCs, \texttt{isinstance} \\
\end{longtable}

\textbf{Critical distinction within \(\{S\}\):} The axis subset does not
capture whether the interface is \emph{declared}. This is orthogonal to
which axes are inspected:

\small
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Discipline & Axes Used & Interface Declared? & Coherent? \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Duck typing & \(\{S\}\) & No (ad-hoc \texttt{hasattr}) & No (Thm
2.10d) \\
OCaml structural & \(\{S\}\) & Yes (inline type) & Yes \\
Protocol & \(\{N, S\}\) & Yes (named interface) & Yes \\
Nominal & \(\{N, B, S\}\) & Yes (class hierarchy) & Yes \\
\end{longtable}

Duck typing and OCaml structural typing both use \(\{S\}\), but duck
typing has \textbf{no declared interface}---conformance is checked
ad-hoc at runtime via \texttt{hasattr}. OCaml declares the interface
inline:
\texttt{\textless{}\ get\ :\ int;\ set\ :\ int\ -\textgreater{}\ unit\ \textgreater{}}
is a complete type specification, statically verified. The interface's
``name'' is its canonical structure: \(N = \text{canonical}(S)\).

\textbf{Theorem 2.10d (Incoherence) applies to duck typing, not to
OCaml.} The incoherence arises from the lack of a declared interface,
not from using axis subset \(\{S\}\).

\textbf{Theorems 2.10p-q (Metaprogramming Gap) apply to both.} Neither
duck typing nor OCaml structural typing can enumerate conforming types
or provide definition-time hooks, because neither has a declaration
event. This is independent of coherence.

Note: \texttt{hasattr(obj,\ \textquotesingle{}foo\textquotesingle{})}
checks namespace membership, not \texttt{type(obj).\_\_name\_\_}.
\texttt{typing.Protocol} uses \(\{N, S\}\): it can see type names and
namespaces, but ignores inheritance. Our provenance impossibility
theorems use the weaker \(\{N, S\}\) constraint to prove stronger
results.

\textbf{Theorem 2.15 (Axis Lattice Dominance).} For any axis subsets
\(A \subseteq A' \subseteq \{N, B, S\}\), the capabilities of discipline
using \(A\) are a subset of capabilities of discipline using \(A'\):
\[\text{capabilities}(A) \subseteq \text{capabilities}(A')\]

\emph{Proof.} Each axis enables specific capabilities: - \(N\): Type
naming, aliasing - \(B\): Provenance, identity, enumeration, conflict
resolution - \(S\): Interface checking

A discipline using subset \(A\) can only employ capabilities enabled by
axes in \(A\). Adding an axis to \(A\) adds capabilities but removes
none. Therefore the capability sets form a monotonic lattice under
subset inclusion. \(\blacksquare\)

\textbf{Corollary 2.16 (Bases Axis Primacy).} The Bases axis \(B\) is
the source of all strict dominance. Specifically: provenance, type
identity, subtype enumeration, and conflict resolution all require
\(B\). Any discipline that discards \(B\) forecloses these capabilities.

\textbf{Theorem 2.17 (Capability Completeness).} The capability set
\(\mathcal{C}_B = \{\text{provenance, identity, enumeration, conflict resolution}\}\)
is \textbf{exactly} the set of capabilities enabled by the Bases axis.
Formally:

\[c \in \mathcal{C}_B \iff c \text{ requires } B\]

\emph{Proof.} We prove both directions:

\textbf{(\(\Rightarrow\)) Each capability in \(\mathcal{C}_B\) requires
\(B\):}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Provenance} (``which type provided value \(v\)?''): By
  Definition 2.12, provenance queries require MRO traversal. MRO is the
  C3 linearization of ancestors, which is the transitive closure over
  \(B\). Without \(B\), MRO is undefined. \(\checkmark\)
\item
  \textbf{Identity} (``is \(x\) an instance of \(T\)?''): By Definition
  2.11, nominal compatibility requires
  \(T \in \text{ancestors}(\text{type}(x))\). Ancestors is defined as
  transitive closure over \(B\). Without \(B\), ancestors is undefined.
  \(\checkmark\)
\item
  \textbf{Enumeration} (``what are all subtypes of \(T\)?''): A subtype
  \(S\) of \(T\) satisfies \(T \in \text{ancestors}(S)\). Enumerating
  subtypes requires inverting the ancestor relation, which requires
  \(B\). \(\checkmark\)
\item
  \textbf{Conflict resolution} (``which definition wins in diamond
  inheritance?''): Diamond inheritance produces multiple paths to a
  common ancestor. Resolution uses MRO ordering, which requires \(B\).
  \(\checkmark\)
\end{enumerate}

\textbf{(\(\Leftarrow\)) No other capability requires \(B\):}

We exhaustively enumerate capabilities NOT in \(\mathcal{C}_B\) and show
none require \(B\):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\item
  \textbf{Interface checking} (``does \(x\) have method \(m\)?''):
  Answered by inspecting \(S(\text{type}(x))\). Requires only \(S\).
  Does not require \(B\). \(\checkmark\)
\item
  \textbf{Type naming} (``what is the name of type \(T\)?''): Answered
  by inspecting \(N(T)\). Requires only \(N\). Does not require \(B\).
  \(\checkmark\)
\item
  \textbf{Value access} (``what is \(x.a\)?''): Answered by attribute
  lookup in \(S(\text{type}(x))\). Requires only \(S\). Does not require
  \(B\). \(\checkmark\)

  \textbf{Remark (Inherited Attributes).} For inherited attributes,
  \(S(\text{type}(x))\) means the \emph{effective} namespace including
  inherited members. Computing this effective namespace initially
  requires \(B\) (to walk the MRO), but once computed, accessing a value
  from the flattened namespace requires only \(S\). The distinction is
  between \emph{computing} the namespace (requires \(B\)) and
  \emph{querying} a computed namespace (requires only \(S\)). Value
  access is the latter.
\item
  \textbf{Method invocation} (``call \(x.m()\)''): Answered by
  retrieving \(m\) from \(S\) and invoking. Requires only \(S\). Does
  not require \(B\). \(\checkmark\)
\end{enumerate}

No capability outside \(\mathcal{C}_B\) requires \(B\). Therefore
\(\mathcal{C}_B\) is exactly the \(B\)-dependent capabilities.
\(\blacksquare\)

\textbf{Significance:} This is a \textbf{tight characterization}, not an
observation. The capability gap is not ``here are some things you
lose''---it is ``here is \textbf{exactly} what you lose, nothing more,
nothing less.'' This completeness result is what distinguishes a formal
theory from an enumerated list.

\textbf{Theorem 2.18 (Strict Dominance --- Abstract).} In any class
system with \(B \neq \emptyset\), nominal typing strictly dominates
shape-based typing.

\emph{Proof.} Let \(\mathcal{C}_{\text{shape}}\) = capabilities of
shape-based typing. Let \(\mathcal{C}_{\text{nominal}}\) = capabilities
of nominal typing.

Shape-based typing can check interface satisfaction:
\(S(\text{type}(x)) \supseteq S(T)\).

Nominal typing can: 1. Check interface satisfaction (equivalent to
shape-based) 2. Check type identity:
\(T \in \text{ancestors}(\text{type}(x))\) --- \textbf{impossible for
shape-based} 3. Answer provenance queries --- \textbf{impossible for
shape-based} (Corollary 2.14) 4. Enumerate subtypes ---
\textbf{impossible for shape-based} 5. Use type as dictionary key ---
\textbf{impossible for shape-based}

Therefore
\(\mathcal{C}_{\text{shape}} \subset \mathcal{C}_{\text{nominal}}\)
(strict subset). In a class system with \(B \neq \emptyset\), both
disciplines are available. Choosing shape-based typing forecloses
capabilities for zero benefit. \(\blacksquare\)

\paragraph{2.5.1 The Decision Procedure}\label{the-decision-procedure}

Given a language \(L\) and development context \(C\):

\begin{verbatim}
FUNCTION select_typing_discipline(L, C):
    IF L has no inheritance syntax (B = $\\emptyset$):
        RETURN structural  # Theorem 3.1: correct when B absent

    # For all cases where B $\\neq$ $\\emptyset$:
    RETURN nominal  # Theorem 2.18: strict dominance

    # Note: "retrofit" is not a separate case. When integrating
    # external types, use explicit adapters (Theorem 2.10j).
    # Protocol is a convenience, not a correct discipline.
\end{verbatim}

This is a \textbf{decision procedure}, not a preference. The output is
determined by whether \(B = \emptyset\).

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

