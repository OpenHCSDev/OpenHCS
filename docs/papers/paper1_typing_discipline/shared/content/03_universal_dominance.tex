\section{Universal Dominance}\label{universal-dominance}

\textbf{Thought experiment:} What if \texttt{type()} only took
namespace?

Given that the semantic core is (bases, namespace), what if we further
reduce to just namespace?

\begin{verbatim}
\# Hypothetical minimal class constructor
def type\_minimal(namespace: dict) {-\textgreater{}} type:
    """Create a class from namespace only."""
    return type("", (), namespace)
\end{verbatim}

\textbf{Definition 3.1 (Namespace-Only System).} A namespace-only class
system is one where: - Classes are characterized entirely by their
namespace (attributes/methods) - No explicit inheritance mechanism
exists (bases axis absent)

\textbf{Theorem 3.1 (Structural Typing Is Correct for Namespace-Only
Systems).}

In a namespace-only system, structural typing is the unique correct
typing discipline.

\emph{Proof.} 1. Let A and B be classes in a namespace-only system 2. A
\(\equiv\) B iff namespace(A) = namespace(B) (by definition of
namespace-only) 3. Structural typing checks: namespace(x) \(\supseteq\)
signature(T) 4. This is the only information available for type checking
5. Therefore structural typing is correct and complete. \(\blacksquare\)

\textbf{Corollary 3.2 (Go's Design Is Consistent).} Go has no
inheritance. Interfaces are method sets. Structural typing is correct
for Go.

\textbf{Corollary 3.3 (TypeScript's Static Type System).} TypeScript's
\emph{static} type system is structural---class compatibility is
determined by shape, not inheritance. However, at runtime, JavaScript's
prototype chain provides nominal identity (\texttt{instanceof} checks
the chain). This creates a coherence tension discussed in Section 8.7.

\textbf{The Critical Observation (Semantic Axes):}

\small
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
System & Semantic Axes & Correct Discipline \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Namespace-only & \texttt{(namespace)} & Structural \\
Full Python & \texttt{(bases,\ namespace)} & Nominal \\
\end{longtable}

The \texttt{name} axis is metadata in both cases---it doesn't affect
which typing discipline is correct.

\textbf{Theorem 3.4 (Bases Mandates Nominal).} The presence of a
\texttt{bases} axis in the class system mandates nominal typing. This is
universal---not limited to greenfield development.

\emph{Proof.} We prove this in two steps: (1) strict dominance holds
unconditionally, (2) retrofit constraints do not constitute an
exception.

\textbf{Step 1: Strict Dominance is Unconditional.}

Let \(D_{\text{shape}}\) be any shape-based discipline (uses only
\(\{S\}\) or \(\{N, S\}\)). Let \(D_{\text{nominal}}\) be nominal typing
(uses \(\{N, B, S\}\)).

By Theorem 2.15 (Axis Lattice Dominance):
\[\text{capabilities}(D_{\text{shape}}) \subseteq \text{capabilities}(D_{\text{nominal}})\]

By Theorem 2.17 (Capability Completeness), \(D_{\text{nominal}}\)
provides four capabilities that \(D_{\text{shape}}\) cannot: provenance,
identity, enumeration, conflict resolution.

Therefore:
\(\text{capabilities}(D_{\text{shape}}) \subset \text{capabilities}(D_{\text{nominal}})\)
(strict subset).

This dominance holds \textbf{regardless of whether the system currently
uses these capabilities}. The capability gap exists by the structure of
axis subsets, not by application requirements.

\textbf{Step 2: Retrofit Constraints Do Not Constitute an Exception.}

One might object: ``In retrofit contexts, external types cannot be made
to inherit from my ABCs, so nominal typing is unavailable.''

This objection was addressed in Theorem 2.10j (Protocol Dominated by
Adapters): when \(B \neq \emptyset\), nominal typing with adapters
provides all capabilities of Protocol plus four additional capabilities.
The ``retrofit exception'' is not an exception---adapters are the
mechanism that makes nominal typing universally available.

\begin{itemize}
\tightlist
\item
  External type cannot inherit from your ABC? Wrap it in an adapter that
  does.
\item
  Protocol avoids the adapter? Yes, but avoiding adapters is a
  convenience, not a capability (Corollary 2.10k).
\end{itemize}

\textbf{Conclusion: Choosing a Dominated Discipline is Incorrect.}

Given two available options \(A\) and \(B\) where
\(\text{capabilities}(A) \subset \text{capabilities}(B)\) and
\(\text{cost}(A) \leq \text{cost}(B)\), choosing \(A\) is
\textbf{dominated} in the decision-theoretic sense: there exists no
rational justification for \(A\) over \(B\).

When \(B \neq \emptyset\): - \(D_{\text{shape}}\) is dominated by
\(D_{\text{nominal}}\) (with adapters if needed) - No constraint makes
\(D_{\text{shape}}\) necessary---adapters handle all retrofit cases -
Therefore choosing \(D_{\text{shape}}\) is incorrect

\textbf{Note on ``what if I don't need the extra capabilities?''}

This objection misunderstands dominance. A dominated choice is incorrect
\textbf{even if the extra capabilities are never used}, because: 1.
Capability availability has zero cost (same declaration syntax, adapters
are trivial) 2. Future requirements are unknown; foreclosing
capabilities has negative expected value 3. ``I don't need it now'' is
not equivalent to ``I will never need it'' 4. The discipline choice is
made once; its consequences persist

The presence of the \texttt{bases} axis creates capabilities that
shape-based typing cannot access. Adapters ensure nominal typing is
always available. The only rational discipline is the one that uses all
available axes. That discipline is nominal typing. \(\blacksquare\)

\textbf{Theorem 3.5 (Strict Dominance---Universal).} Nominal typing
strictly dominates shape-based typing whenever \(B \neq \emptyset\):
nominal provides all capabilities of shape-based typing plus additional
capabilities, at equal or lower cost.

\emph{Proof.} Consider Python's concrete implementations: - Shape-based:
\texttt{typing.Protocol} (structural typing) - Nominal: Abstract Base
Classes (ABCs)

Let S = capabilities provided by Protocol, N = capabilities provided by
ABCs.

\textbf{What Protocols provide:} 1. Interface enforcement via method
signature matching 2. Type checking at static analysis time (mypy,
pyright) 3. No runtime isinstance() check (by default)

\textbf{What ABCs provide:} 1. Interface enforcement via
\texttt{@abstractmethod} (equivalent to Protocol) 2. Type checking at
static analysis time (equivalent to Protocol) 3. \textbf{Type identity
via isinstance()} (Protocol cannot provide this) 4. \textbf{Provenance
tracking via MRO position} (Protocol cannot provide this) 5.
\textbf{Exhaustive enumeration via \texttt{\_\_subclasses\_\_()}}
(Protocol cannot provide this) 6. \textbf{Type-as-dictionary-key via
type() identity} (Protocol cannot provide this) 7. \textbf{Runtime
enforcement at instantiation} (Protocol only checks statically)

Therefore S \(\subset\) N (strict subset). Both require explicit type
declarations. The declaration cost is equivalent: one class definition
per interface. Therefore, nominal typing provides strictly more
capabilities at equal or lower cost (earlier failure). \(\blacksquare\)

\textbf{Corollary 3.6 (Shape Typing Incorrectness).} When
\(B \neq \emptyset\), using shape-based typing instead of nominal typing
is not suboptimal---it is incorrect.

\emph{Proof.} By Theorem 3.5, nominal typing strictly dominates
shape-based typing. By Theorem 2.10j, adapters make nominal typing
universally available. Choosing a strictly dominated option when the
superior option is available is definitionally incorrect.
\(\blacksquare\)

\subsection{The Absolute Claim}\label{the-absolute-claim}

\textbf{Claim (Typing Discipline Correctness).} In any programming
language with explicit inheritance syntax (\(B \neq \emptyset\)),
shape-based typing (structural typing, duck typing, Protocol-based
typing) is \textbf{incorrect}. Nominal typing is \textbf{correct}. This
is not a preference, recommendation, or tradeoff. It is a mathematical
fact derivable from the structure of class systems.

\emph{Proof.} By Theorem 2.18 (Strict Dominance), nominal typing
provides all capabilities of shape-based typing plus additional
capabilities (provenance, type identity, subtype enumeration,
type-as-key). By Theorem 2.10j, adapters eliminate the retrofit
exception. Therefore, choosing shape-based typing when
\(B \neq \emptyset\) is choosing the strictly dominated option.
\(\blacksquare\)

\textbf{What ``incorrect'' means:} 1. \textbf{Information-theoretic}:
Shape-based typing discards the \(B\) axis. Discarding available
information without compensating benefit is suboptimal by definition. 2.
\textbf{Capability-theoretic}: Shape-based typing forecloses
capabilities that nominal typing provides. Foreclosing capabilities for
zero benefit is incorrect. 3. \textbf{Decision-theoretic}: Given the
choice between two options where one strictly dominates, choosing the
dominated option is irrational.

\subsection{Information-Theoretic
Foundations}\label{information-theoretic-foundations}

This section establishes the formal foundation of our
results. We prove three theorems that make claims about all possible
typing disciplines, not just our particular model.

\paragraph{3.8.1 The Impossibility
Theorem}\label{the-impossibility-theorem}

\textbf{Definition 3.10 (Typing Discipline).} A \emph{typing discipline}
\(\mathcal{D}\) over axis set \(A \subseteq \{N, B, S\}\) is a
collection of computable functions that take as input only the
projections of types onto axes in \(A\).

\textbf{Definition 3.11 (Shape Discipline --- Theoretical Upper Bound).}
A \emph{shape discipline} is a typing discipline over \(\{N, S\}\)---it
has access to type names and namespaces, but not to the Bases axis.

\textbf{Note:} Definition 2.10 defines practical shape-based typing as
using only \(\{S\}\) (duck typing doesn't inspect names). We use the
weaker \(\{N, S\}\) constraint here to prove a \textbf{stronger}
impossibility result: even if a discipline has access to type names, it
STILL cannot compute provenance without \(B\). This generalizes to all
shape-based systems, including hypothetical ones that inspect names.

\textbf{Definition 3.12 (Provenance Function).} The \emph{provenance
function} is:
\[\text{prov} : \text{Type} \times \text{Attr} \to \text{Type}\] where
\(\text{prov}(T, a)\) returns the type in \(T\)'s MRO that provides
attribute \(a\).

\textbf{Theorem 3.13 (Provenance Impossibility --- Universal).}\label{thm:provenance-impossibility} Let
\(\mathcal{D}\) be ANY shape discipline (typing discipline over
\(\{N, S\}\) only). Then \(\mathcal{D}\) cannot compute \(\text{prov}\).

\emph{Proof.} We prove this by showing that \(\text{prov}\) requires
information that is information-theoretically absent from \((N, S)\).

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Information content of \((N, S)\).} A shape discipline
  receives: the type name \(N(T)\) and the namespace
  \(S(T) = \{a_1, a_2, \ldots, a_k\}\) (the set of attributes \(T\)
  declares or inherits).
\item
  \textbf{Information content required by \(\text{prov}\).} The function
  \(\text{prov}(T, a)\) must return \emph{which ancestor type}
  originally declared \(a\). This requires knowing the MRO of \(T\) and
  which position in the MRO declares \(a\).
\item
  \textbf{MRO is defined exclusively by \(B\).} By Definition 2.11,
  \(\text{MRO}(T) = \text{C3}(T, B(T))\)---the C3 linearization of
  \(T\)'s base classes. The function
  \(B : \text{Type} \to \text{List}[\text{Type}]\) is the Bases axis.
\item
  \textbf{\((N, S)\) contains no information about \(B\).} The namespace
  \(S(T)\) is the \emph{union} of attributes from all ancestors---it
  does not record \emph{which} ancestor contributed each attribute. Two
  types with identical \(S\) can have completely different \(B\) (and
  therefore different MROs and different provenance answers).
\item
  \textbf{Concrete counterexample.} Let:

  \begin{itemize}
  \tightlist
  \item
    \(A = \text{type}(\text{"A"}, (), \{\text{"x"}: 1\})\)
  \item
    \(B_1 = \text{type}(\text{"B1"}, (A,), \{\})\)
  \item
    \(B_2 = \text{type}(\text{"B2"}, (), \{\text{"x"}: 1\})\)
  \end{itemize}

  Then \(S(B_1) = S(B_2) = \{\text{"x"}\}\) (both have attribute ``x''),
  but:

  \begin{itemize}
  \tightlist
  \item
    \(\text{prov}(B_1, \text{"x"}) = A\) (inherited from parent)
  \item
    \(\text{prov}(B_2, \text{"x"}) = B_2\) (declared locally)
  \end{itemize}

  A shape discipline cannot distinguish \(B_1\) from \(B_2\), therefore
  cannot compute \(\text{prov}\). \(\blacksquare\)
\end{enumerate}

\textbf{Corollary 3.14 (No Algorithm Exists).} There exists no
algorithm, heuristic, or approximation that allows a shape discipline to
compute provenance. This is not a limitation of current
implementations---it is information-theoretically impossible.

\emph{Proof.} The proof of Theorem 3.13 shows that the input \((N, S)\)
contains strictly less information than required to determine
\(\text{prov}\). No computation can extract information that is not
present in its input. \(\blacksquare\)

\textbf{Significance:} This is not ``our model doesn't have
provenance''---it is ``NO model over \((N, S)\) can have provenance.''
The impossibility is mathematical, not implementational.

\paragraph{3.8.2 The Derived Characterization
Theorem}\label{the-derived-characterization-theorem}

A potential objection is that our capability enumeration
\(\mathcal{C}_B = \{\text{provenance, identity, enumeration, conflict resolution}\}\)
is arbitrary. We now prove it is \textbf{derived from information
structure}, not chosen.

\textbf{Definition 3.15 (Query).} A \emph{query} is a computable
function \(q : \text{Type}^k \to \text{Result}\) that a typing
discipline evaluates.

\textbf{Definition 3.16 (Shape-Respecting Query).} A query \(q\) is
\emph{shape-respecting} if for all types with \(S(A) = S(B)\):
\[q(\ldots, A, \ldots) = q(\ldots, B, \ldots)\]

That is, shape-equivalent types produce identical query results.

\textbf{Definition 3.17 (B-Dependent Query).} A query \(q\) is
\emph{B-dependent} if there exist types \(A, B\) with \(S(A) = S(B)\)
but \(q(A) \neq q(B)\).

\textbf{Theorem 3.18 (Query Space Partition).} Every query is either
shape-respecting or B-dependent. These categories are mutually exclusive
and exhaustive.

\emph{Proof.} - \emph{Mutual exclusion:} If \(q\) is shape-respecting,
then \(S(A) = S(B) \Rightarrow q(A) = q(B)\). If \(q\) is B-dependent,
then \(\exists A, B: S(A) = S(B) \land q(A) \neq q(B)\). These are
logical negations. - \emph{Exhaustiveness:} For any query \(q\), either
\(\forall A, B: S(A) = S(B) \Rightarrow q(A) = q(B)\) (shape-respecting)
or \(\exists A, B: S(A) = S(B) \land q(A) \neq q(B)\) (B-dependent).
Tertium non datur. \(\blacksquare\)

\textbf{Theorem 3.19 (Capability Gap = B-Dependent Queries).} The
capability gap between shape and nominal typing is EXACTLY the set of
B-dependent queries:
\[\text{NominalCapabilities} \setminus \text{ShapeCapabilities} = \{q : q \text{ is B-dependent}\}\]

\emph{Proof.} - (\(\supseteq\)) If \(q\) is B-dependent, then
\(\exists A, B\) with \(S(A) = S(B)\) but \(q(A) \neq q(B)\). Shape
disciplines cannot distinguish \(A\) from \(B\), so cannot compute
\(q\). Nominal disciplines have access to \(B\), so can distinguish
\(A\) from \(B\) via MRO. Therefore \(q\) is in the gap. -
(\(\subseteq\)) If \(q\) is in the gap, then nominal can compute it but
shape cannot. If \(q\) were shape-respecting, shape could compute it
(contradiction). Therefore \(q\) is B-dependent. \(\blacksquare\)

\textbf{Theorem 3.20 (Four Capabilities Are Complete).} The set
\(\mathcal{C}_B = \{\text{provenance, identity, enumeration, conflict resolution}\}\)
is the complete set of B-dependent query classes.

\emph{Proof.} We show that every B-dependent query reduces to one of
these four:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Provenance queries} (``which type provided \(a\)?''): Any
  query requiring ancestor attribution.
\item
  \textbf{Identity queries} (``is \(x\) an instance of \(T\)?''): Any
  query requiring MRO membership.
\item
  \textbf{Enumeration queries} (``what are all subtypes of \(T\)?''):
  Any query requiring inverse MRO.
\item
  \textbf{Conflict resolution queries} (``which definition wins?''): Any
  query requiring MRO ordering.
\end{enumerate}

\textbf{Completeness argument:} A B-dependent query must use information
from \(B\). The only information in \(B\) is: - Which types are
ancestors (enables identity, provenance) - The order of ancestors
(enables conflict resolution) - The inverse relation (enables
enumeration)

These three pieces of information (ancestor set, ancestor order, inverse
relation) generate exactly four query classes. No other information
exists in \(B\). \(\blacksquare\)

\textbf{Corollary 3.21 (Capability Set Is Minimal).}
\(|\mathcal{C}_B| = 4\) and no element is redundant.

\emph{Proof.} Each capability addresses a distinct aspect of \(B\): -
Provenance: forward lookup by attribute - Identity: forward lookup by
type - Enumeration: inverse lookup - Conflict resolution: ordering

Removing any one leaves queries that the remaining three cannot answer.
\(\blacksquare\)

\paragraph{3.8.3 The Complexity Lower Bound
Theorem}\label{the-complexity-lower-bound-theorem}

Our O(1) vs $\\Omega$(n) complexity claim requires proving that $\\Omega$(n) is a
\textbf{lower bound}, not merely an upper bound. We must show that NO
algorithm can do better.

\textbf{Definition 3.22 (Computational Model).} We formalize error
localization as a decision problem in the following model:

\begin{itemize}
\tightlist
\item
  \textbf{Input:} A program \(P\) with \(n\) call sites
  \(c_1, \ldots, c_n\), each potentially accessing attribute \(a\) on
  objects of type \(T\).
\item
  \textbf{Oracle:} The algorithm may query an oracle
  \(\mathcal{O}(c_i) \in \{\text{uses } a, \text{does not use } a\}\)
  for each call site.
\item
  \textbf{Output:} The set \(V \subseteq \{c_1, \ldots, c_n\}\) of call
  sites that access \(a\) on objects lacking \(a\).
\item
  \textbf{Correctness:} The algorithm must output the exact set \(V\)
  for all valid inputs.
\end{itemize}

This model captures duck typing's fundamental constraint: type
compatibility is checked at each call site, not at declaration.

\textbf{Definition 3.23 (Inspection Cost).} The \emph{cost} of an
algorithm is the number of oracle queries in the worst case over all
inputs.

\textbf{Theorem 3.24 (Duck Typing Lower Bound).} Any algorithm that
correctly solves error localization in the above model requires
\(\Omega(n)\) oracle queries in the worst case.

\emph{Proof.} By adversary argument and information-theoretic counting.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Adversary construction.} Fix any deterministic algorithm
  \(\mathcal{A}\). We construct an adversary that forces \(\mathcal{A}\)
  to query at least \(n-1\) call sites.
\item
  \textbf{Adversary strategy.} The adversary maintains a set \(S\) of
  ``candidate violators''---call sites that could be the unique
  violating site. Initially \(S = \{c_1, \ldots, c_n\}\). When
  \(\mathcal{A}\) queries \(\mathcal{O}(c_i)\):

  \begin{itemize}
  \tightlist
  \item
    If \(|S| > 1\): Answer ``does not use \(a\)'' and set
    \(S \leftarrow S \setminus \{c_i\}\)
  \item
    If \(|S| = 1\): Answer consistently with \(c_i \in S\) or
    \(c_i \notin S\)
  \end{itemize}
\item
  \textbf{Lower bound derivation.} The algorithm must distinguish
  between \(n\) possible inputs (exactly one of \(c_1, \ldots, c_n\)
  violates). Each query eliminates at most one candidate. After
  \(k < n-1\) queries, \(|S| \geq 2\), so the algorithm cannot determine
  the unique violator. Therefore \(\mathcal{A}\) requires at least
  \(n-1 \in \Omega(n)\) queries.
\item
  \textbf{Generalization.} For the case where multiple call sites may
  violate: there are \(2^n\) possible subsets. Each binary query
  provides at most 1 bit. Therefore \(\log_2(2^n) = n\) queries are
  necessary to identify the exact subset. \(\blacksquare\)
\end{enumerate}

\textbf{Remark (Static Analysis).} Static analyzers precompute call site
information via control-flow analysis over the program text. This shifts
the \(\Omega(n)\) cost to analysis time rather than eliminating it. The
bound characterizes the inherent information content required---\(n\)
bits to identify \(n\) potential violation sites---regardless of when
that information is gathered.

\textbf{Theorem 3.25 (Nominal Typing Upper Bound).} Nominal error
localization requires exactly 1 inspection.

\emph{Proof.} In nominal typing, constraints are declared at the class
definition. The constraint ``type \(T\) must have attribute \(a\)'' is
checked at the single location where \(T\) is defined. If the constraint
is violated, the error is at that location. No call site inspection is
required. \(\blacksquare\)

\textbf{Corollary 3.26 (Complexity Gap Is Unbounded).} The ratio
\(\frac{\text{DuckCost}(n)}{\text{NominalCost}}\) grows without bound:
\[\lim_{n \to \infty} \frac{\Omega(n)}{O(1)} = \infty\]

\emph{Proof.} Immediate from Theorems 3.24 and 3.25. \(\blacksquare\)

\textbf{Corollary 3.27 (Lower Bound Is Tight).} The $\\Omega$(n) lower bound for
duck typing is achieved by naive inspection---no algorithm can do
better, and simple algorithms achieve this bound.

\emph{Proof.} Theorem 3.24 proves \(\Omega(n)\) is necessary. Linear
scan of call sites achieves \(O(n)\). Therefore the bound is tight.
\(\blacksquare\)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Summary: Core Formal
Results}\label{summary-core-formal-results}

We have established three theorems with universal scope:

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2195}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2683}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.5122}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Theorem
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Statement
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Proof Technique
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{3.13 (Impossibility)} & No shape discipline can compute
provenance & Information-theoretic: input lacks required data \\
\textbf{3.19 (Derived Characterization)} & Capability gap = B-dependent
queries & Mathematical: query space partitions exactly \\
\textbf{3.24 (Lower Bound)} & Duck typing requires $\Omega$(n) inspections &
Adversary argument: any algorithm can be forced \\
\end{longtable}

These are not claims about our model---they are claims about \textbf{the
universe of possible typing systems}. The theorems establish:
\begin{itemize}
\tightlist
\item Theorem 3.13 proves no model over $(N, S)$ can provide provenance.
\item Theorem 3.19 proves the capability enumeration is derived from information structure.
\item Theorem 3.24 proves no algorithm can overcome the information-theoretic limitation.
\end{itemize}

These results follow from the structure of the problem, not from our particular formalization.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Information-Theoretic
Completeness}\label{information-theoretic-completeness}

For completeness, we restate the original characterization in the
context of the new foundations.

\textbf{Definition 3.28 (Query).} A \emph{query} is a predicate
\(q : \text{Type} \to \text{Bool}\) that a typing discipline can
evaluate.

\textbf{Definition 3.29 (Shape-Respecting Query).} A query \(q\) is
\emph{shape-respecting} if for all types \(A, B\) with \(S(A) = S(B)\):
\[q(A) = q(B)\]

That is, shape-equivalent types cannot be distinguished by \(q\).

\textbf{Theorem 3.30 (Capability Gap Characterization).} Let
ShapeQueries be the set of all shape-respecting queries, and let
AllQueries be the set of all queries. If there exist types \(A \neq B\)
with \(S(A) = S(B)\), then:
\[\text{ShapeQueries} \subsetneq \text{AllQueries}\]

\emph{Proof.} The identity query \(\text{isA}(T) := (T = A)\) is in
AllQueries but not ShapeQueries, because isA(A) = true but isA(B) =
false despite \(S(A) = S(B)\). \(\blacksquare\)

\textbf{Corollary 3.31 (Derived Capability Set).} The capability gap
between shape-based and nominal typing is \textbf{exactly} the set of
queries that depend on the Bases axis:
\[\text{Capability Gap} = \{ q \mid \exists A, B.\ S(A) = S(B) \land q(A) \neq q(B) \}\]

This is not an enumeration---it's a \textbf{characterization}. Our
listed capabilities (provenance, identity, enumeration, conflict
resolution) are instances of this set, not arbitrary choices.

\textbf{Information-Theoretic Interpretation:} Information theory tells
us that discarding information removes the ability to answer queries that depend on that
information. The Bases axis contains information about inheritance
relationships. Shape-based typing discards this axis. Therefore, any
query that depends on inheritance---provenance, identity, enumeration,
conflict resolution---cannot be answered. This follows from the structure
of the information available.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Completeness and Robustness Theorems}\label{completeness-robustness-theorems}

This section presents additional theorems that establish the completeness
and robustness of our results. Each theorem addresses a specific aspect
of the model's coverage.

\paragraph{3.11.1 Model Completeness}\label{model-completeness}

\textbf{Theorem 3.32 (Model Completeness).}\label{thm:model-completeness} The \((N, B, S)\) model
captures all information constitutive of a type. Any computable function
over types is expressible as a function of \((N, B, S)\).

\emph{Proof.} The proof proceeds by constitutive definition, not empirical
enumeration.

In Python, \texttt{type(name, bases, namespace)} is the universal type
constructor. Every type \(T\) is created by some invocation
\texttt{type(n, b, s)}---either explicitly or via the \texttt{class}
statement (which is syntactic sugar for \texttt{type()}). A type does not
merely \emph{have} \((N, B, S)\); a type \emph{is} \((N, B, S)\). There is
no other information constitutive of a type object.

Therefore, for any computable function \(g : \text{Type} \to \alpha\):
\[g(T) = g(\texttt{type}(n, b, s)) = h(n, b, s)\]
for some computable \(h\). Any function of a type is definitionally a
function of the triple that constitutes it.

\textbf{Remark (Derived vs.\ Constitutive).} Properties like
\texttt{\_\_mro\_\_} (method resolution order) or \texttt{\_\_module\_\_}
are not counterexamples: MRO is computed from \(B\) by C3 linearization;
\texttt{\_\_module\_\_} is stored in the namespace \(S\). These are
\emph{derived from} or \emph{contained in} \((N, B, S)\), not independent
of it.

This is a definitional closure: a critic cannot exhibit a ``fourth axis''
because any proposed axis is either (a) stored in \(S\), (b) computable
from \((N, B, S)\), or (c) not part of the type's semantic identity
(e.g., memory address). \(\blacksquare\)

\textbf{Corollary 3.33 (No Hidden Information).} There exists no
``fourth axis'' that shape-based typing could use to recover provenance.
The information is structurally absent---not because we failed to model
it, but because types \emph{are} \((N, B, S)\) by construction.

\paragraph{3.11.2 Capability Comparison}\label{capability-comparison}

\textbf{Theorem 3.34 (Capability Superset).} Let
\(\mathcal{C}_{\text{duck}}\) be the capabilities available under duck
typing. Let \(\mathcal{C}_{\text{nom}}\) be the capabilities under
nominal typing. Then:
\[\mathcal{C}_{\text{duck}} \subseteq \mathcal{C}_{\text{nom}}\]

\emph{Proof.} Duck typing operations are: 1. Attribute access:
\texttt{getattr(obj,\ "name")} 2. Attribute existence:
\texttt{hasattr(obj,\ "name")} 3. Method invocation:
\texttt{obj.method()}

All three operations are available in nominal systems. Nominal typing
adds type identity operations; it does not remove duck typing
operations. \(\blacksquare\)

\textbf{Theorem 3.35 (Strict Superset).} The inclusion is strict:
\[\mathcal{C}_{\text{duck}} \subsetneq \mathcal{C}_{\text{nom}}\]

\emph{Proof.} Nominal typing provides provenance, identity, enumeration,
and conflict resolution (Theorem 2.17). Duck typing cannot provide these
(Theorem 3.13). Therefore:
\[\mathcal{C}_{\text{nom}} = \mathcal{C}_{\text{duck}} \cup \mathcal{C}_B\]
where \(\mathcal{C}_B \neq \emptyset\). \(\blacksquare\)

\textbf{Corollary 3.36 (No Capability Tradeoff).} Choosing nominal
typing over duck typing: - Forecloses \textbf{zero} capabilities - Gains
\textbf{four} capabilities

There is no capability tradeoff. Nominal typing strictly dominates.

\textbf{Remark (Capability vs.~Code Compatibility).} The capability
superset does not mean ``all duck-typed code runs unchanged under
nominal typing.'' It means ``every operation expressible in duck typing
is expressible in nominal typing.'' The critical distinction:

\begin{itemize}
\item
  \textbf{False equivalence} (duck typing): \texttt{WellFilterConfig}
  and \texttt{StepWellFilterConfig} are structurally identical but
  semantically distinct (different MRO positions, different scopes).
  Duck typing conflates them---it literally cannot answer ``which type
  is this?'' This is not flexibility; it is \textbf{information
  destruction}.
\item
  \textbf{Type distinction} (nominal typing):
  \texttt{isinstance(config,\ StepWellFilterConfig)} distinguishes them
  in O(1). The distinction is expressible because nominal typing
  preserves type identity.
\end{itemize}

Duck typing's ``acceptance'' of structurally-equivalent types is not a
capability---it is the \emph{absence} of the capability to distinguish
them. Nominal typing adds this capability without removing any duck
typing operation. See Case Study 1 (ยง5.2, Theorem 5.1) for the complete
production example demonstrating that structural identity $\\neq$ semantic
identity.

\paragraph{3.11.3 Axiom Justification}\label{axiom-justification}

\textbf{Lemma 3.37 (Shape Axiom is Definitional).}\label{lem:shape-axiom-definitional} The axiom
``shape-based typing treats same-namespace types identically'' is not an
assumption---it is the \textbf{definition} of shape-based typing.

\emph{Proof.} Shape-based typing is defined as a typing discipline over
\(\{S\}\) only (Definition 2.10). If a discipline uses information from
\(B\) (the Bases axis) to distinguish types, it is, by definition, not
shape-based.

The axiom is not: ``We assume shape typing can't distinguish same-shape
types.'' The axiom is: ``Shape typing means treating same-shape types
identically.''

Any system that distinguishes same-shape types is using \(B\)
(explicitly or implicitly). \(\blacksquare\)

\textbf{Corollary 3.38 (No Clever Shape System).} There exists no
``clever'' shape-based system that can distinguish types \(A\) and \(B\)
with \(S(A) = S(B)\). Such a system would, by definition, not be
shape-based.

\paragraph{3.11.4 Extension
Impossibility}\label{extension-impossibility}

\textbf{Theorem 3.39 (Extension Impossibility).}\label{thm:extension-impossibility} Let \(\mathcal{D}\) be
any duck typing system. Let \(\mathcal{D}'\) be \(\mathcal{D}\) extended
with any computable function \(f : \text{Namespace} \to \alpha\). Then
\(\mathcal{D}'\) still cannot compute provenance.

\emph{Proof.} Provenance requires distinguishing types \(A\) and \(B\)
where \(S(A) = S(B)\) but \(\text{prov}(A, a) \neq \text{prov}(B, a)\)
for some attribute \(a\).

Any function \(f : \text{Namespace} \to \alpha\) maps \(A\) and \(B\) to
the same value, since \(S(A) = S(B)\) implies \(f\) receives identical
input for both.

Therefore, \(f\) provides no distinguishing information. The only way to
distinguish \(A\) from \(B\) is to use information not in
\(\text{Namespace}\)---i.e., the Bases axis \(B\).

No computable extension over \(\{N, S\}\) alone can recover provenance.
\(\blacksquare\)

\textbf{Corollary 3.40 (No Future Fix).} No future language feature,
library, or tool operating within the duck typing paradigm can provide
provenance. The limitation is structural, not technical.

\paragraph{3.11.5 Scope Boundaries}\label{scope-boundaries}

We explicitly scope our claims:

\textbf{Non-Claim 3.41 (Untyped Code).} This paper does not claim
nominal typing applies to systems where \(B = \emptyset\) (no
inheritance). For untyped code being gradually typed (Siek \& Taha
2006), the dynamic type \texttt{?} is appropriate. However, for retrofit
scenarios where \(B \neq \emptyset\), adapters make nominal typing
available (Theorem 2.10j).

\textbf{Non-Claim 3.42 (Interop Boundaries).} At boundaries with untyped
systems (FFI, JSON parsing, external APIs), structural typing via
Protocols is \emph{convenient} but not necessary. Per Theorem 2.10j,
explicit adapters provide the same functionality with better properties.
Protocol is a dominated choice---a concession, not an alternative
(Corollary 2.10k'). Choosing Protocol accepts reduced capabilities to
defer adapter work.

\paragraph{3.11.6 Capability
Exhaustiveness}\label{capability-exhaustiveness}

\textbf{Theorem 3.43a (Capability Exhaustiveness).} The four
capabilities (provenance, identity, enumeration, conflict resolution)
are \textbf{exhaustive}---they are the only capabilities derivable from
the Bases axis.

\emph{Proof.} (Machine-checked in \texttt{nominal\_resolution.lean},
Section 6: CapabilityExhaustiveness)

The Bases axis provides MRO, a \textbf{list of types}. A list has
exactly three queryable properties: 1. \textbf{Ordering}: Which element
precedes which? $\\rightarrow$ \emph{Conflict resolution} (C3 linearization selects
based on MRO order) 2. \textbf{Membership}: Is element X in the list? $\\rightarrow$
\emph{Enumeration} (subtype iff in some type's MRO) 3. \textbf{Element
identity}: Which specific element? $\\rightarrow$ \emph{Provenance} and \emph{type
identity} (distinguish structurally-equivalent types by MRO position)

These are exhaustive by the structure of lists---there are no other
operations on a list that do not reduce to ordering, membership, or
element identity. Therefore, the four capabilities are derived from MRO
structure, not enumerated by inspection. \(\blacksquare\)

\textbf{Corollary 3.43b (No Missing Capability).} Any capability claimed
to require \(B\) reduces to one of the four. There is no ``fifth
capability'' that \(B\) provides.

\emph{Proof.} Any operation on \(B\) is an operation on MRO. Any
operation on MRO is an operation on a list. List operations are
exhaustively \{ordering, membership, identity\}. \(\blacksquare\)

\textbf{Theorem 3.43b-bis (Capability Reducibility).} Every B-dependent
query reduces to a composition of the four primitive capabilities.

\emph{Proof.} Let \(q : \text{Type} \to \alpha\) be any B-dependent
query (per Definition 3.17). By Definition 3.17, \(q\) distinguishes
types with identical structure:
\(\exists A, B: S(A) = S(B) \land q(A) \neq q(B)\).

The only information distinguishing \(A\) from \(B\) is: -
\(N(A) \neq N(B)\) (name)---but names are part of identity, covered by
\textbf{type\_identity} - \(B(A) \neq B(B)\) (bases)---distinguishes
via: - Ancestor membership: is \(T \in \text{ancestors}(A)\)? $\\rightarrow$ covered
by \textbf{provenance} - Subtype enumeration: what are all
\(T : T <: A\)? $\\rightarrow$ covered by \textbf{enumeration} - MRO position: which
type wins for attribute \(a\)? $\\rightarrow$ covered by
\textbf{conflict\_resolution}

No other distinguishing information exists (Theorem 3.32: \((N, B, S)\)
is complete).

Therefore any B-dependent query \(q\) can be computed by composing:
\[q(T) = f(\text{provenance}(T), \text{identity}(T), \text{enumeration}(T), \text{conflict\_resolution}(T))\]
for some computable \(f\). \(\blacksquare\)

\paragraph{3.11.6a Adapter Cost Analysis}\label{a-adapter-cost-analysis}

\textbf{Theorem 3.43c (Adapter Declaration is Information-Preserving).}
An adapter declares information that is \textbf{already true}---that a
type conforms to an interface. Declaration does not create the
conformance; it makes it explicit.

\emph{Proof.} If \texttt{TheirType} does not satisfy \texttt{YourABC}'s
interface, the adapter fails at definition time (missing method error).
If \texttt{TheirType} does satisfy the interface, the conformance
existed before the adapter. The adapter is not implementation---it is
documentation of pre-existing fact. \(\blacksquare\)

\textbf{Theorem 3.43d (Adapter Amortization).} Adapter cost is O(1).
Manual capability implementation is O(N) where N is the number of use
sites.

\emph{Proof.} (Machine-checked in \texttt{nominal\_resolution.lean},
Section 7: AdapterAmortization)

Under nominal typing (with adapter): - Provenance: Automatic via
\texttt{type(obj).\_\_mro\_\_} (0 additional code per use) - Identity:
Automatic via \texttt{isinstance()} (0 additional code per use) -
Enumeration: Automatic via \texttt{\_\_subclasses\_\_()} (0 additional
code per use) - Conflict resolution: Automatic via C3 (0 additional code
per use)

Under structural typing (without adapter), to recover any capability
manually: - Provenance: Must thread source information through call
sites (1 additional parameter $\\times$ N calls) - Identity: Must maintain
external type registry (1 registry + N registration calls) -
Enumeration: Must maintain external subtype set (1 set + N insertions) -
Conflict resolution: Must implement manual dispatch (1 dispatcher + N
cases)

The adapter is 2 lines. Manual implementation is \(\Omega(N)\). For
\(N \geq 1\), adapter dominates. \(\blacksquare\)

\textbf{Corollary 3.43e (Negative Adapter Cost).} Adapter ``cost'' is
negative---a net benefit.

\emph{Proof.} The adapter enables automatic capabilities that would
otherwise require O(N) manual implementation. The adapter costs O(1).
For any system requiring the capabilities, adapter provides net savings
of \(\Omega(N) - O(1) = \Omega(N)\). The ``cost'' is negative.
\(\blacksquare\)

\textbf{Corollary 3.43f (Adapter Cost Objection is Invalid).} Objecting
to adapter cost is objecting to O(1) overhead while accepting O(N)
overhead. This is mathematically incoherent.

\paragraph{3.11.6b Methodological
Independence}\label{b-methodological-independence}

\textbf{Theorem 3.43g (Methodological Independence).}\label{thm:methodological-independence} The dominance
theorems are derived from the structure of \((N, B, S)\), not from any
implementation. OpenHCS is an existential witness, not a premise.

\emph{Proof.} We distinguish two logical roles:
\begin{itemize}
\tightlist
\item \textbf{Premise:} A proposition the conclusion depends on. If false,
  the conclusion may not follow.
\item \textbf{Existential witness:} A concrete example demonstrating
  satisfiability. Removing it does not affect the theorem's validity.
\end{itemize}

Examine the proof of Theorem 3.13 (Provenance Impossibility): it shows
that \((N, S)\) contains insufficient information to compute provenance.
This is an information-theoretic argument referencing no codebase. The
proof could be written before any codebase existed.

\textbf{Proof chain (no OpenHCS references):}
\begin{enumerate}
\tightlist
\item Theorem 2.17 (Capability Gap): Proved from the definition of
  shape-based typing
\item Theorem 3.5 (Strict Dominance): Proved from Theorem 2.17 + Theorem 2.18
\item Theorem 2.10j (Adapters): Proved from capability comparison
\end{enumerate}

OpenHCS appears only to demonstrate that the four capabilities are
\emph{achievable}---that real systems use provenance, identity,
enumeration, and conflict resolution. This is an existence proof
(``such systems exist''), not a premise (``if OpenHCS works, then
the theorems hold'').

\textbf{Analogy:} Proving ``comparison-based sorting requires
\(\Omega(n \log n)\)'' does not require testing on multiple arrays.
Exhibiting quicksort demonstrates achievability, not theorem validity.
\(\blacksquare\)

\textbf{Corollary 3.43h (Cross-Codebase Validity).} The theorems apply
to any codebase in any language where \(B \neq \emptyset\). OpenHCS is a
sufficient example, not a necessary one.

\paragraph{3.11.6c Inheritance Ubiquity}\label{c-inheritance-ubiquity}

\textbf{Theorem 3.43i (Inheritance Ubiquity).} In Python,
\(B = \emptyset\) requires actively avoiding all standard tooling. Any
project using \(\geq 1\) of the following has \(B \neq \emptyset\) by
construction:

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2273}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2273}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.5455}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Category
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Examples
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Why \(B \neq \emptyset\)
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Exceptions & \texttt{raise\ MyError()} & Must subclass
\texttt{Exception} \\
Web frameworks & Django, Flask, FastAPI & Views/models inherit framework
bases \\
Testing & pytest classes, unittest & Test classes inherit
\texttt{TestCase} or use class fixtures \\
ORM & SQLAlchemy, Django ORM & Models inherit declarative
\texttt{Base} \\
Data validation & Pydantic, attrs & Models inherit \texttt{BaseModel} \\
Enumerations & \texttt{class\ Color(Enum)} & Must subclass
\texttt{Enum} \\
Abstract interfaces & ABC, Protocol with inheritance & Defines
inheritance hierarchy \\
Dataclasses & \texttt{@dataclass} with inheritance & Parent class in
\texttt{\_\_bases\_\_} \\
Context managers & Class-based \texttt{\_\_enter\_\_/\_\_exit\_\_} &
Often inherit helper bases \\
Type extensions & \texttt{typing.NamedTuple}, \texttt{TypedDict} &
Inherit from typing constructs \\
\end{longtable}

\emph{Proof.} Each listed feature requires defining or inheriting from a
class with non-trivial bases. In Python, even an ``empty'' class
\texttt{class\ X:\ pass} has \texttt{X.\_\_bases\_\_\ ==\ (object,)}, so
\(B \supseteq \{\texttt{object}\}\). For \(B = \emptyset\) to hold, a
project must use:

\begin{itemize}
\tightlist
\item
  No user-defined exceptions (use only built-in exceptions)
\item
  No web frameworks (no Django, Flask, FastAPI, Starlette, etc.)
\item
  No ORM (no SQLAlchemy, Django ORM, Peewee, etc.)
\item
  No Pydantic, attrs, or dataclass inheritance
\item
  No Enum
\item
  No ABC or Protocol inheritance
\item
  No pytest/unittest class-based tests
\item
  No class-based context managers
\item
  Pure functional style with only module-level functions and built-in
  types
\end{itemize}

This describes a pathologically constrained subset of Python---not
``most code'' but ``no OOP at all.'' \(\blacksquare\)

\textbf{Corollary 3.43j (B=$\\emptyset$ Is Exceptional).} The \(B = \emptyset\)
case applies only to: 1. Languages without inheritance by design (Go) 2.
Pure data serialization boundaries (JSON parsing before domain modeling)
3. FFI boundaries (ctypes, CFFI) before wrapping in domain types 4.
Purely functional codebases with no class definitions

In all other cases---which constitute the overwhelming majority of
production Python, Java, C\#, TypeScript, Kotlin, Swift, Scala, and C++
code---\(B \neq \emptyset\) and nominal typing strictly dominates.

\textbf{Corollary 3.43k (Inheritance Prevalence).} A claim that
``\(B = \emptyset\) is the common case'' would require exhibiting a non-trivial
production codebase using none of the tooling in Theorem 3.43i. No such
codebase is known to exist in the Python ecosystem.

\paragraph{3.11.7 Generics and Parametric
Polymorphism}\label{generics-and-parametric-polymorphism}

\textbf{Theorem 3.43 (Generics Preserve Axis Structure).} Parametric
polymorphism does not introduce a fourth axis. Type parameters are a
refinement of \(N\), not additional information orthogonal to
\((N, B, S)\).

\emph{Proof.} A parameterized type \(G\langle T \rangle\) (e.g.,
\texttt{List\textless{}Dog\textgreater{}}) has: -
\(N(G\langle T \rangle) = (N(G), N(T))\) --- the parameterized name is a
pair - \(B(G\langle T \rangle) = B(G)[T/\tau]\) --- bases with parameter
substituted - \(S(G\langle T \rangle) = S(G)[T/\tau]\) --- namespace
with parameter in signatures

No additional axis is required. The type parameter is encoded in \(N\).
\(\blacksquare\)

\textbf{Theorem 3.44 (Generic Shape Indistinguishability).} Under
shape-based typing, \texttt{List\textless{}Dog\textgreater{}} and
\texttt{Set\textless{}Cat\textgreater{}} are indistinguishable if
\(S(\text{List}\langle\text{Dog}\rangle) = S(\text{Set}\langle\text{Cat}\rangle)\).

\emph{Proof.} Shape typing uses only \(S\). If two parameterized types
have the same method signatures (after parameter substitution), shape
typing treats them identically. It cannot distinguish: - The base
generic type (\texttt{List} vs \texttt{Set}) - The type parameter
(\texttt{Dog} vs \texttt{Cat}) - The generic inheritance hierarchy

These require \(N\) (for parameter identity) and \(B\) (for hierarchy).
\(\blacksquare\)

\textbf{Theorem 3.45 (Generic Capability Gap Extends).} The four
capabilities from \(\mathcal{C}_B\) (provenance, identity, enumeration,
conflict resolution) apply to generic types. Generics do not reduce the
capability gap---they \textbf{increase the type space} where it applies.

\emph{Proof.} For generic types, the four capabilities manifest as: 1.
\textbf{Provenance:} ``Which generic type provided this method?'' ---
requires \(B\) 2. \textbf{Identity:} ``Is this
\texttt{List\textless{}Dog\textgreater{}} or
\texttt{Set\textless{}Cat\textgreater{}}?'' --- requires parameterized
\(N\) 3. \textbf{Enumeration:} ``What are the subtypes of
\texttt{Collection\textless{}T\textgreater{}}?'' --- requires \(B\) 4.
\textbf{Conflict resolution:} ``Which
\texttt{Comparable\textless{}T\textgreater{}} implementation wins?'' ---
requires \(B\)

Additionally, generics introduce \textbf{variance} (covariant,
contravariant, invariant), which requires \(B\) to track inheritance
direction. Shape typing discards \(B\) and the parameter component of
\(N\), losing all four capabilities plus variance. \(\blacksquare\)

\textbf{Corollary 3.45.1 (Same Four, Larger Space).} Generics do not
create new capabilities---they apply the same four capabilities to a
larger type space. The capability gap is preserved, not reduced.

\textbf{Theorem 3.46 (Erasure Does Not Save Shape Typing).} In languages
with type erasure (Java), the capability gap still exists.

\emph{Proof.} Type checking occurs at compile time, where full
parameterized types are available. Erasure only affects runtime
representations. Our theorems about typing disciplines apply to the type
system (compile time), not runtime behavior.

At compile time: - The type checker has access to
\texttt{List\textless{}Dog\textgreater{}} vs
\texttt{List\textless{}Cat\textgreater{}} - Shape typing cannot
distinguish them if method signatures match - Nominal typing can
distinguish them

At runtime (erased): - Both become \texttt{List} (erased) - Shape typing
cannot distinguish \texttt{ArrayList} from \texttt{LinkedList} - Nominal
typing can (via \texttt{instanceof})

The capability gap exists at both levels. \(\blacksquare\)

\textbf{Theorem 3.47 (Universal Extension).} All capability gap theorems
(3.13, 3.19, 3.24) extend to generic type systems. The formal results
apply to:

\begin{itemize}
\tightlist
\item
  \textbf{Erased generics:} Java, Scala, Kotlin
\item
  \textbf{Reified generics:} C\#, Kotlin (inline reified)
\item
  \textbf{Monomorphized generics:} Rust, C++ (templates)
\item
  \textbf{Compile-time only:} TypeScript, Swift
\end{itemize}

\emph{Proof.} Each language encodes generics as parameterized \(N\) (see
Table 2.2). The \((N, B, S)\) model applies uniformly. Type checking
occurs at compile time where full parameterized types are available.
Runtime representation (erased, reified, or monomorphized) is irrelevant
to typing discipline. \(\blacksquare\)

\textbf{Corollary 3.48 (No Generic Escape).} Generics do not provide an
escape from the capability gap. No major language invented a fourth
axis.

\textbf{Remark 3.49 (Exotic Type Features).} Intersection types, union
types, row polymorphism, higher-kinded types, and multiple dispatch do
not escape the \((N, B, S)\) model:

\begin{itemize}
\tightlist
\item
  \textbf{Intersection/union types} (TypeScript \texttt{A\ \&\ B},
  \texttt{A\ \textbar{}\ B}): Refine \(N\), combine \(B\) and \(S\).
  Still three axes.
\item
  \textbf{Row polymorphism} (OCaml
  \texttt{\textless{}\ x:\ int;\ ..\ \textgreater{}}): Pure structural
  typing using \(S\) only, but with a \emph{declared} interface (unlike
  duck typing). OCaml row types are coherent (Theorem 2.10d does not
  apply) but still lose the four \(B\)-dependent capabilities
  (provenance, identity, enumeration, conflict resolution) and cannot
  provide metaprogramming hooks (Theorem 2.10p).
\item
  \textbf{Higher-kinded types} (Haskell \texttt{Functor},
  \texttt{Monad}): Parameterized \(N\) at the type-constructor level.
  Typeclass hierarchies provide \(B\).
\item
  \textbf{Multiple dispatch} (Julia): Type hierarchies exist
  (\texttt{AbstractArray\ \textless{}:\ Any}). \(B\) axis present.
  Dispatch semantics are orthogonal to type structure.
\item
  \textbf{Prototype-based inheritance} (JavaScript): Prototype chain IS
  the \(B\) axis at object level. \texttt{Object.getPrototypeOf()}
  traverses MRO.
\end{itemize}

No mainstream type system feature introduces a fourth axis orthogonal to
\((N, B, S)\).

\paragraph{3.11.7 Scope Expansion: From Greenfield to
Universal}\label{scope-expansion-from-greenfield-to-universal}

\textbf{Theorem 3.50 (Universal Optimality).} Wherever inheritance
hierarchies exist and are accessible, nominal typing provides strictly
more capabilities than shape-based typing. This is not limited to
greenfield development.

\emph{Proof.} The capability gap (Theorem 3.19) is
information-theoretic: shape typing discards \(B\), losing four
capabilities. This holds regardless of: - Whether code is new or legacy
- Whether the language is compiled or interpreted - Whether types are
manifest or inferred - Whether the system uses classes, traits,
protocols, or typeclasses

The gap exists wherever \(B\) exists. \(\blacksquare\)

\textbf{Corollary 3.51 (Scope of Shape Typing).} Shape-based typing is
capability-equivalent to nominal typing only when:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{No hierarchy exists:} \(B = \emptyset\) (e.g., Go interfaces,
  JSON objects)
\item
  \textbf{Hierarchy is inaccessible:} True FFI boundaries where type
  metadata is lost
\end{enumerate}

When \(B \neq \emptyset\), shape-based typing is \textbf{always
dominated} by nominal typing with adapters (Theorem 2.10j).
``Deliberately ignored'' is not a valid justification---it is an
admission of choosing the dominated option.

\textbf{Claim 3.52 (Universal).} For ALL object-oriented systems where
inheritance hierarchies exist and are accessible---including legacy
codebases, dynamic languages, and functional languages with
typeclasses---nominal typing is strictly optimal. Shape-based typing is
a \textbf{capability sacrifice}, not an alternative with tradeoffs.

\paragraph{3.11.8 Discipline Optimality vs Migration
Optimality}\label{discipline-optimality-vs-migration-optimality}

A critical distinction:
\textbf{discipline optimality} (which typing paradigm has more
capabilities) is independent of \textbf{migration optimality} (whether
migrating an existing codebase is beneficial).

\textbf{Definition 3.53 (Pareto Dominance).} Discipline \(A\) Pareto
dominates discipline \(B\) if: 1. \(A\) provides all capabilities of
\(B\) 2. \(A\) provides at least one capability \(B\) lacks 3. The
declaration cost of \(A\) is at most the declaration cost of \(B\)

\textbf{Theorem 3.54 (Nominal Pareto Dominates Shape).} Nominal typing
Pareto dominates shape-based typing.

\emph{Proof.} (Machine-checked in \texttt{discipline\_migration.lean})
1. Shape capabilities = \{attributeCheck\} 2. Nominal capabilities =
\{provenance, identity, enumeration, conflictResolution,
attributeCheck\} 3. Shape $\\subset$ Nominal (strict subset) 4. Declaration cost:
both require one class definition per interface 5. Therefore nominal
Pareto dominates shape. \(\blacksquare\)

\textbf{Theorem 3.55 (Dominance Does Not Imply Migration).}\label{thm:dominance-not-migration} Pareto
dominance of discipline \(A\) over \(B\) does NOT imply that migrating
from \(B\) to \(A\) is beneficial for all codebases.

\emph{Proof.} (Machine-checked in \texttt{discipline\_migration.lean})

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Dominance is codebase-independent.} \(D(A, B)\) (``\(A\)
  dominates \(B\)'') is a relation on typing disciplines. It depends
  only on capability sets:
  \(\text{Capabilities}(A) \supset \text{Capabilities}(B)\). This is a
  property of the disciplines themselves, not of any codebase.
\item
  \textbf{Migration cost is codebase-dependent.} Let \(C(ctx)\) be the
  cost of migrating codebase \(ctx\) from \(B\) to \(A\). Migration
  requires modifying: type annotations using \(B\)-specific constructs,
  call sites relying on \(B\)-specific semantics, and external API
  boundaries (which may be immutable). Each of these quantities is
  unbounded: there exist codebases with arbitrarily many annotations,
  call sites, and external dependencies.
\item
  \textbf{Benefit is bounded.} The benefit of migration is the
  capability gap:
  \(|\text{Capabilities}(A) \setminus \text{Capabilities}(B)|\). For
  nominal vs structural, this is 4 (provenance, identity, enumeration,
  conflict resolution). This is a constant, independent of codebase
  size.
\item
  \textbf{Unbounded cost vs bounded benefit.} For any fixed benefit
  \(B\), there exists a codebase \(ctx\) such that \(C(ctx) > B\). This
  follows from (2) and (3): cost grows without bound, benefit does not.
\item
  \textbf{Existence of both cases.} For small \(ctx\): \(C(ctx) < B\)
  (migration beneficial). For large \(ctx\): \(C(ctx) > B\) (migration
  not beneficial).
\end{enumerate}

Therefore dominance does not determine migration benefit.
\(\blacksquare\)

\textbf{Corollary 3.55a (Category Error).} Conflating ``discipline \(A\)
is better'' with ``migrate to \(A\)'' is a category error: the former is
a property of disciplines (universal), the latter is a property of
(discipline, codebase) pairs (context-dependent).

\textbf{Corollary 3.56 (Discipline vs Migration Independence).} The
question ``which discipline is better?'' (answered by Theorem 3.54) is
independent of ``should I migrate?'' (answered by cost-benefit
analysis).

This distinguishes ``nominal provides more capabilities'' from ``rewrite everything
in nominal.'' The theorems are:
\begin{itemize}
\tightlist
\item \textbf{Discipline comparison}: Universal, always true (Theorem 3.54)
\item \textbf{Migration decision}: Context-dependent, requires cost-benefit
analysis (Theorem 3.55)
\end{itemize}

\paragraph{3.11.9 Context Formalization: Greenfield and Retrofit
(Historical)}\label{context-formalization-greenfield-and-retrofit-historical}

\textbf{Note.} The following definitions were used in earlier versions
of this paper to distinguish contexts where nominal typing was
``available'' from those where it was not. Theorem 2.10j (Adapters)
eliminates this distinction: adapters make nominal typing available in
all retrofit contexts. We retain these definitions for completeness and
because the Lean formalization verifies them.

\textbf{Definition 3.57 (Greenfield Context).} A development context is
\emph{greenfield} if: 1. All modules are internal (architect can modify
type hierarchies) 2. No constraints require structural typing (e.g.,
JSON API compatibility)

\textbf{Definition 3.58 (Retrofit Context).} A development context is
\emph{retrofit} if: 1. At least one module is external (cannot modify
type hierarchies), OR 2. At least one constraint requires structural
typing

\textbf{Theorem 3.59 (Context Classification Exclusivity).} Greenfield
and retrofit contexts are mutually exclusive.

\emph{Proof.} (Machine-checked in \texttt{context\_formalization.lean})
If a context is greenfield, all modules are internal and no constraints
require structural typing. If any module is external or any constraint
requires structural typing, the context is retrofit. These conditions
are mutually exclusive by construction. \(\blacksquare\)

\textbf{Corollary 3.59a (Retrofit Does Not Imply Structural).} A
retrofit context does not require structural typing. Adapters (Theorem
2.10j) make nominal typing available in all retrofit contexts where
\(B \neq \emptyset\).

\textbf{Definition 3.60 (Provenance-Requiring Query).} A system query
\emph{requires provenance} if it needs to distinguish between
structurally equivalent types. Examples: - ``Which type provided this
value?'' (provenance) - ``Is this the same type?'' (identity) - ``What
are all subtypes?'' (enumeration) - ``Which type wins in MRO?''
(conflict resolution)

\textbf{Theorem 3.61 (Provenance Detection).} Whether a system requires
provenance is decidable from its query set.

\emph{Proof.} (Machine-checked in \texttt{context\_formalization.lean})
Each query type is classified as requiring provenance or not. A system
requires provenance iff any of its queries requires provenance. This is
a finite check over a finite query set. \(\blacksquare\)

\textbf{Theorem 3.62 (Decision Procedure Soundness).} The discipline
selection procedure is sound: 1. If \(B \neq \emptyset\) $\\rightarrow$ select
Nominal (dominance, universal) 2. If \(B = \emptyset\) $\\rightarrow$ select Shape
(no alternative exists)

\emph{Proof.} (Machine-checked in \texttt{context\_formalization.lean})
Case 1: When \(B \neq \emptyset\), nominal typing strictly dominates
shape-based typing (Theorem 3.5). Adapters eliminate the retrofit
exception (Theorem 2.10j). Therefore nominal is always correct. Case 2:
When \(B = \emptyset\) (e.g., Go interfaces, JSON objects), nominal
typing is undefined---there is no inheritance to track. Shape is the
only coherent discipline. \(\blacksquare\)

\textbf{Remark (Obsolescence of Greenfield/Retrofit Distinction).}
Earlier versions of this paper distinguished ``greenfield'' (use
nominal) from ``retrofit'' (use shape). Theorem 2.10j eliminates this
distinction: adapters make nominal typing available in all retrofit
contexts. The only remaining distinction is whether \(B\) exists at all.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Summary: Completeness Analysis}\label{summary-completeness-analysis}

\small
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5143}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4857}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Potential Concern
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Formal Analysis
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
``Model is incomplete'' & Theorem 3.32 (Model Completeness) \\
``Duck typing has tradeoffs'' & Theorems 3.34-3.36 (Capability Comparison) \\
``Axioms are assumptive'' & Lemma 3.37 (Axiom is Definitional) \\
``Clever extension could fix it'' & Theorem 3.39 (Extension
Impossibility) \\
``What about generics?'' & Theorems 3.43-3.48, Table 2.2 (Parameterized
N) \\
``Erasure changes things'' & Theorems 3.46-3.47 (Compile-Time Type
Checking) \\
``Only works for some languages'' & Theorem 3.47 (8 languages), Remark
3.49 (exotic features) \\
``What about intersection/union types?'' & Remark 3.49 (still three
axes) \\
``What about row polymorphism?'' & Remark 3.49 (pure S, loses
capabilities) \\
``What about higher-kinded types?'' & Remark 3.49 (parameterized N) \\
``Only applies to greenfield'' & Theorem 2.10j (Adapters eliminate
retrofit exception) \\
``Legacy codebases are different'' & Corollary 3.51 (sacrifice, not
alternative) \\
``Claims are too broad'' & Non-Claims 3.41-3.42 (true scope limits) \\
``You can't say rewrite everything'' & Theorem 3.55 (Dominance $\neq$
Migration) \\
``Greenfield is undefined'' & Definitions 3.57-3.58, Theorem 3.59 \\
``Provenance requirement is circular'' & Theorem 3.61 (Provenance
Detection) \\
``Duck typing is coherent'' & Theorem 2.10d (Incoherence) \\
``Protocol is valid for retrofit'' & Theorem 2.10j (Dominated by
Adapters) \\
``Avoiding adapters is a benefit'' & Corollary 2.10k (Negative Value) \\
``Protocol has equivalent metaprogramming'' & Theorem 2.10p (Hooks
Require Declarations) \\
``You can enumerate Protocol implementers'' & Theorem 2.10q (Enumeration
Requires Registration) \\
\end{longtable}

\textbf{Completeness.} Appendix~\ref{appendix:robustness} provides detailed
analysis of each potential concern, demonstrating why none affect our conclusions.
The analysis covers model completeness, capability characterization, scope
boundaries, and the distinction between discipline dominance and migration
recommendation.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

